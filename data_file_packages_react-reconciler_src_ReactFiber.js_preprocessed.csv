,commit ID,author name,committer name,message,URL,commit date,message_preprocessed
0,C_kwDOAJy2KtoAKDk0ZTRhY2FhMTQ3N2U2NWNhYzAyYmE4NjA1OGNkZTBhZmU0YzhmMWY,Sebastian Markbåge,GitHub,"[Fiber] Set profiler values to doubles (#30942)

At some point this trick was added to initialize the value first to NaN
and then replace them with zeros and negative ones.

This is to address the issue noted in
https://github.com/facebook/react/issues/14365 where these hidden
classes can be initialized to SMIs at first and then deopt when we
realize they're actually doubles.

However, this fix has been long broken and has deopted the profiling
build for years because closure compiler optimizes out the first write.

I'm not sure because I haven't A/B-tested this in the JIT yet but I
think we can use negative zero and -1.1 as the initial values instead
since they're not simple integers. Negative zero `===` zero (but not
Object.is) so is the same as far as our code is concerned. The negative
value is just `< 0` comparisons.",https://api.github.com/repos/facebook/react/git/commits/94e4acaa1477e65cac02ba86058cde0afe4c8f1f,2024-09-13,[Fiber] Set profiler values to doubles (#30942)
0,C_kwDOAJy2KtoAKDk0ZTRhY2FhMTQ3N2U2NWNhYzAyYmE4NjA1OGNkZTBhZmU0YzhmMWY,Sebastian Markbåge,GitHub,"[Fiber] Set profiler values to doubles (#30942)

At some point this trick was added to initialize the value first to NaN
and then replace them with zeros and negative ones.

This is to address the issue noted in
https://github.com/facebook/react/issues/14365 where these hidden
classes can be initialized to SMIs at first and then deopt when we
realize they're actually doubles.

However, this fix has been long broken and has deopted the profiling
build for years because closure compiler optimizes out the first write.

I'm not sure because I haven't A/B-tested this in the JIT yet but I
think we can use negative zero and -1.1 as the initial values instead
since they're not simple integers. Negative zero `===` zero (but not
Object.is) so is the same as far as our code is concerned. The negative
value is just `< 0` comparisons.",https://api.github.com/repos/facebook/react/git/commits/94e4acaa1477e65cac02ba86058cde0afe4c8f1f,2024-09-13,"At some point this trick was added to initialize the value first to NaN
and then replace them with zeros and negative ones"
0,C_kwDOAJy2KtoAKDk0ZTRhY2FhMTQ3N2U2NWNhYzAyYmE4NjA1OGNkZTBhZmU0YzhmMWY,Sebastian Markbåge,GitHub,"[Fiber] Set profiler values to doubles (#30942)

At some point this trick was added to initialize the value first to NaN
and then replace them with zeros and negative ones.

This is to address the issue noted in
https://github.com/facebook/react/issues/14365 where these hidden
classes can be initialized to SMIs at first and then deopt when we
realize they're actually doubles.

However, this fix has been long broken and has deopted the profiling
build for years because closure compiler optimizes out the first write.

I'm not sure because I haven't A/B-tested this in the JIT yet but I
think we can use negative zero and -1.1 as the initial values instead
since they're not simple integers. Negative zero `===` zero (but not
Object.is) so is the same as far as our code is concerned. The negative
value is just `< 0` comparisons.",https://api.github.com/repos/facebook/react/git/commits/94e4acaa1477e65cac02ba86058cde0afe4c8f1f,2024-09-13,"
This is to address the issue noted in
where these hidden
classes can be initialized to SMIs at first and then deopt when we
realize they're actually doubles"
0,C_kwDOAJy2KtoAKDk0ZTRhY2FhMTQ3N2U2NWNhYzAyYmE4NjA1OGNkZTBhZmU0YzhmMWY,Sebastian Markbåge,GitHub,"[Fiber] Set profiler values to doubles (#30942)

At some point this trick was added to initialize the value first to NaN
and then replace them with zeros and negative ones.

This is to address the issue noted in
https://github.com/facebook/react/issues/14365 where these hidden
classes can be initialized to SMIs at first and then deopt when we
realize they're actually doubles.

However, this fix has been long broken and has deopted the profiling
build for years because closure compiler optimizes out the first write.

I'm not sure because I haven't A/B-tested this in the JIT yet but I
think we can use negative zero and -1.1 as the initial values instead
since they're not simple integers. Negative zero `===` zero (but not
Object.is) so is the same as far as our code is concerned. The negative
value is just `< 0` comparisons.",https://api.github.com/repos/facebook/react/git/commits/94e4acaa1477e65cac02ba86058cde0afe4c8f1f,2024-09-13,"
However, this fix has been long broken and has deopted the profiling
build for years because closure compiler optimizes out the first write"
0,C_kwDOAJy2KtoAKDk0ZTRhY2FhMTQ3N2U2NWNhYzAyYmE4NjA1OGNkZTBhZmU0YzhmMWY,Sebastian Markbåge,GitHub,"[Fiber] Set profiler values to doubles (#30942)

At some point this trick was added to initialize the value first to NaN
and then replace them with zeros and negative ones.

This is to address the issue noted in
https://github.com/facebook/react/issues/14365 where these hidden
classes can be initialized to SMIs at first and then deopt when we
realize they're actually doubles.

However, this fix has been long broken and has deopted the profiling
build for years because closure compiler optimizes out the first write.

I'm not sure because I haven't A/B-tested this in the JIT yet but I
think we can use negative zero and -1.1 as the initial values instead
since they're not simple integers. Negative zero `===` zero (but not
Object.is) so is the same as far as our code is concerned. The negative
value is just `< 0` comparisons.",https://api.github.com/repos/facebook/react/git/commits/94e4acaa1477e65cac02ba86058cde0afe4c8f1f,2024-09-13,"
I'm not sure because I haven't A/B-tested this in the JIT yet but I
think we can use negative zero and -1.1 as the initial values instead
since they're not simple integers"
0,C_kwDOAJy2KtoAKDk0ZTRhY2FhMTQ3N2U2NWNhYzAyYmE4NjA1OGNkZTBhZmU0YzhmMWY,Sebastian Markbåge,GitHub,"[Fiber] Set profiler values to doubles (#30942)

At some point this trick was added to initialize the value first to NaN
and then replace them with zeros and negative ones.

This is to address the issue noted in
https://github.com/facebook/react/issues/14365 where these hidden
classes can be initialized to SMIs at first and then deopt when we
realize they're actually doubles.

However, this fix has been long broken and has deopted the profiling
build for years because closure compiler optimizes out the first write.

I'm not sure because I haven't A/B-tested this in the JIT yet but I
think we can use negative zero and -1.1 as the initial values instead
since they're not simple integers. Negative zero `===` zero (but not
Object.is) so is the same as far as our code is concerned. The negative
value is just `< 0` comparisons.",https://api.github.com/repos/facebook/react/git/commits/94e4acaa1477e65cac02ba86058cde0afe4c8f1f,2024-09-13,"Negative zero `===` zero (but not
Object.is) so is the same as far as our code is concerned"
0,C_kwDOAJy2KtoAKDk0ZTRhY2FhMTQ3N2U2NWNhYzAyYmE4NjA1OGNkZTBhZmU0YzhmMWY,Sebastian Markbåge,GitHub,"[Fiber] Set profiler values to doubles (#30942)

At some point this trick was added to initialize the value first to NaN
and then replace them with zeros and negative ones.

This is to address the issue noted in
https://github.com/facebook/react/issues/14365 where these hidden
classes can be initialized to SMIs at first and then deopt when we
realize they're actually doubles.

However, this fix has been long broken and has deopted the profiling
build for years because closure compiler optimizes out the first write.

I'm not sure because I haven't A/B-tested this in the JIT yet but I
think we can use negative zero and -1.1 as the initial values instead
since they're not simple integers. Negative zero `===` zero (but not
Object.is) so is the same as far as our code is concerned. The negative
value is just `< 0` comparisons.",https://api.github.com/repos/facebook/react/git/commits/94e4acaa1477e65cac02ba86058cde0afe4c8f1f,2024-09-13,"The negative
value is just `< 0` comparisons."
1,C_kwDOAJy2KtoAKDhkNjhkYTNmNzM5NjA2NDYxNGYzNGI4NDg4MWZlODgzM2I2MDM5YWM,Sebastian Markbåge,GitHub,"[Fiber] Stash ThenableState on the Dependencies Object for Use By DevTools (#30866)

This lets us track what a Component might suspend on from DevTools. We
could already collect this by replaying a component's Hooks but that
would be expensive to collect from a whole tree.

The thenables themselves might contain useful information but mainly
we'd want access to the `_debugInfo` on the thenables which might
contain additional information from the server.


https://github.com/facebook/react/blob/19bd26beb689e554fceb0b929dc5199be8cba594/packages/shared/ReactTypes.js#L114

In a follow up we should really do something similar in Flight to
transfer `use()` on the debugInfo of that Server Component.",https://api.github.com/repos/facebook/react/git/commits/8d68da3f7396064614f34b84881fe8833b6039ac,2024-09-03,[Fiber] Stash ThenableState on the Dependencies Object for Use By DevTools (#30866)
1,C_kwDOAJy2KtoAKDhkNjhkYTNmNzM5NjA2NDYxNGYzNGI4NDg4MWZlODgzM2I2MDM5YWM,Sebastian Markbåge,GitHub,"[Fiber] Stash ThenableState on the Dependencies Object for Use By DevTools (#30866)

This lets us track what a Component might suspend on from DevTools. We
could already collect this by replaying a component's Hooks but that
would be expensive to collect from a whole tree.

The thenables themselves might contain useful information but mainly
we'd want access to the `_debugInfo` on the thenables which might
contain additional information from the server.


https://github.com/facebook/react/blob/19bd26beb689e554fceb0b929dc5199be8cba594/packages/shared/ReactTypes.js#L114

In a follow up we should really do something similar in Flight to
transfer `use()` on the debugInfo of that Server Component.",https://api.github.com/repos/facebook/react/git/commits/8d68da3f7396064614f34b84881fe8833b6039ac,2024-09-03,This lets us track what a Component might suspend on from DevTools
1,C_kwDOAJy2KtoAKDhkNjhkYTNmNzM5NjA2NDYxNGYzNGI4NDg4MWZlODgzM2I2MDM5YWM,Sebastian Markbåge,GitHub,"[Fiber] Stash ThenableState on the Dependencies Object for Use By DevTools (#30866)

This lets us track what a Component might suspend on from DevTools. We
could already collect this by replaying a component's Hooks but that
would be expensive to collect from a whole tree.

The thenables themselves might contain useful information but mainly
we'd want access to the `_debugInfo` on the thenables which might
contain additional information from the server.


https://github.com/facebook/react/blob/19bd26beb689e554fceb0b929dc5199be8cba594/packages/shared/ReactTypes.js#L114

In a follow up we should really do something similar in Flight to
transfer `use()` on the debugInfo of that Server Component.",https://api.github.com/repos/facebook/react/git/commits/8d68da3f7396064614f34b84881fe8833b6039ac,2024-09-03,"We
could already collect this by replaying a component's Hooks but that
would be expensive to collect from a whole tree"
1,C_kwDOAJy2KtoAKDhkNjhkYTNmNzM5NjA2NDYxNGYzNGI4NDg4MWZlODgzM2I2MDM5YWM,Sebastian Markbåge,GitHub,"[Fiber] Stash ThenableState on the Dependencies Object for Use By DevTools (#30866)

This lets us track what a Component might suspend on from DevTools. We
could already collect this by replaying a component's Hooks but that
would be expensive to collect from a whole tree.

The thenables themselves might contain useful information but mainly
we'd want access to the `_debugInfo` on the thenables which might
contain additional information from the server.


https://github.com/facebook/react/blob/19bd26beb689e554fceb0b929dc5199be8cba594/packages/shared/ReactTypes.js#L114

In a follow up we should really do something similar in Flight to
transfer `use()` on the debugInfo of that Server Component.",https://api.github.com/repos/facebook/react/git/commits/8d68da3f7396064614f34b84881fe8833b6039ac,2024-09-03,"
The thenables themselves might contain useful information but mainly
we'd want access to the `_debugInfo` on the thenables which might
contain additional information from the server"
1,C_kwDOAJy2KtoAKDhkNjhkYTNmNzM5NjA2NDYxNGYzNGI4NDg4MWZlODgzM2I2MDM5YWM,Sebastian Markbåge,GitHub,"[Fiber] Stash ThenableState on the Dependencies Object for Use By DevTools (#30866)

This lets us track what a Component might suspend on from DevTools. We
could already collect this by replaying a component's Hooks but that
would be expensive to collect from a whole tree.

The thenables themselves might contain useful information but mainly
we'd want access to the `_debugInfo` on the thenables which might
contain additional information from the server.


https://github.com/facebook/react/blob/19bd26beb689e554fceb0b929dc5199be8cba594/packages/shared/ReactTypes.js#L114

In a follow up we should really do something similar in Flight to
transfer `use()` on the debugInfo of that Server Component.",https://api.github.com/repos/facebook/react/git/commits/8d68da3f7396064614f34b84881fe8833b6039ac,2024-09-03,"
In a follow up we should really do something similar in Flight to
transfer `use()` on the debugInfo of that Server Component."
2,C_kwDOAJy2KtoAKDE0YTQ2OTlmZjE3MzkzNmEzMGVjNDUzZjdiOTRkNDcxMDViYmIyNTI,Jack Pope,GitHub,"Remove allowConcurrentByDefault flag (#30445)

Following https://github.com/facebook/react/pull/30436

Concurrent by default strategy has been unshipped. Here we clean up the
`allowConcurrentByDefault` path and related logic/tests.

For now, this keeps the `concurrentUpdatesByDefaultOverride` argument in
`createContainer` and `createHydrationContainer` and ignores the value
to prevent more breaking changes to `react-reconciler` in the RC stage.",https://api.github.com/repos/facebook/react/git/commits/14a4699ff173936a30ec453f7b94d47105bbb252,2024-07-25,Remove allowConcurrentByDefault flag (#30445)
2,C_kwDOAJy2KtoAKDE0YTQ2OTlmZjE3MzkzNmEzMGVjNDUzZjdiOTRkNDcxMDViYmIyNTI,Jack Pope,GitHub,"Remove allowConcurrentByDefault flag (#30445)

Following https://github.com/facebook/react/pull/30436

Concurrent by default strategy has been unshipped. Here we clean up the
`allowConcurrentByDefault` path and related logic/tests.

For now, this keeps the `concurrentUpdatesByDefaultOverride` argument in
`createContainer` and `createHydrationContainer` and ignores the value
to prevent more breaking changes to `react-reconciler` in the RC stage.",https://api.github.com/repos/facebook/react/git/commits/14a4699ff173936a30ec453f7b94d47105bbb252,2024-07-25,"Following 
Concurrent by default strategy has been unshipped"
2,C_kwDOAJy2KtoAKDE0YTQ2OTlmZjE3MzkzNmEzMGVjNDUzZjdiOTRkNDcxMDViYmIyNTI,Jack Pope,GitHub,"Remove allowConcurrentByDefault flag (#30445)

Following https://github.com/facebook/react/pull/30436

Concurrent by default strategy has been unshipped. Here we clean up the
`allowConcurrentByDefault` path and related logic/tests.

For now, this keeps the `concurrentUpdatesByDefaultOverride` argument in
`createContainer` and `createHydrationContainer` and ignores the value
to prevent more breaking changes to `react-reconciler` in the RC stage.",https://api.github.com/repos/facebook/react/git/commits/14a4699ff173936a30ec453f7b94d47105bbb252,2024-07-25,"Here we clean up the
`allowConcurrentByDefault` path and related logic/tests"
2,C_kwDOAJy2KtoAKDE0YTQ2OTlmZjE3MzkzNmEzMGVjNDUzZjdiOTRkNDcxMDViYmIyNTI,Jack Pope,GitHub,"Remove allowConcurrentByDefault flag (#30445)

Following https://github.com/facebook/react/pull/30436

Concurrent by default strategy has been unshipped. Here we clean up the
`allowConcurrentByDefault` path and related logic/tests.

For now, this keeps the `concurrentUpdatesByDefaultOverride` argument in
`createContainer` and `createHydrationContainer` and ignores the value
to prevent more breaking changes to `react-reconciler` in the RC stage.",https://api.github.com/repos/facebook/react/git/commits/14a4699ff173936a30ec453f7b94d47105bbb252,2024-07-25,"
For now, this keeps the `concurrentUpdatesByDefaultOverride` argument in
`createContainer` and `createHydrationContainer` and ignores the value
to prevent more breaking changes to `react-reconciler` in the RC stage."
3,C_kwDOAJy2KtoAKGU5MDJjNDVjYWY3Y2E2NzgxMGQzZTUzNzQ4YTU0OWJkY2MzNjA2M2I,Jack Pope,GitHub,"Remove forceConcurrentByDefaultForTesting flag (#30436)

Concurrent by default has been unshipped! Let's clean it up.

Here we remove `forceConcurrentByDefaultForTesting`, which allows us to
run tests against both concurrent strategies. In the next PR, we'll
remove the actual concurrent by default code path.",https://api.github.com/repos/facebook/react/git/commits/e902c45caf7ca67810d3e53748a549bdcc36063b,2024-07-24,Remove forceConcurrentByDefaultForTesting flag (#30436)
3,C_kwDOAJy2KtoAKGU5MDJjNDVjYWY3Y2E2NzgxMGQzZTUzNzQ4YTU0OWJkY2MzNjA2M2I,Jack Pope,GitHub,"Remove forceConcurrentByDefaultForTesting flag (#30436)

Concurrent by default has been unshipped! Let's clean it up.

Here we remove `forceConcurrentByDefaultForTesting`, which allows us to
run tests against both concurrent strategies. In the next PR, we'll
remove the actual concurrent by default code path.",https://api.github.com/repos/facebook/react/git/commits/e902c45caf7ca67810d3e53748a549bdcc36063b,2024-07-24,Concurrent by default has been unshipped! Let's clean it up
3,C_kwDOAJy2KtoAKGU5MDJjNDVjYWY3Y2E2NzgxMGQzZTUzNzQ4YTU0OWJkY2MzNjA2M2I,Jack Pope,GitHub,"Remove forceConcurrentByDefaultForTesting flag (#30436)

Concurrent by default has been unshipped! Let's clean it up.

Here we remove `forceConcurrentByDefaultForTesting`, which allows us to
run tests against both concurrent strategies. In the next PR, we'll
remove the actual concurrent by default code path.",https://api.github.com/repos/facebook/react/git/commits/e902c45caf7ca67810d3e53748a549bdcc36063b,2024-07-24,"
Here we remove `forceConcurrentByDefaultForTesting`, which allows us to
run tests against both concurrent strategies"
3,C_kwDOAJy2KtoAKGU5MDJjNDVjYWY3Y2E2NzgxMGQzZTUzNzQ4YTU0OWJkY2MzNjA2M2I,Jack Pope,GitHub,"Remove forceConcurrentByDefaultForTesting flag (#30436)

Concurrent by default has been unshipped! Let's clean it up.

Here we remove `forceConcurrentByDefaultForTesting`, which allows us to
run tests against both concurrent strategies. In the next PR, we'll
remove the actual concurrent by default code path.",https://api.github.com/repos/facebook/react/git/commits/e902c45caf7ca67810d3e53748a549bdcc36063b,2024-07-24,"In the next PR, we'll
remove the actual concurrent by default code path."
4,C_kwDOAJy2KtoAKGI3ZTdmMWEzZmFiODdlOGZjMTllODZhODA4OGE5ZTBmZTQ3MTA5NzM,Jan Kassens,GitHub,"[BE] upgrade prettier to 3.3.3 (#30420)

Mostly just changes in ternary formatting.",https://api.github.com/repos/facebook/react/git/commits/b7e7f1a3fab87e8fc19e86a8088a9e0fe4710973,2024-07-22,[BE] upgrade prettier to 3.3.3 (#30420)
4,C_kwDOAJy2KtoAKGI3ZTdmMWEzZmFiODdlOGZjMTllODZhODA4OGE5ZTBmZTQ3MTA5NzM,Jan Kassens,GitHub,"[BE] upgrade prettier to 3.3.3 (#30420)

Mostly just changes in ternary formatting.",https://api.github.com/repos/facebook/react/git/commits/b7e7f1a3fab87e8fc19e86a8088a9e0fe4710973,2024-07-22,Mostly just changes in ternary formatting.
5,C_kwDOAJy2KtoAKGQ3YzQzMzRjZTkxNzI2ZGRmZjRiNmJhODRmZjZiZDgxZWIzYTkxZDU,Jan Kassens,GitHub,Add _debugStack and _debugTask under enableObjectFiber flag (#30337),https://api.github.com/repos/facebook/react/git/commits/d7c4334ce91726ddff4b6ba84ff6bd81eb3a91d5,2024-07-22,Add _debugStack and _debugTask under enableObjectFiber flag (#30337)
5,C_kwDOAJy2KtoAKGQ3YzQzMzRjZTkxNzI2ZGRmZjRiNmJhODRmZjZiZDgxZWIzYTkxZDU,Jan Kassens,GitHub,Add _debugStack and _debugTask under enableObjectFiber flag (#30337),https://api.github.com/repos/facebook/react/git/commits/d7c4334ce91726ddff4b6ba84ff6bd81eb3a91d5,2024-07-22,
6,C_kwDOAJy2KtoAKGZlOTgyODk1NGFkY2M1MWFhMmJkMjFmZTUzZDk2OWE0NGRkM2M5ZDI,Jan Kassens,GitHub,"Experiment with using an object literal for Fiber creation (#28734)

Object literals should be faster at least on React Native with Hermes as
the JS engine.
It might also be interesting to confirm the old comments in this file
from years ago are even still valid. Creating an object from a literal
should be a simpler operation.

It's a bit unfortunate that this introduces a bunch of copied code, but
since we rearely update the fields on fibers, this seems like an okay
tradeoff for a hot code path. An alternative would be some sort of macro
system, but that doesn't seem worth the extra complexity.",https://api.github.com/repos/facebook/react/git/commits/fe9828954adcc51aa2bd21fe53d969a44dd3c9d2,2024-07-10,Experiment with using an object literal for Fiber creation (#28734)
6,C_kwDOAJy2KtoAKGZlOTgyODk1NGFkY2M1MWFhMmJkMjFmZTUzZDk2OWE0NGRkM2M5ZDI,Jan Kassens,GitHub,"Experiment with using an object literal for Fiber creation (#28734)

Object literals should be faster at least on React Native with Hermes as
the JS engine.
It might also be interesting to confirm the old comments in this file
from years ago are even still valid. Creating an object from a literal
should be a simpler operation.

It's a bit unfortunate that this introduces a bunch of copied code, but
since we rearely update the fields on fibers, this seems like an okay
tradeoff for a hot code path. An alternative would be some sort of macro
system, but that doesn't seem worth the extra complexity.",https://api.github.com/repos/facebook/react/git/commits/fe9828954adcc51aa2bd21fe53d969a44dd3c9d2,2024-07-10,"Object literals should be faster at least on React Native with Hermes as
the JS engine"
6,C_kwDOAJy2KtoAKGZlOTgyODk1NGFkY2M1MWFhMmJkMjFmZTUzZDk2OWE0NGRkM2M5ZDI,Jan Kassens,GitHub,"Experiment with using an object literal for Fiber creation (#28734)

Object literals should be faster at least on React Native with Hermes as
the JS engine.
It might also be interesting to confirm the old comments in this file
from years ago are even still valid. Creating an object from a literal
should be a simpler operation.

It's a bit unfortunate that this introduces a bunch of copied code, but
since we rearely update the fields on fibers, this seems like an okay
tradeoff for a hot code path. An alternative would be some sort of macro
system, but that doesn't seem worth the extra complexity.",https://api.github.com/repos/facebook/react/git/commits/fe9828954adcc51aa2bd21fe53d969a44dd3c9d2,2024-07-10,"
It might also be interesting to confirm the old comments in this file
from years ago are even still valid"
6,C_kwDOAJy2KtoAKGZlOTgyODk1NGFkY2M1MWFhMmJkMjFmZTUzZDk2OWE0NGRkM2M5ZDI,Jan Kassens,GitHub,"Experiment with using an object literal for Fiber creation (#28734)

Object literals should be faster at least on React Native with Hermes as
the JS engine.
It might also be interesting to confirm the old comments in this file
from years ago are even still valid. Creating an object from a literal
should be a simpler operation.

It's a bit unfortunate that this introduces a bunch of copied code, but
since we rearely update the fields on fibers, this seems like an okay
tradeoff for a hot code path. An alternative would be some sort of macro
system, but that doesn't seem worth the extra complexity.",https://api.github.com/repos/facebook/react/git/commits/fe9828954adcc51aa2bd21fe53d969a44dd3c9d2,2024-07-10,"Creating an object from a literal
should be a simpler operation"
6,C_kwDOAJy2KtoAKGZlOTgyODk1NGFkY2M1MWFhMmJkMjFmZTUzZDk2OWE0NGRkM2M5ZDI,Jan Kassens,GitHub,"Experiment with using an object literal for Fiber creation (#28734)

Object literals should be faster at least on React Native with Hermes as
the JS engine.
It might also be interesting to confirm the old comments in this file
from years ago are even still valid. Creating an object from a literal
should be a simpler operation.

It's a bit unfortunate that this introduces a bunch of copied code, but
since we rearely update the fields on fibers, this seems like an okay
tradeoff for a hot code path. An alternative would be some sort of macro
system, but that doesn't seem worth the extra complexity.",https://api.github.com/repos/facebook/react/git/commits/fe9828954adcc51aa2bd21fe53d969a44dd3c9d2,2024-07-10,"
It's a bit unfortunate that this introduces a bunch of copied code, but
since we rearely update the fields on fibers, this seems like an okay
tradeoff for a hot code path"
6,C_kwDOAJy2KtoAKGZlOTgyODk1NGFkY2M1MWFhMmJkMjFmZTUzZDk2OWE0NGRkM2M5ZDI,Jan Kassens,GitHub,"Experiment with using an object literal for Fiber creation (#28734)

Object literals should be faster at least on React Native with Hermes as
the JS engine.
It might also be interesting to confirm the old comments in this file
from years ago are even still valid. Creating an object from a literal
should be a simpler operation.

It's a bit unfortunate that this introduces a bunch of copied code, but
since we rearely update the fields on fibers, this seems like an okay
tradeoff for a hot code path. An alternative would be some sort of macro
system, but that doesn't seem worth the extra complexity.",https://api.github.com/repos/facebook/react/git/commits/fe9828954adcc51aa2bd21fe53d969a44dd3c9d2,2024-07-10,"An alternative would be some sort of macro
system, but that doesn't seem worth the extra complexity."
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,Warn for invalid type in renderer with the correct RSC stack (#30102)
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,This is all behind the `enableOwnerStacks` flag
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,"
This is a follow up to #29088"
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,"In that I moved type validation into the
renderer since that's the one that knows what types are allowed"
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,"
However, I only removed it from `React.createElement` and not the JSX
which was an oversight"
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,"
However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid"
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,We should use its stack for the stack trace
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,"That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack"
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,"This is fixed by creating a fake
Throw Fiber that gets assigned the right stack"
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,"
Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error"
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,"Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not"
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,"Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case"
7,C_kwDOAJy2KtoAKGUwMmJhZjZjOTI4MzNhMGQ0NWE3N2ZiMmU3NDE2NzZmMzkzYzI0Zjc,Sebastian Markbåge,GitHub,"Warn for invalid type in renderer with the correct RSC stack (#30102)

This is all behind the `enableOwnerStacks` flag.

This is a follow up to #29088. In that I moved type validation into the
renderer since that's the one that knows what types are allowed.
However, I only removed it from `React.createElement` and not the JSX
which was an oversight.

However, I also noticed that for invalid types we don't have the right
stack trace for throws because we're not yet inside the JSX element that
itself is invalid. We should use its stack for the stack trace. That's
the reason it's enough to just use the throw now because we can get a
good stack trace from the owner stack. This is fixed by creating a fake
Throw Fiber that gets assigned the right stack.

Additionally, I noticed that for certain invalid types like the most
common one `undefined` we error in Flight so a missing import in RSC
leads to a generic error. Instead of erroring on the Flight side we
should just let anything that's not a Server Component through to the
client and then let the Client renderer determine whether it's a valid
type or not. Since we now have owner stacks through the server too, this
will still be able to provide a good stack trace on the client that
points to the server in that case.

<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""https://github.com/facebook/react/assets/63648/6812c24f-e274-4e09-b4de-21deda9ea1d4"">

To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](https://issues.chromium.org/issues/345248263) which makes it a
little harder to find but once that's fixed it might be easier.",https://api.github.com/repos/facebook/react/git/commits/e02baf6c92833a0d45a77fb2e741676f393c24f7,2024-06-27,"
<img width=""571"" alt=""Screenshot 2024-06-25 at 6 46 35 PM""
src=""
To get the best stack you have to expand the little icon and the regular
stack is noisy [due to this Chrome
bug](which makes it a
little harder to find but once that's fixed it might be easier."
8,C_kwDOAJy2KtoAKGI1NjUzNzNhZmQwY2MxOTg4NDk3ZTExMDcxMDZlODUxZThjZmIyNjE,Jan Kassens,GitHub,"lint: enable reportUnusedDisableDirectives and remove unused suppressions (#28721)

This enables linting against unused suppressions and removes the ones
that were unused.",https://api.github.com/repos/facebook/react/git/commits/b565373afd0cc1988497e1107106e851e8cfb261,2024-06-21,lint: enable reportUnusedDisableDirectives and remove unused suppressions (#28721)
8,C_kwDOAJy2KtoAKGI1NjUzNzNhZmQwY2MxOTg4NDk3ZTExMDcxMDZlODUxZThjZmIyNjE,Jan Kassens,GitHub,"lint: enable reportUnusedDisableDirectives and remove unused suppressions (#28721)

This enables linting against unused suppressions and removes the ones
that were unused.",https://api.github.com/repos/facebook/react/git/commits/b565373afd0cc1988497e1107106e851e8cfb261,2024-06-21,"This enables linting against unused suppressions and removes the ones
that were unused."
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,This lets us rethrow it in the conceptual place of the child
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"
There's currently a problem when we suspend or throw in the child fiber
reconciliation phase"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"
However, conceptually it's like a child suspended or errored"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"
In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"
Mainly this happens because a Server Component that errors turns into a
`React.lazy`"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"In practice this means that if you have a Server Component
as the direct child of an Error Boundary"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"Errors inside of it won't be
caught"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"
We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"This fixes it for thrown
promises but it doesn't fix it for SuspenseException"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"I'm not sure this
is even the right strategy for Suspense though"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"It kind of relies on the
node never actually mounting/committing"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"
It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"Such as
SuspenseList"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"
The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error"
9,C_kwDOAJy2KtoAKDI3MDIyOWYwYzMzN2RjNjUyZjA3ZWYyN2QyMjU0YmI5MjJiZmFhOWU,Sebastian Markbåge,GitHub,"[Fiber] Create virtual Fiber when an error occurs during reconcilation (#29804)

This lets us rethrow it in the conceptual place of the child.

There's currently a problem when we suspend or throw in the child fiber
reconciliation phase. This work is done by the parent component, so if
it suspends or errors it is as if that component errored or suspended.
However, conceptually it's like a child suspended or errored.

In theory any thing can throw but it is really mainly due to either
`React.lazy` (both in the element.type position and node position),
`Thenable`s or the `Thenable`s that make up `AsyncIterable`s.

Mainly this happens because a Server Component that errors turns into a
`React.lazy`. In practice this means that if you have a Server Component
as the direct child of an Error Boundary. Errors inside of it won't be
caught.

We used to have the same problem with Thenables and Suspense but because
it's now always nested inside an inner Offscreen boundary that shields
it by being one level nested. However, when we have raw Offscreen
(Activity) boundaries they should also be able to catch the suspense if
it's in a hidden state so the problem returns. This fixes it for thrown
promises but it doesn't fix it for SuspenseException. I'm not sure this
is even the right strategy for Suspense though. It kind of relies on the
node never actually mounting/committing.

It's conceptually a little tricky because the current component can
inspect the children and make decisions based on them. Such as
SuspenseList.

The other thing that this PR tries to address is that it sets the
foundation for dealing with error reporting for Server Components that
errored. If something client side errors it'll be a stack like Server
(DebugInfo) -> Fiber -> Fiber -> Server -> (DebugInfo) -> Fiber.
However, all error reporting relies on it eventually terminating into a
Fiber that is responsible for the error. To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber.",https://api.github.com/repos/facebook/react/git/commits/270229f0c337dc652f07ef27d2254bb922bfaa9e,2024-06-11,"To avoid having to fork too
much it would be nice if I could create a Fiber to associate with the
error so that even a Server component error in this case ultimately
terminates in a Fiber."
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,This one should be fully behind the `enableOwnerStacks` flag
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"
Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"Mainly it provides the line number of the JSX
callsite"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"In terms of the number of components is a subset of the parent
component stack so it's less information in that regard"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this)"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"
__Follow ups__
- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"They're also not yet printed in the server logs of the
RSC server"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"
- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,E.g
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"if
server is running V8 and browser is running JSC or vice versa"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"Ideally
we can reformat them in terms of the client formatting"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"
- This doesn't yet update Fizz or DevTools"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,Those will be follow ups
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"
Fizz still prints parent stacks in the server side logs"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"
- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override"
10,C_kwDOAJy2KtoAKGQ2Y2ZhMGYyOTVmNGM4YjM2NmFmMTVmZDIwYzg0ZTI3Y2RkMWZhYjc,Sebastian Markbåge,GitHub,"[Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)

This one should be fully behind the `enableOwnerStacks` flag.

Instead of printing the parent Component stack all the way to the root,
this now prints the owner stack of every JSX callsite. It also includes
intermediate callsites between the Component and the JSX call so it has
potentially more frames. Mainly it provides the line number of the JSX
callsite. In terms of the number of components is a subset of the parent
component stack so it's less information in that regard. This is usually
better since it's more focused on components that might affect the
output but if it's contextual based on rendering it's still good to have
parent stack. Therefore, I still use the parent stack when printing DOM
nesting warnings but I plan on switching that format to a diff view
format instead (Next.js already reformats the parent stack like this).

__Follow ups__

- Server Components show up in the owner stack for client logs but logs
done by Server Components don't yet get their owner stack printed as
they're replayed. They're also not yet printed in the server logs of the
RSC server.

- Server Component stack frames are formatted as the server and added to
the end but this might be a different format than the browser. E.g. if
server is running V8 and browser is running JSC or vice versa. Ideally
we can reformat them in terms of the client formatting.

- This doesn't yet update Fizz or DevTools. Those will be follow ups.
Fizz still prints parent stacks in the server side logs. The stacks
added to user space `console.error` calls by DevTools still get the
parent stacks instead.

- It also doesn't yet expose these to user space so there's no way to
get them inside `onCaughtError` for example or inside a custom
`console.error` override.

- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available.",https://api.github.com/repos/facebook/react/git/commits/d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7,2024-05-25,"
- In another follow up I'll use `console.createTask` instead and
completely remove these stacks if it's available."
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,Move createElement/JSX Warnings into the Renderer (#29088)
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"This is necessary to simplify the component stack handling to make way
for owner stacks"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"It also solves some hacks that we used to have but
don't quite make sense"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"It also solves the problem where things like key
warnings get silenced in RSC because they get deduped"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"It also surfaces
areas where we were missing key warnings to begin with"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
Almost every type of warning is issued from the renderer"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"React Elements
are really not anything special themselves"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"They're just lazily invoked
functions and its really the renderer that determines there semantics"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
We have three types of warnings that previously fired in
JSX/createElement:
- Fragment props validation"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
- Type validation"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
- Key warning"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"However,
that's the case for every type of component and validation"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"That's the
whole point of enableOwnerStacks"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"So
this validation is really just an eager validation but also happens
again later"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
The problem with these is that we don't really know what types are valid
until we get to the renderer"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"It also means we can't reuse logic
for managing stacks etc"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
Fragment props validation really should just be part of the renderer
like any other component type"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"This also matters once we add Fragment
refs and other fragment features"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,So I moved this into Fiber
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
For `type` validation we already do validation when rendering"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"By
leaving it to the renderer we don't have to hard code an extra list"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
This list also varies by context"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,E.g
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"I
normalized some of the errors to ensure tests pass"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
For `key` validation it's the same principle"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
I also added logging to Fizz so that key warnings can print in SSR logs"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
Flight is a bit more complex"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info"
11,C_kwDOAJy2KtoAKDg0MjM5ZGE4OTZmZDczOTVhNjY3YWIxZTdlZjFlZjMzOGEzMmRlOGY,Sebastian Markbåge,GitHub,"Move createElement/JSX Warnings into the Renderer (#29088)

This is necessary to simplify the component stack handling to make way
for owner stacks. It also solves some hacks that we used to have but
don't quite make sense. It also solves the problem where things like key
warnings get silenced in RSC because they get deduped. It also surfaces
areas where we were missing key warnings to begin with.

Almost every type of warning is issued from the renderer. React Elements
are really not anything special themselves. They're just lazily invoked
functions and its really the renderer that determines there semantics.

We have three types of warnings that previously fired in
JSX/createElement:

- Fragment props validation.
- Type validation.
- Key warning.

It's nice to be able to do some validation in the JSX/createElement
because it has a more specific stack frame at the callsite. However,
that's the case for every type of component and validation. That's the
whole point of enableOwnerStacks. It's also not sufficient to do it in
JSX/createElement so we also have validation in the renderers too. So
this validation is really just an eager validation but also happens
again later.

The problem with these is that we don't really know what types are valid
until we get to the renderer. Additionally, by placing it in the
isomorphic code it becomes harder to do deduping of warnings in a way
that makes sense for that renderer. It also means we can't reuse logic
for managing stacks etc.

Fragment props validation really should just be part of the renderer
like any other component type. This also matters once we add Fragment
refs and other fragment features. So I moved this into Fiber. However,
since some Fragments don't have Fibers, I do the validation in
ChildFiber instead of beginWork where it would normally happen.

For `type` validation we already do validation when rendering. By
leaving it to the renderer we don't have to hard code an extra list.
This list also varies by context. E.g. class components aren't allowed
in RSC but client references are but we don't have an isomorphic way to
identify client references because they're defined by the host config so
the current logic is flawed anyway. I kept the early validation for now
without the `enableOwnerStacks` since it does provide a nicer stack
frame but with that flag on it'll be handled with nice stacks anyway. I
normalized some of the errors to ensure tests pass.

For `key` validation it's the same principle. The mechanism for the
heuristic is still the same - if it passes statically through a parent
JSX/createElement call then it's considered validated. We already did
print the error later from the renderer so this also disables the early
log in the `enableOwnerStacks` flag.

I also added logging to Fizz so that key warnings can print in SSR logs.

Flight is a bit more complex. For elements that end up on the client we
just pass the `validated` flag along to the client and let the client
renderer print the error once rendered. For server components we log the
error from Flight with the server component as the owner on the stack
which will allow us to print the right stack for context. The factoring
of this is a little tricky because we only want to warn if it's in an
array parent but we want to log the error later to get the right debug
info.

Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools.",https://api.github.com/repos/facebook/react/git/commits/84239da896fd7395a667ab1e7ef1ef338a32de8f,2024-05-23,"
Fiber/Fizz has a similar factoring problem that causes us to create a
fake Fiber for the owner which means the logs won't be associated with
the right place in DevTools."
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,Track Owner for Server Components in DEV (#28753)
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"This implements the concept of a DEV-only ""owner"" for Server Components"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"
The owner concept isn't really super useful"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"However, this is mainly interesting because it could
be used to wire up future owner-based stacks"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"
I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo)"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"Then I just rely on Flight deduping to refer to
that"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"
If you suspend and replay a Server Component, we have to restore the
same owner"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"To do that, I did a little ugly hack and stashed it on the
thenable state object"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"
The owner could really be anything since it could be coming from a
different implementation"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"
This also doesn't actually add it to DevTools / RN Inspector yet"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"I just
ignore them there for now"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"
Because Server Components can be async the owner isn't tracked after an
await"
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,We need per-component AsyncLocalStorage for that
12,C_kwDOAJy2KtoAKGYzM2E2YjY5YzZjYjQwNmVhMGNjNTFkMDdiYzRkM2ZkMmQ4ZDg3NDQ,Sebastian Markbåge,GitHub,"Track Owner for Server Components in DEV (#28753)

This implements the concept of a DEV-only ""owner"" for Server Components.
The owner concept isn't really super useful. We barely use it anymore,
but we do have it as a concept in DevTools in a couple of cases so this
adds it for parity. However, this is mainly interesting because it could
be used to wire up future owner-based stacks.

I do this by outlining the DebugInfo for a Server Component
(ReactComponentInfo). Then I just rely on Flight deduping to refer to
that. I refer to the same thing by referential equality so that we can
associate a Server Component parent in DebugInfo with an owner.

If you suspend and replay a Server Component, we have to restore the
same owner. To do that, I did a little ugly hack and stashed it on the
thenable state object. Felt unnecessarily complicated to add a stateful
wrapper for this one dev-only case.

The owner could really be anything since it could be coming from a
different implementation. Because this is the first time we have an
owner other than Fiber, I have to fix up a bunch of places that assumes
Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
Fiber for now.

This also doesn't actually add it to DevTools / RN Inspector yet. I just
ignore them there for now.

Because Server Components can be async the owner isn't tracked after an
await. We need per-component AsyncLocalStorage for that. This can be
done in a follow up.",https://api.github.com/repos/facebook/react/git/commits/f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744,2024-04-05,"This can be
done in a follow up."
13,C_kwDOAJy2KtoAKDVkZTg3MDM2NDZjZGQzODM4Y2IxNjg2Zjc2MWIxMGMwNjkyNzQzYWE,Sebastian Markbåge,GitHub,"Use the disableLegacyMode where ever we check the ConcurrentMode mode (#28657)

Saves some bytes and ensures that we're actually disabling it.

Turns out this flag wasn't disabling React Native/Fabric, React Noop and
React ART legacy modes so those are updated too.

Should be rebased on #28681.",https://api.github.com/repos/facebook/react/git/commits/5de8703646cdd3838cb1686f761b10c0692743aa,2024-04-03,Use the disableLegacyMode where ever we check the ConcurrentMode mode (#28657)
13,C_kwDOAJy2KtoAKDVkZTg3MDM2NDZjZGQzODM4Y2IxNjg2Zjc2MWIxMGMwNjkyNzQzYWE,Sebastian Markbåge,GitHub,"Use the disableLegacyMode where ever we check the ConcurrentMode mode (#28657)

Saves some bytes and ensures that we're actually disabling it.

Turns out this flag wasn't disabling React Native/Fabric, React Noop and
React ART legacy modes so those are updated too.

Should be rebased on #28681.",https://api.github.com/repos/facebook/react/git/commits/5de8703646cdd3838cb1686f761b10c0692743aa,2024-04-03,Saves some bytes and ensures that we're actually disabling it
13,C_kwDOAJy2KtoAKDVkZTg3MDM2NDZjZGQzODM4Y2IxNjg2Zjc2MWIxMGMwNjkyNzQzYWE,Sebastian Markbåge,GitHub,"Use the disableLegacyMode where ever we check the ConcurrentMode mode (#28657)

Saves some bytes and ensures that we're actually disabling it.

Turns out this flag wasn't disabling React Native/Fabric, React Noop and
React ART legacy modes so those are updated too.

Should be rebased on #28681.",https://api.github.com/repos/facebook/react/git/commits/5de8703646cdd3838cb1686f761b10c0692743aa,2024-04-03,"
Turns out this flag wasn't disabling React Native/Fabric, React Noop and
React ART legacy modes so those are updated too"
13,C_kwDOAJy2KtoAKDVkZTg3MDM2NDZjZGQzODM4Y2IxNjg2Zjc2MWIxMGMwNjkyNzQzYWE,Sebastian Markbåge,GitHub,"Use the disableLegacyMode where ever we check the ConcurrentMode mode (#28657)

Saves some bytes and ensures that we're actually disabling it.

Turns out this flag wasn't disabling React Native/Fabric, React Noop and
React ART legacy modes so those are updated too.

Should be rebased on #28681.",https://api.github.com/repos/facebook/react/git/commits/5de8703646cdd3838cb1686f761b10c0692743aa,2024-04-03,"
Should be rebased on #28681."
14,C_kwDOAJy2KtoAKDU5OThhNzc1MTk0ZjQ5MWFmYTVkM2JhZGQ5YWZlOWNlYWYxMjg0NWU,Josh Story,GitHub,"Reland #28672: Remove IndeterminateComponent (#28681)

This PR relands #28672 on top of the flag removal and the test
demonstrating a breakage in Suspense for legacy mode.

React has deprecated module pattern Function Components for many years
at this point. Supporting this pattern required React to have a concept
of an indeterminate component so that when a component first renders it
can turn into either a ClassComponent or a FunctionComponent depending
on what it returns. While this feature was deprecated and put behind a
flag it is still in stable. This change remvoes the flag, removes the
warnings, and removes the concept of IndeterminateComponent from the
React codebase.

While removing IndeterminateComponent type Seb and I discovered that we
needed a concept of IncompleteFunctionComponent to support Suspense in
legacy mode. This new work tag is only needed as long as legacy mode is
around and ideally any code that considers this tag will be excludable
from OSS builds once we land extra gates using `disableLegacyMode` flag.",https://api.github.com/repos/facebook/react/git/commits/5998a775194f491afa5d3badd9afe9ceaf12845e,2024-04-03,Reland #28672: Remove IndeterminateComponent (#28681)
14,C_kwDOAJy2KtoAKDU5OThhNzc1MTk0ZjQ5MWFmYTVkM2JhZGQ5YWZlOWNlYWYxMjg0NWU,Josh Story,GitHub,"Reland #28672: Remove IndeterminateComponent (#28681)

This PR relands #28672 on top of the flag removal and the test
demonstrating a breakage in Suspense for legacy mode.

React has deprecated module pattern Function Components for many years
at this point. Supporting this pattern required React to have a concept
of an indeterminate component so that when a component first renders it
can turn into either a ClassComponent or a FunctionComponent depending
on what it returns. While this feature was deprecated and put behind a
flag it is still in stable. This change remvoes the flag, removes the
warnings, and removes the concept of IndeterminateComponent from the
React codebase.

While removing IndeterminateComponent type Seb and I discovered that we
needed a concept of IncompleteFunctionComponent to support Suspense in
legacy mode. This new work tag is only needed as long as legacy mode is
around and ideally any code that considers this tag will be excludable
from OSS builds once we land extra gates using `disableLegacyMode` flag.",https://api.github.com/repos/facebook/react/git/commits/5998a775194f491afa5d3badd9afe9ceaf12845e,2024-04-03,"This PR relands #28672 on top of the flag removal and the test
demonstrating a breakage in Suspense for legacy mode"
14,C_kwDOAJy2KtoAKDU5OThhNzc1MTk0ZjQ5MWFmYTVkM2JhZGQ5YWZlOWNlYWYxMjg0NWU,Josh Story,GitHub,"Reland #28672: Remove IndeterminateComponent (#28681)

This PR relands #28672 on top of the flag removal and the test
demonstrating a breakage in Suspense for legacy mode.

React has deprecated module pattern Function Components for many years
at this point. Supporting this pattern required React to have a concept
of an indeterminate component so that when a component first renders it
can turn into either a ClassComponent or a FunctionComponent depending
on what it returns. While this feature was deprecated and put behind a
flag it is still in stable. This change remvoes the flag, removes the
warnings, and removes the concept of IndeterminateComponent from the
React codebase.

While removing IndeterminateComponent type Seb and I discovered that we
needed a concept of IncompleteFunctionComponent to support Suspense in
legacy mode. This new work tag is only needed as long as legacy mode is
around and ideally any code that considers this tag will be excludable
from OSS builds once we land extra gates using `disableLegacyMode` flag.",https://api.github.com/repos/facebook/react/git/commits/5998a775194f491afa5d3badd9afe9ceaf12845e,2024-04-03,"
React has deprecated module pattern Function Components for many years
at this point"
14,C_kwDOAJy2KtoAKDU5OThhNzc1MTk0ZjQ5MWFmYTVkM2JhZGQ5YWZlOWNlYWYxMjg0NWU,Josh Story,GitHub,"Reland #28672: Remove IndeterminateComponent (#28681)

This PR relands #28672 on top of the flag removal and the test
demonstrating a breakage in Suspense for legacy mode.

React has deprecated module pattern Function Components for many years
at this point. Supporting this pattern required React to have a concept
of an indeterminate component so that when a component first renders it
can turn into either a ClassComponent or a FunctionComponent depending
on what it returns. While this feature was deprecated and put behind a
flag it is still in stable. This change remvoes the flag, removes the
warnings, and removes the concept of IndeterminateComponent from the
React codebase.

While removing IndeterminateComponent type Seb and I discovered that we
needed a concept of IncompleteFunctionComponent to support Suspense in
legacy mode. This new work tag is only needed as long as legacy mode is
around and ideally any code that considers this tag will be excludable
from OSS builds once we land extra gates using `disableLegacyMode` flag.",https://api.github.com/repos/facebook/react/git/commits/5998a775194f491afa5d3badd9afe9ceaf12845e,2024-04-03,"Supporting this pattern required React to have a concept
of an indeterminate component so that when a component first renders it
can turn into either a ClassComponent or a FunctionComponent depending
on what it returns"
14,C_kwDOAJy2KtoAKDU5OThhNzc1MTk0ZjQ5MWFmYTVkM2JhZGQ5YWZlOWNlYWYxMjg0NWU,Josh Story,GitHub,"Reland #28672: Remove IndeterminateComponent (#28681)

This PR relands #28672 on top of the flag removal and the test
demonstrating a breakage in Suspense for legacy mode.

React has deprecated module pattern Function Components for many years
at this point. Supporting this pattern required React to have a concept
of an indeterminate component so that when a component first renders it
can turn into either a ClassComponent or a FunctionComponent depending
on what it returns. While this feature was deprecated and put behind a
flag it is still in stable. This change remvoes the flag, removes the
warnings, and removes the concept of IndeterminateComponent from the
React codebase.

While removing IndeterminateComponent type Seb and I discovered that we
needed a concept of IncompleteFunctionComponent to support Suspense in
legacy mode. This new work tag is only needed as long as legacy mode is
around and ideally any code that considers this tag will be excludable
from OSS builds once we land extra gates using `disableLegacyMode` flag.",https://api.github.com/repos/facebook/react/git/commits/5998a775194f491afa5d3badd9afe9ceaf12845e,2024-04-03,"While this feature was deprecated and put behind a
flag it is still in stable"
14,C_kwDOAJy2KtoAKDU5OThhNzc1MTk0ZjQ5MWFmYTVkM2JhZGQ5YWZlOWNlYWYxMjg0NWU,Josh Story,GitHub,"Reland #28672: Remove IndeterminateComponent (#28681)

This PR relands #28672 on top of the flag removal and the test
demonstrating a breakage in Suspense for legacy mode.

React has deprecated module pattern Function Components for many years
at this point. Supporting this pattern required React to have a concept
of an indeterminate component so that when a component first renders it
can turn into either a ClassComponent or a FunctionComponent depending
on what it returns. While this feature was deprecated and put behind a
flag it is still in stable. This change remvoes the flag, removes the
warnings, and removes the concept of IndeterminateComponent from the
React codebase.

While removing IndeterminateComponent type Seb and I discovered that we
needed a concept of IncompleteFunctionComponent to support Suspense in
legacy mode. This new work tag is only needed as long as legacy mode is
around and ideally any code that considers this tag will be excludable
from OSS builds once we land extra gates using `disableLegacyMode` flag.",https://api.github.com/repos/facebook/react/git/commits/5998a775194f491afa5d3badd9afe9ceaf12845e,2024-04-03,"This change remvoes the flag, removes the
warnings, and removes the concept of IndeterminateComponent from the
React codebase"
14,C_kwDOAJy2KtoAKDU5OThhNzc1MTk0ZjQ5MWFmYTVkM2JhZGQ5YWZlOWNlYWYxMjg0NWU,Josh Story,GitHub,"Reland #28672: Remove IndeterminateComponent (#28681)

This PR relands #28672 on top of the flag removal and the test
demonstrating a breakage in Suspense for legacy mode.

React has deprecated module pattern Function Components for many years
at this point. Supporting this pattern required React to have a concept
of an indeterminate component so that when a component first renders it
can turn into either a ClassComponent or a FunctionComponent depending
on what it returns. While this feature was deprecated and put behind a
flag it is still in stable. This change remvoes the flag, removes the
warnings, and removes the concept of IndeterminateComponent from the
React codebase.

While removing IndeterminateComponent type Seb and I discovered that we
needed a concept of IncompleteFunctionComponent to support Suspense in
legacy mode. This new work tag is only needed as long as legacy mode is
around and ideally any code that considers this tag will be excludable
from OSS builds once we land extra gates using `disableLegacyMode` flag.",https://api.github.com/repos/facebook/react/git/commits/5998a775194f491afa5d3badd9afe9ceaf12845e,2024-04-03,"
While removing IndeterminateComponent type Seb and I discovered that we
needed a concept of IncompleteFunctionComponent to support Suspense in
legacy mode"
14,C_kwDOAJy2KtoAKDU5OThhNzc1MTk0ZjQ5MWFmYTVkM2JhZGQ5YWZlOWNlYWYxMjg0NWU,Josh Story,GitHub,"Reland #28672: Remove IndeterminateComponent (#28681)

This PR relands #28672 on top of the flag removal and the test
demonstrating a breakage in Suspense for legacy mode.

React has deprecated module pattern Function Components for many years
at this point. Supporting this pattern required React to have a concept
of an indeterminate component so that when a component first renders it
can turn into either a ClassComponent or a FunctionComponent depending
on what it returns. While this feature was deprecated and put behind a
flag it is still in stable. This change remvoes the flag, removes the
warnings, and removes the concept of IndeterminateComponent from the
React codebase.

While removing IndeterminateComponent type Seb and I discovered that we
needed a concept of IncompleteFunctionComponent to support Suspense in
legacy mode. This new work tag is only needed as long as legacy mode is
around and ideally any code that considers this tag will be excludable
from OSS builds once we land extra gates using `disableLegacyMode` flag.",https://api.github.com/repos/facebook/react/git/commits/5998a775194f491afa5d3badd9afe9ceaf12845e,2024-04-03,"This new work tag is only needed as long as legacy mode is
around and ideally any code that considers this tag will be excludable
from OSS builds once we land extra gates using `disableLegacyMode` flag."
15,C_kwDOAJy2KtoAKDczMTljNjFiMTgyNzRlZTdlN2MyMGJkMmU1MzNiOTNjOTIyZDhmZTA,Joseph Savona,GitHub,"[be] Remove unshipped experimental <Cache> element type (#28698)

Removes the `<Cache />` element type since we're going with a simpler
caching strategy.",https://api.github.com/repos/facebook/react/git/commits/7319c61b18274ee7e7c20bd2e533b93c922d8fe0,2024-04-02,[be] Remove unshipped experimental <Cache> element type (#28698)
15,C_kwDOAJy2KtoAKDczMTljNjFiMTgyNzRlZTdlN2MyMGJkMmU1MzNiOTNjOTIyZDhmZTA,Joseph Savona,GitHub,"[be] Remove unshipped experimental <Cache> element type (#28698)

Removes the `<Cache />` element type since we're going with a simpler
caching strategy.",https://api.github.com/repos/facebook/react/git/commits/7319c61b18274ee7e7c20bd2e533b93c922d8fe0,2024-04-02,"Removes the `<Cache />` element type since we're going with a simpler
caching strategy."
16,C_kwDOAJy2KtoAKGYyNjkwNzQ3MjM5NTMzZmEyNjY2MTJkMmQ0ZGQ5YWU4OGVhOTJmYmM,Ricky,GitHub,"Revert ""Remove module pattern function component support"" (#28670)

This breaks internal tests, so must be something in the refactor. Since
it's the top commit let's revert and split into two PRs, one that
removes the flag and one that does the refactor, so we can find the bug.",https://api.github.com/repos/facebook/react/git/commits/f2690747239533fa266612d2d4dd9ae88ea92fbc,2024-03-29,"Revert ""Remove module pattern function component support"" (#28670)"
16,C_kwDOAJy2KtoAKGYyNjkwNzQ3MjM5NTMzZmEyNjY2MTJkMmQ0ZGQ5YWU4OGVhOTJmYmM,Ricky,GitHub,"Revert ""Remove module pattern function component support"" (#28670)

This breaks internal tests, so must be something in the refactor. Since
it's the top commit let's revert and split into two PRs, one that
removes the flag and one that does the refactor, so we can find the bug.",https://api.github.com/repos/facebook/react/git/commits/f2690747239533fa266612d2d4dd9ae88ea92fbc,2024-03-29,"This breaks internal tests, so must be something in the refactor"
16,C_kwDOAJy2KtoAKGYyNjkwNzQ3MjM5NTMzZmEyNjY2MTJkMmQ0ZGQ5YWU4OGVhOTJmYmM,Ricky,GitHub,"Revert ""Remove module pattern function component support"" (#28670)

This breaks internal tests, so must be something in the refactor. Since
it's the top commit let's revert and split into two PRs, one that
removes the flag and one that does the refactor, so we can find the bug.",https://api.github.com/repos/facebook/react/git/commits/f2690747239533fa266612d2d4dd9ae88ea92fbc,2024-03-29,"Since
it's the top commit let's revert and split into two PRs, one that
removes the flag and one that does the refactor, so we can find the bug."
17,C_kwDOAJy2KtoAKGNjNTZiZWQzOGNiZTVhNWM3NmRmZGM0ZTljNjQyZmFiNDg4NGEzZmM,Josh Story,GitHub,"Remove module pattern function component support (#27742)

The module pattern

```
function MyComponent() {
  return {
    render() {
      return this.state.foo
    }
  }
}
```

has been deprecated for approximately 5 years now. This PR removes
support for this pattern. It also simplifies a number of code paths in
particular related to the concept of `IndeterminateComponent` types.",https://api.github.com/repos/facebook/react/git/commits/cc56bed38cbe5a5c76dfdc4e9c642fab4884a3fc,2024-03-28,Remove module pattern function component support (#27742)
17,C_kwDOAJy2KtoAKGNjNTZiZWQzOGNiZTVhNWM3NmRmZGM0ZTljNjQyZmFiNDg4NGEzZmM,Josh Story,GitHub,"Remove module pattern function component support (#27742)

The module pattern

```
function MyComponent() {
  return {
    render() {
      return this.state.foo
    }
  }
}
```

has been deprecated for approximately 5 years now. This PR removes
support for this pattern. It also simplifies a number of code paths in
particular related to the concept of `IndeterminateComponent` types.",https://api.github.com/repos/facebook/react/git/commits/cc56bed38cbe5a5c76dfdc4e9c642fab4884a3fc,2024-03-28,"The module pattern
  return {
      return this.state.foo
has been deprecated for approximately 5 years now"
17,C_kwDOAJy2KtoAKGNjNTZiZWQzOGNiZTVhNWM3NmRmZGM0ZTljNjQyZmFiNDg4NGEzZmM,Josh Story,GitHub,"Remove module pattern function component support (#27742)

The module pattern

```
function MyComponent() {
  return {
    render() {
      return this.state.foo
    }
  }
}
```

has been deprecated for approximately 5 years now. This PR removes
support for this pattern. It also simplifies a number of code paths in
particular related to the concept of `IndeterminateComponent` types.",https://api.github.com/repos/facebook/react/git/commits/cc56bed38cbe5a5c76dfdc4e9c642fab4884a3fc,2024-03-28,"This PR removes
support for this pattern"
17,C_kwDOAJy2KtoAKGNjNTZiZWQzOGNiZTVhNWM3NmRmZGM0ZTljNjQyZmFiNDg4NGEzZmM,Josh Story,GitHub,"Remove module pattern function component support (#27742)

The module pattern

```
function MyComponent() {
  return {
    render() {
      return this.state.foo
    }
  }
}
```

has been deprecated for approximately 5 years now. This PR removes
support for this pattern. It also simplifies a number of code paths in
particular related to the concept of `IndeterminateComponent` types.",https://api.github.com/repos/facebook/react/git/commits/cc56bed38cbe5a5c76dfdc4e9c642fab4884a3fc,2024-03-28,"It also simplifies a number of code paths in
particular related to the concept of `IndeterminateComponent` types."
18,C_kwDOAJy2KtoAKDY3MGQ2MWJlYTIzNDcwZTk4MGJhMTNjMWM4NDQxZTM3NTc3OWIwYjg,Sebastian Markbåge,GitHub,"Remove legacy hydration mode (#28440)

While Meta is still using legacy mode and we can't remove completely,
Meta is not using legacy hydration so we should be able to remove that.

This is just the first step. Once removed, we can vastly simplify the
DOMConfig for hydration.

This will have to be rebased when tests are upgraded.",https://api.github.com/repos/facebook/react/git/commits/670d61bea23470e980ba13c1c8441e375779b0b8,2024-03-26,Remove legacy hydration mode (#28440)
18,C_kwDOAJy2KtoAKDY3MGQ2MWJlYTIzNDcwZTk4MGJhMTNjMWM4NDQxZTM3NTc3OWIwYjg,Sebastian Markbåge,GitHub,"Remove legacy hydration mode (#28440)

While Meta is still using legacy mode and we can't remove completely,
Meta is not using legacy hydration so we should be able to remove that.

This is just the first step. Once removed, we can vastly simplify the
DOMConfig for hydration.

This will have to be rebased when tests are upgraded.",https://api.github.com/repos/facebook/react/git/commits/670d61bea23470e980ba13c1c8441e375779b0b8,2024-03-26,"While Meta is still using legacy mode and we can't remove completely,
Meta is not using legacy hydration so we should be able to remove that"
18,C_kwDOAJy2KtoAKDY3MGQ2MWJlYTIzNDcwZTk4MGJhMTNjMWM4NDQxZTM3NTc3OWIwYjg,Sebastian Markbåge,GitHub,"Remove legacy hydration mode (#28440)

While Meta is still using legacy mode and we can't remove completely,
Meta is not using legacy hydration so we should be able to remove that.

This is just the first step. Once removed, we can vastly simplify the
DOMConfig for hydration.

This will have to be rebased when tests are upgraded.",https://api.github.com/repos/facebook/react/git/commits/670d61bea23470e980ba13c1c8441e375779b0b8,2024-03-26,"
This is just the first step"
18,C_kwDOAJy2KtoAKDY3MGQ2MWJlYTIzNDcwZTk4MGJhMTNjMWM4NDQxZTM3NTc3OWIwYjg,Sebastian Markbåge,GitHub,"Remove legacy hydration mode (#28440)

While Meta is still using legacy mode and we can't remove completely,
Meta is not using legacy hydration so we should be able to remove that.

This is just the first step. Once removed, we can vastly simplify the
DOMConfig for hydration.

This will have to be rebased when tests are upgraded.",https://api.github.com/repos/facebook/react/git/commits/670d61bea23470e980ba13c1c8441e375779b0b8,2024-03-26,"Once removed, we can vastly simplify the
DOMConfig for hydration"
18,C_kwDOAJy2KtoAKDY3MGQ2MWJlYTIzNDcwZTk4MGJhMTNjMWM4NDQxZTM3NTc3OWIwYjg,Sebastian Markbåge,GitHub,"Remove legacy hydration mode (#28440)

While Meta is still using legacy mode and we can't remove completely,
Meta is not using legacy hydration so we should be able to remove that.

This is just the first step. Once removed, we can vastly simplify the
DOMConfig for hydration.

This will have to be rebased when tests are upgraded.",https://api.github.com/repos/facebook/react/git/commits/670d61bea23470e980ba13c1c8441e375779b0b8,2024-03-26,"
This will have to be rebased when tests are upgraded."
19,C_kwDOAJy2KtoAKDIwOGNlZWI0NmNhMjgzOGM5YmYyNGNkMzQxNDM1Zjg3YjJkNTA1Njk,Jan Kassens,GitHub,"Cleanup enableFloat flag (#28613)

Cleanup enableFloat flag",https://api.github.com/repos/facebook/react/git/commits/208ceeb46ca2838c9bf24cd341435f87b2d50569,2024-03-22,Cleanup enableFloat flag (#28613)
19,C_kwDOAJy2KtoAKDIwOGNlZWI0NmNhMjgzOGM5YmYyNGNkMzQxNDM1Zjg3YjJkNTA1Njk,Jan Kassens,GitHub,"Cleanup enableFloat flag (#28613)

Cleanup enableFloat flag",https://api.github.com/repos/facebook/react/git/commits/208ceeb46ca2838c9bf24cd341435f87b2d50569,2024-03-22,Cleanup enableFloat flag
20,C_kwDOAJy2KtoAKDg5MDIxZmI0ZWM5YWE4MjE5NGIwNzg4NTY2ZTczNmE0Y2VkZmMwZTQ,Sebastian Markbåge,GitHub,"Remove invokeGuardedCallback and replay trick (#28515)

We broke the ability to ""break on uncaught exceptions"" by adding a
try/catch higher up in the scheduling. We're giving up on fixing that so
we can remove the replay trick inside an event handler.

The issue with that approach is that we end up double logging a lot of
errors in DEV since they get reported to the page.

It's also a lot of complexity around this feature.",https://api.github.com/repos/facebook/react/git/commits/89021fb4ec9aa82194b0788566e736a4cedfc0e4,2024-03-12,Remove invokeGuardedCallback and replay trick (#28515)
20,C_kwDOAJy2KtoAKDg5MDIxZmI0ZWM5YWE4MjE5NGIwNzg4NTY2ZTczNmE0Y2VkZmMwZTQ,Sebastian Markbåge,GitHub,"Remove invokeGuardedCallback and replay trick (#28515)

We broke the ability to ""break on uncaught exceptions"" by adding a
try/catch higher up in the scheduling. We're giving up on fixing that so
we can remove the replay trick inside an event handler.

The issue with that approach is that we end up double logging a lot of
errors in DEV since they get reported to the page.

It's also a lot of complexity around this feature.",https://api.github.com/repos/facebook/react/git/commits/89021fb4ec9aa82194b0788566e736a4cedfc0e4,2024-03-12,"We broke the ability to ""break on uncaught exceptions"" by adding a
try/catch higher up in the scheduling"
20,C_kwDOAJy2KtoAKDg5MDIxZmI0ZWM5YWE4MjE5NGIwNzg4NTY2ZTczNmE0Y2VkZmMwZTQ,Sebastian Markbåge,GitHub,"Remove invokeGuardedCallback and replay trick (#28515)

We broke the ability to ""break on uncaught exceptions"" by adding a
try/catch higher up in the scheduling. We're giving up on fixing that so
we can remove the replay trick inside an event handler.

The issue with that approach is that we end up double logging a lot of
errors in DEV since they get reported to the page.

It's also a lot of complexity around this feature.",https://api.github.com/repos/facebook/react/git/commits/89021fb4ec9aa82194b0788566e736a4cedfc0e4,2024-03-12,"We're giving up on fixing that so
we can remove the replay trick inside an event handler"
20,C_kwDOAJy2KtoAKDg5MDIxZmI0ZWM5YWE4MjE5NGIwNzg4NTY2ZTczNmE0Y2VkZmMwZTQ,Sebastian Markbåge,GitHub,"Remove invokeGuardedCallback and replay trick (#28515)

We broke the ability to ""break on uncaught exceptions"" by adding a
try/catch higher up in the scheduling. We're giving up on fixing that so
we can remove the replay trick inside an event handler.

The issue with that approach is that we end up double logging a lot of
errors in DEV since they get reported to the page.

It's also a lot of complexity around this feature.",https://api.github.com/repos/facebook/react/git/commits/89021fb4ec9aa82194b0788566e736a4cedfc0e4,2024-03-12,"
The issue with that approach is that we end up double logging a lot of
errors in DEV since they get reported to the page"
20,C_kwDOAJy2KtoAKDg5MDIxZmI0ZWM5YWE4MjE5NGIwNzg4NTY2ZTczNmE0Y2VkZmMwZTQ,Sebastian Markbåge,GitHub,"Remove invokeGuardedCallback and replay trick (#28515)

We broke the ability to ""break on uncaught exceptions"" by adding a
try/catch higher up in the scheduling. We're giving up on fixing that so
we can remove the replay trick inside an event handler.

The issue with that approach is that we end up double logging a lot of
errors in DEV since they get reported to the page.

It's also a lot of complexity around this feature.",https://api.github.com/repos/facebook/react/git/commits/89021fb4ec9aa82194b0788566e736a4cedfc0e4,2024-03-12,"
It's also a lot of complexity around this feature."
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,Switch <Context> to mean <Context.Provider> (#28226)
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,"Previously, `<Context>` was equivalent to `<Context.Consumer>`"
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,"However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used"
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,"The goal here is to make the common case cleaner:
```js
const ThemeContext = createContext('light')
  return (
    <ThemeContext value=""dark"">
    </ThemeContext>
  const theme = use(ThemeContext)
This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior"
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,"[Proof that
it warns today (check
console).](
switches `createContext` implementation so that `Context.Provider ===
Context`"
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,"
The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object)"
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,"Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object)"
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,"
My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages"
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,"
This might break tooling that depends on inspecting React's internal
fields"
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,I've added DevTools support in the second commit
21,C_kwDOAJy2KtoAKDE0ZmQ5NjMwZWUwNDM4N2Y0MzYxZGEyODkzOTMyMzRlMmI3ZDkzYjY,dan,GitHub,"Switch <Context> to mean <Context.Provider> (#28226)

Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
since the introduction of Hooks, the `<Context.Consumer>` API is rarely
used. The goal here is to make the common case cleaner:

```js
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext value=""dark"">
      ...
    </ThemeContext>
  )
}

function Button() {
  const theme = use(ThemeContext)
  // ...
}
```

This is technically a breaking change, but we've been warning about
rendering `<Context>` directly for several years by now, so it's
unlikely much code in the wild depends on the old behavior. [Proof that
it warns today (check
console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)

---

**The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
switches `createContext` implementation so that `Context.Provider ===
Context`.

The main assumption that changed is that a Provider's fiber type is now
the context itself (rather than an intermediate object). Whereas a
Consumer's fiber type is now always an intermediate object (rather than
it being sometimes the context itself and sometimes an intermediate
object).

My methodology was to start with the relevant symbols, work tags, and
types, and work my way backwards to all usages.

This might break tooling that depends on inspecting React's internal
fields. I've added DevTools support in the second commit. This didn't
need explicit versioning—the structure tells us enough.",https://api.github.com/repos/facebook/react/git/commits/14fd9630ee04387f4361da289393234e2b7d93b6,2024-02-13,"This didn't
need explicit versioning—the structure tells us enough."
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"That way we can use it for debug information like component stacks and
DevTools"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"
It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"
This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"I started outline the types for this for some things I was
planning to add but it's not final"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"
I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"However, I realized that there's no Hook instance
for those to stash it on"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render"
22,C_kwDOAJy2KtoAKDNmOTNjYTFjOGRlYzFmZDg1ZGY0ZGJiNzQ4YTJkZjk0MzhmYzY5OWY,Sebastian Markbåge,GitHub,"[Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)

That way we can use it for debug information like component stacks and
DevTools. I used an extra stack argument in Child Fiber to track this as
it's flowing down since it's not just elements where we have this info
readily available but parent arrays and lazy can merge this into the
Fiber too. It's not great that this is a dev-only argument and I could
track it globally but seems more likely to make mistakes.

It is possible for the same debug info to appear for multiple child
fibers like when it's attached to a fragment or a lazy that resolves to
a fragment at the root. The object identity could be used in these
scenarios to infer if that's really one server component that's a parent
of all children or if each child has a server component with the same
name.

This is effectively a public API because you can use it to stash
information on Promises from a third-party service - not just Server
Components. I started outline the types for this for some things I was
planning to add but it's not final.

I was also planning on storing it from `use(thenable)` for when you
suspend on a Promise. However, I realized that there's no Hook instance
for those to stash it on. So it might need a separate data structure to
stash the previous pass over of `use()` that resets each render.

No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks.",https://api.github.com/repos/facebook/react/git/commits/3f93ca1c8dec1fd85df4dbb748a2df9438fc699f,2024-02-12,"
No tests yet since I didn't want to test internals but it'll be covered
once we have debugging features like component stacks."
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,Remove __self and __source location from elements (#28265)
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,Along with all the places using it like the `_debugSource` on Fiber
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
We used to have a DEV mode that compiles the source location of JSX into
the compiled output"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component)"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"It had a
bunch of issues though:
- It only works with JSX"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
- The way this source location is compiled is different in all the
pipelines along the way"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"Ideally it should just use the mechanism other source
maps use"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
- It only captures the callsite of the JSX and not the stack between the
component and that callsite"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"In the happy case it's in the component but
not always"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"This ensures that component
stacks are the same in DEV and PROD"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"At the cost of worse line number
information"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
We might explore that in the future"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
This removes source location info from React DevTools and React Native
Inspector"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"That
way it can be made to work in prod too"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"The filtering based on file path
is a bit trickier"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
When redesigned this UI should ideally also account for more than one
stack frame"
23,C_kwDOAJy2KtoAKDM3ZDkwMWUyYjgxZTEyZDQwZGY3MDEyYzZmODY4MWI4MjcyZDI1NTU,Sebastian Markbåge,GitHub,"Remove __self and __source location from elements (#28265)

Along with all the places using it like the `_debugSource` on Fiber.
This still lets them be passed into `createElement` (and JSX dev
runtime) since those can still be used in existing already compiled code
and we don't want that to start spreading to DOM attributes.

We used to have a DEV mode that compiles the source location of JSX into
the compiled output. This was nice because we could get the actual call
site of the JSX (instead of just somewhere in the component). It had a
bunch of issues though:

- It only works with JSX.
- The way this source location is compiled is different in all the
pipelines along the way. It relies on this transform being first and the
source location we want to extract but it doesn't get preserved along
source maps and don't have a way to be connected to the source hosted by
the source maps. Ideally it should just use the mechanism other source
maps use.
- Since it's expensive it only works in DEV so if it's used for
component stacks it would vary between dev and prod.
- It only captures the callsite of the JSX and not the stack between the
component and that callsite. In the happy case it's in the component but
not always.

Instead, we have another zero-cost trick to extract the call site of
each component lazily only if it's needed. This ensures that component
stacks are the same in DEV and PROD. At the cost of worse line number
information.

The better way to get the JSX call site would be to get it from `new
Error()` or `console.createTask()` inside the JSX runtime which can
capture the whole stack in a consistent way with other source mappings.
We might explore that in the future.

This removes source location info from React DevTools and React Native
Inspector. The ""jump to source code"" feature or inspection can be made
lazy instead by invoking the lazy component stack frame generation. That
way it can be made to work in prod too. The filtering based on file path
is a bit trickier.

When redesigned this UI should ideally also account for more than one
stack frame.

With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything.",https://api.github.com/repos/facebook/react/git/commits/37d901e2b81e12d40df7012c6f8681b8272d2555,2024-02-07,"
With this change the DEV only Babel transforms are effectively
deprecated since they're not necessary for anything."
24,C_kwDOAJy2KtoAKDNkMWRhMWY5YWI3ZDU0OTg0YzA5NmU2YTA0Yzg3MjlmM2E1MGZkOGE,Ricky,GitHub,"Remove createRootStrictEffectsByDefault flag (#28102)

There's no need to separate strict mode from strict effects mode any
more.

I didn't clean up the `StrictEffectMode` fiber flag, because it's used
to prevent strict effects in legacy mode. I could replace those checks
with `LegacyMode` checks, but when we remove legacy mode, we can remove
that flag and condense them into one StrictMode flag away.",https://api.github.com/repos/facebook/react/git/commits/3d1da1f9ab7d54984c096e6a04c8729f3a50fd8a,2024-02-01,Remove createRootStrictEffectsByDefault flag (#28102)
24,C_kwDOAJy2KtoAKDNkMWRhMWY5YWI3ZDU0OTg0YzA5NmU2YTA0Yzg3MjlmM2E1MGZkOGE,Ricky,GitHub,"Remove createRootStrictEffectsByDefault flag (#28102)

There's no need to separate strict mode from strict effects mode any
more.

I didn't clean up the `StrictEffectMode` fiber flag, because it's used
to prevent strict effects in legacy mode. I could replace those checks
with `LegacyMode` checks, but when we remove legacy mode, we can remove
that flag and condense them into one StrictMode flag away.",https://api.github.com/repos/facebook/react/git/commits/3d1da1f9ab7d54984c096e6a04c8729f3a50fd8a,2024-02-01,"There's no need to separate strict mode from strict effects mode any
more"
24,C_kwDOAJy2KtoAKDNkMWRhMWY5YWI3ZDU0OTg0YzA5NmU2YTA0Yzg3MjlmM2E1MGZkOGE,Ricky,GitHub,"Remove createRootStrictEffectsByDefault flag (#28102)

There's no need to separate strict mode from strict effects mode any
more.

I didn't clean up the `StrictEffectMode` fiber flag, because it's used
to prevent strict effects in legacy mode. I could replace those checks
with `LegacyMode` checks, but when we remove legacy mode, we can remove
that flag and condense them into one StrictMode flag away.",https://api.github.com/repos/facebook/react/git/commits/3d1da1f9ab7d54984c096e6a04c8729f3a50fd8a,2024-02-01,"
I didn't clean up the `StrictEffectMode` fiber flag, because it's used
to prevent strict effects in legacy mode"
24,C_kwDOAJy2KtoAKDNkMWRhMWY5YWI3ZDU0OTg0YzA5NmU2YTA0Yzg3MjlmM2E1MGZkOGE,Ricky,GitHub,"Remove createRootStrictEffectsByDefault flag (#28102)

There's no need to separate strict mode from strict effects mode any
more.

I didn't clean up the `StrictEffectMode` fiber flag, because it's used
to prevent strict effects in legacy mode. I could replace those checks
with `LegacyMode` checks, but when we remove legacy mode, we can remove
that flag and condense them into one StrictMode flag away.",https://api.github.com/repos/facebook/react/git/commits/3d1da1f9ab7d54984c096e6a04c8729f3a50fd8a,2024-02-01,"I could replace those checks
with `LegacyMode` checks, but when we remove legacy mode, we can remove
that flag and condense them into one StrictMode flag away."
25,C_kwDOAJy2KtoAKDFhNjVkMDM2ZWYwNTdiMDdhNmIxNWY1NjA0ZTM5OWY5MWJjNWVkNzM,Jan Kassens,GitHub,"[cleanup] remove enableHostSingletons feature flag (#27583)

The flag is enabled everywhere, I think we can remove it now.",https://api.github.com/repos/facebook/react/git/commits/1a65d036ef057b07a6b15f5604e399f91bc5ed73,2023-11-16,[cleanup] remove enableHostSingletons feature flag (#27583)
25,C_kwDOAJy2KtoAKDFhNjVkMDM2ZWYwNTdiMDdhNmIxNWY1NjA0ZTM5OWY5MWJjNWVkNzM,Jan Kassens,GitHub,"[cleanup] remove enableHostSingletons feature flag (#27583)

The flag is enabled everywhere, I think we can remove it now.",https://api.github.com/repos/facebook/react/git/commits/1a65d036ef057b07a6b15f5604e399f91bc5ed73,2023-11-16,"The flag is enabled everywhere, I think we can remove it now."
26,C_kwDOAJy2KtoAKGNlMmJjNThhOWY2ZjNiMGJmYzhjNzM4YTBkOGUyYTVmM2EzMzJmZjU,Jan Kassens,GitHub,"[activity] rename unstable_Offscreen to unstable_Activity (#27640)

`Activity` is the current candidate name. This PR starts the rename work
by renaming the exported unstable component name.

NOTE: downstream consumers need to rename the import when updating to
this commit.",https://api.github.com/repos/facebook/react/git/commits/ce2bc58a9f6f3b0bfc8c738a0d8e2a5f3a332ff5,2023-11-02,[activity] rename unstable_Offscreen to unstable_Activity (#27640)
26,C_kwDOAJy2KtoAKGNlMmJjNThhOWY2ZjNiMGJmYzhjNzM4YTBkOGUyYTVmM2EzMzJmZjU,Jan Kassens,GitHub,"[activity] rename unstable_Offscreen to unstable_Activity (#27640)

`Activity` is the current candidate name. This PR starts the rename work
by renaming the exported unstable component name.

NOTE: downstream consumers need to rename the import when updating to
this commit.",https://api.github.com/repos/facebook/react/git/commits/ce2bc58a9f6f3b0bfc8c738a0d8e2a5f3a332ff5,2023-11-02,`Activity` is the current candidate name
26,C_kwDOAJy2KtoAKGNlMmJjNThhOWY2ZjNiMGJmYzhjNzM4YTBkOGUyYTVmM2EzMzJmZjU,Jan Kassens,GitHub,"[activity] rename unstable_Offscreen to unstable_Activity (#27640)

`Activity` is the current candidate name. This PR starts the rename work
by renaming the exported unstable component name.

NOTE: downstream consumers need to rename the import when updating to
this commit.",https://api.github.com/repos/facebook/react/git/commits/ce2bc58a9f6f3b0bfc8c738a0d8e2a5f3a332ff5,2023-11-02,"This PR starts the rename work
by renaming the exported unstable component name"
26,C_kwDOAJy2KtoAKGNlMmJjNThhOWY2ZjNiMGJmYzhjNzM4YTBkOGUyYTVmM2EzMzJmZjU,Jan Kassens,GitHub,"[activity] rename unstable_Offscreen to unstable_Activity (#27640)

`Activity` is the current candidate name. This PR starts the rename work
by renaming the exported unstable component name.

NOTE: downstream consumers need to rename the import when updating to
this commit.",https://api.github.com/repos/facebook/react/git/commits/ce2bc58a9f6f3b0bfc8c738a0d8e2a5f3a332ff5,2023-11-02,"
NOTE: downstream consumers need to rename the import when updating to
this commit."
27,C_kwDOAJy2KtoAKGVhYTY5Njg3NmVlNDBiYjA0ODcyN2FlZmU5OTViZTFiYmI3Mzg0YTg,idango10,GitHub,"fix: devtools source field disappears after component remount (#27297)

## Summary

Fixes: https://github.com/facebook/react/issues/27296

On actions that cause a component to change its signature, and therefore
to remount, the `_debugSource` property of the fiber updates in delay
and causes the `devtools` source field to vanish.

This issue happens in
https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberBeginWork.js

```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  if (__DEV__) {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // This will restart the begin phase with a new fiber.
      return remountFiber(
        current,
        workInProgress,
        createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes,
        ),
      );
    }
  }

  // ...
```

`remountFiber` uses the 3rd parameter as the new fiber
(`createFiberFromTypeAndProps(...)`), but this parameter doesn’t contain
a `_debugSource`.

## How did you test this change?

Tested by monkey patching
`./node_modules/react-dom/cjs/react-dom.development.js`:
<img width=""1749"" alt=""image""
src=""https://github.com/facebook/react/assets/75563024/ccaf7fab-4cc9-4c05-a48b-64db6f55dc23"">


https://github.com/facebook/react/assets/75563024/0650ae5c-b277-44d1-acbb-a08d98bd38e0",https://api.github.com/repos/facebook/react/git/commits/eaa696876ee40bb048727aefe995be1bbb7384a8,2023-08-29,fix: devtools source field disappears after component remount (#27297)
27,C_kwDOAJy2KtoAKGVhYTY5Njg3NmVlNDBiYjA0ODcyN2FlZmU5OTViZTFiYmI3Mzg0YTg,idango10,GitHub,"fix: devtools source field disappears after component remount (#27297)

## Summary

Fixes: https://github.com/facebook/react/issues/27296

On actions that cause a component to change its signature, and therefore
to remount, the `_debugSource` property of the fiber updates in delay
and causes the `devtools` source field to vanish.

This issue happens in
https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberBeginWork.js

```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  if (__DEV__) {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // This will restart the begin phase with a new fiber.
      return remountFiber(
        current,
        workInProgress,
        createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes,
        ),
      );
    }
  }

  // ...
```

`remountFiber` uses the 3rd parameter as the new fiber
(`createFiberFromTypeAndProps(...)`), but this parameter doesn’t contain
a `_debugSource`.

## How did you test this change?

Tested by monkey patching
`./node_modules/react-dom/cjs/react-dom.development.js`:
<img width=""1749"" alt=""image""
src=""https://github.com/facebook/react/assets/75563024/ccaf7fab-4cc9-4c05-a48b-64db6f55dc23"">


https://github.com/facebook/react/assets/75563024/0650ae5c-b277-44d1-acbb-a08d98bd38e0",https://api.github.com/repos/facebook/react/git/commits/eaa696876ee40bb048727aefe995be1bbb7384a8,2023-08-29,"## Summary
Fixes: 
On actions that cause a component to change its signature, and therefore
to remount, the `_debugSource` property of the fiber updates in delay
and causes the `devtools` source field to vanish"
27,C_kwDOAJy2KtoAKGVhYTY5Njg3NmVlNDBiYjA0ODcyN2FlZmU5OTViZTFiYmI3Mzg0YTg,idango10,GitHub,"fix: devtools source field disappears after component remount (#27297)

## Summary

Fixes: https://github.com/facebook/react/issues/27296

On actions that cause a component to change its signature, and therefore
to remount, the `_debugSource` property of the fiber updates in delay
and causes the `devtools` source field to vanish.

This issue happens in
https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberBeginWork.js

```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  if (__DEV__) {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // This will restart the begin phase with a new fiber.
      return remountFiber(
        current,
        workInProgress,
        createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes,
        ),
      );
    }
  }

  // ...
```

`remountFiber` uses the 3rd parameter as the new fiber
(`createFiberFromTypeAndProps(...)`), but this parameter doesn’t contain
a `_debugSource`.

## How did you test this change?

Tested by monkey patching
`./node_modules/react-dom/cjs/react-dom.development.js`:
<img width=""1749"" alt=""image""
src=""https://github.com/facebook/react/assets/75563024/ccaf7fab-4cc9-4c05-a48b-64db6f55dc23"">


https://github.com/facebook/react/assets/75563024/0650ae5c-b277-44d1-acbb-a08d98bd38e0",https://api.github.com/repos/facebook/react/git/commits/eaa696876ee40bb048727aefe995be1bbb7384a8,2023-08-29,"
This issue happens in
```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
      // This will restart the begin phase with a new fiber"
27,C_kwDOAJy2KtoAKGVhYTY5Njg3NmVlNDBiYjA0ODcyN2FlZmU5OTViZTFiYmI3Mzg0YTg,idango10,GitHub,"fix: devtools source field disappears after component remount (#27297)

## Summary

Fixes: https://github.com/facebook/react/issues/27296

On actions that cause a component to change its signature, and therefore
to remount, the `_debugSource` property of the fiber updates in delay
and causes the `devtools` source field to vanish.

This issue happens in
https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberBeginWork.js

```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  if (__DEV__) {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // This will restart the begin phase with a new fiber.
      return remountFiber(
        current,
        workInProgress,
        createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes,
        ),
      );
    }
  }

  // ...
```

`remountFiber` uses the 3rd parameter as the new fiber
(`createFiberFromTypeAndProps(...)`), but this parameter doesn’t contain
a `_debugSource`.

## How did you test this change?

Tested by monkey patching
`./node_modules/react-dom/cjs/react-dom.development.js`:
<img width=""1749"" alt=""image""
src=""https://github.com/facebook/react/assets/75563024/ccaf7fab-4cc9-4c05-a48b-64db6f55dc23"">


https://github.com/facebook/react/assets/75563024/0650ae5c-b277-44d1-acbb-a08d98bd38e0",https://api.github.com/repos/facebook/react/git/commits/eaa696876ee40bb048727aefe995be1bbb7384a8,2023-08-29,"
      return remountFiber(
        current,
        workInProgress,
        createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes,
`remountFiber` uses the 3rd parameter as the new fiber
(`createFiberFromTypeAndProps(...)`), but this parameter doesn’t contain
a `_debugSource`"
27,C_kwDOAJy2KtoAKGVhYTY5Njg3NmVlNDBiYjA0ODcyN2FlZmU5OTViZTFiYmI3Mzg0YTg,idango10,GitHub,"fix: devtools source field disappears after component remount (#27297)

## Summary

Fixes: https://github.com/facebook/react/issues/27296

On actions that cause a component to change its signature, and therefore
to remount, the `_debugSource` property of the fiber updates in delay
and causes the `devtools` source field to vanish.

This issue happens in
https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberBeginWork.js

```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  if (__DEV__) {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // This will restart the begin phase with a new fiber.
      return remountFiber(
        current,
        workInProgress,
        createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes,
        ),
      );
    }
  }

  // ...
```

`remountFiber` uses the 3rd parameter as the new fiber
(`createFiberFromTypeAndProps(...)`), but this parameter doesn’t contain
a `_debugSource`.

## How did you test this change?

Tested by monkey patching
`./node_modules/react-dom/cjs/react-dom.development.js`:
<img width=""1749"" alt=""image""
src=""https://github.com/facebook/react/assets/75563024/ccaf7fab-4cc9-4c05-a48b-64db6f55dc23"">


https://github.com/facebook/react/assets/75563024/0650ae5c-b277-44d1-acbb-a08d98bd38e0",https://api.github.com/repos/facebook/react/git/commits/eaa696876ee40bb048727aefe995be1bbb7384a8,2023-08-29,"
## How did you test this change?
Tested by monkey patching
`./node_modules/react-dom/cjs/react-dom.development.js`:
<img width=""1749"" alt=""image""
src=""
https://github.com/facebook/react/assets/75563024/0650ae5c-b277-44d1-acbb-a08d98bd38e0"
28,C_kwDOAJy2KtoAKDcwZTk5OGExMDY0Y2MxZThlOGY5MTAzZTBjMDBkMzdmYmJjZjcxYzE,Tianyu Yao,GitHub,"Fix disableStrictPassiveEffect not working under Suspense (#26989)

In https://github.com/facebook/react/pull/26914 I added an extra logic
to turn off double useEffect if there is an `Offscreen`
tag. But `Suspense` uses `Offscreen` tag internally and that turns off
`disableStrictPassiveEffect` for everything.",https://api.github.com/repos/facebook/react/git/commits/70e998a1064cc1e8e8f9103e0c00d37fbbcf71c1,2023-06-22,Fix disableStrictPassiveEffect not working under Suspense (#26989)
28,C_kwDOAJy2KtoAKDcwZTk5OGExMDY0Y2MxZThlOGY5MTAzZTBjMDBkMzdmYmJjZjcxYzE,Tianyu Yao,GitHub,"Fix disableStrictPassiveEffect not working under Suspense (#26989)

In https://github.com/facebook/react/pull/26914 I added an extra logic
to turn off double useEffect if there is an `Offscreen`
tag. But `Suspense` uses `Offscreen` tag internally and that turns off
`disableStrictPassiveEffect` for everything.",https://api.github.com/repos/facebook/react/git/commits/70e998a1064cc1e8e8f9103e0c00d37fbbcf71c1,2023-06-22,"In I added an extra logic
to turn off double useEffect if there is an `Offscreen`
tag"
28,C_kwDOAJy2KtoAKDcwZTk5OGExMDY0Y2MxZThlOGY5MTAzZTBjMDBkMzdmYmJjZjcxYzE,Tianyu Yao,GitHub,"Fix disableStrictPassiveEffect not working under Suspense (#26989)

In https://github.com/facebook/react/pull/26914 I added an extra logic
to turn off double useEffect if there is an `Offscreen`
tag. But `Suspense` uses `Offscreen` tag internally and that turns off
`disableStrictPassiveEffect` for everything.",https://api.github.com/repos/facebook/react/git/commits/70e998a1064cc1e8e8f9103e0c00d37fbbcf71c1,2023-06-22,"But `Suspense` uses `Offscreen` tag internally and that turns off
`disableStrictPassiveEffect` for everything."
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"Please
provide enough information so that others can review your pull request"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
The three fields below are mandatory"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
Before submitting a pull request, please make sure the following is
done:
1"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"Fork [the repository](and create
your branch from `main`"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
  2"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,Run `yarn` in the repository root
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
3"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"If you've fixed a bug or added code that should be tested, add tests!
4"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,Ensure the test suite passes (`yarn test`)
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"Tip: `yarn test --watch
TestName` is helpful in development"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
5"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,Run `yarn test --prod` to test in the production environment
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"It
supports the same options as `yarn test`"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
6"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"""
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
7"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"Format your code with
[prettier]((`yarn prettier`)"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
8"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,Make sure your code lints (`yarn lint`)
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"Tip: `yarn linc` to only
check changed files"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
  9"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,Run the [Flow](type checks (`yarn flow`)
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
  10"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"If you haven't already, complete the CLA"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
Learn more about contributing:
## Summary
Explain the **motivation** for making this change"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"What existing problem
does the pull request solve?
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"There are non-trivial number of test failures caused by
double `useEffect` in StrictMode"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
## How did you test this change?
Demonstrate the code is solid"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed"
29,C_kwDOAJy2KtoAKDI1NGNiZGJkNmQ4NTFhMzBiZjNiNjQ5YTZjYjdjNTI3ODY3NjZmYTQ,Tianyu Yao,GitHub,"Add a temporary internal option to disable double useEffect in legacy strict mode (#26914)

<!--
  Thanks for submitting a pull request!
We appreciate you spending the time to work on these changes. Please
provide enough information so that others can review your pull request.
The three fields below are mandatory.

Before submitting a pull request, please make sure the following is
done:

1. Fork [the repository](https://github.com/facebook/react) and create
your branch from `main`.
  2. Run `yarn` in the repository root.
3. If you've fixed a bug or added code that should be tested, add tests!
4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
TestName` is helpful in development.
5. Run `yarn test --prod` to test in the production environment. It
supports the same options as `yarn test`.
6. If you need a debugger, run `yarn test --debug --watch TestName`,
open `chrome://inspect`, and press ""Inspect"".
7. Format your code with
[prettier](https://github.com/prettier/prettier) (`yarn prettier`).
8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
check changed files.
  9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
  10. If you haven't already, complete the CLA.

Learn more about contributing:
https://reactjs.org/docs/how-to-contribute.html
-->

## Summary

<!--
Explain the **motivation** for making this change. What existing problem
does the pull request solve?
-->
We are upgrading React 17 codebase to React18, and `StrictMode` has been
great for surfacing potential production bugs on React18 for class
components. There are non-trivial number of test failures caused by
double `useEffect` in StrictMode. To prioritize surfacing and fixing
issues that will break in production now, we need a flag to turn off
double `useEffect` for now in StrictMode temporarily. This is a
Meta-only hack for rolling out `createRoot` and we will fast follow to
remove it and use full strict mode.

## How did you test this change?

<!--
Demonstrate the code is solid. Example: The exact commands you ran and
their output, screenshots / videos if the pull request changes the user
interface.
How exactly did you verify that your PR solves the issue you wanted to
solve?
  If you leave this empty, your PR will very likely be closed.
-->
jest",https://api.github.com/repos/facebook/react/git/commits/254cbdbd6d851a30bf3b649a6cb7c52786766fa4,2023-06-21,"
jest"
30,C_kwDOAJy2KtoAKDAxOGM1OGM5YzY1NDUyY2ZmMjVhYWYxZjM4Zjc4YTliOTBkOGU1YzE,Ricky,GitHub,"Clean up enableSyncDefaultUpdates flag a bit (#26858)

## Overview

Does a few things:
- Renames `enableSyncDefaultUpdates` to
`forceConcurrentByDefaultForTesting`
- Changes the way it's used so it's dead-code eliminated separate from
`allowConcurrentByDefault`
- Deletes a bunch of the gated code

The gates that are deleted are unnecessary now. We were keeping them
when we originally thought we would come back to being concurrent by
default. But we've shifted and now sync-by default is the desired
behavior long term, so there's no need to keep all these forked tests
around.

I'll follow up to delete more of the forked behavior if possible.
Ideally we wouldn't need this flag even if we're still using
`allowConcurrentByDefault`.",https://api.github.com/repos/facebook/react/git/commits/018c58c9c65452cff25aaf1f38f78a9b90d8e5c1,2023-06-01,Clean up enableSyncDefaultUpdates flag a bit (#26858)
30,C_kwDOAJy2KtoAKDAxOGM1OGM5YzY1NDUyY2ZmMjVhYWYxZjM4Zjc4YTliOTBkOGU1YzE,Ricky,GitHub,"Clean up enableSyncDefaultUpdates flag a bit (#26858)

## Overview

Does a few things:
- Renames `enableSyncDefaultUpdates` to
`forceConcurrentByDefaultForTesting`
- Changes the way it's used so it's dead-code eliminated separate from
`allowConcurrentByDefault`
- Deletes a bunch of the gated code

The gates that are deleted are unnecessary now. We were keeping them
when we originally thought we would come back to being concurrent by
default. But we've shifted and now sync-by default is the desired
behavior long term, so there's no need to keep all these forked tests
around.

I'll follow up to delete more of the forked behavior if possible.
Ideally we wouldn't need this flag even if we're still using
`allowConcurrentByDefault`.",https://api.github.com/repos/facebook/react/git/commits/018c58c9c65452cff25aaf1f38f78a9b90d8e5c1,2023-06-01,"## Overview
Does a few things:
- Renames `enableSyncDefaultUpdates` to
`forceConcurrentByDefaultForTesting`
- Changes the way it's used so it's dead-code eliminated separate from
`allowConcurrentByDefault`
- Deletes a bunch of the gated code
The gates that are deleted are unnecessary now"
30,C_kwDOAJy2KtoAKDAxOGM1OGM5YzY1NDUyY2ZmMjVhYWYxZjM4Zjc4YTliOTBkOGU1YzE,Ricky,GitHub,"Clean up enableSyncDefaultUpdates flag a bit (#26858)

## Overview

Does a few things:
- Renames `enableSyncDefaultUpdates` to
`forceConcurrentByDefaultForTesting`
- Changes the way it's used so it's dead-code eliminated separate from
`allowConcurrentByDefault`
- Deletes a bunch of the gated code

The gates that are deleted are unnecessary now. We were keeping them
when we originally thought we would come back to being concurrent by
default. But we've shifted and now sync-by default is the desired
behavior long term, so there's no need to keep all these forked tests
around.

I'll follow up to delete more of the forked behavior if possible.
Ideally we wouldn't need this flag even if we're still using
`allowConcurrentByDefault`.",https://api.github.com/repos/facebook/react/git/commits/018c58c9c65452cff25aaf1f38f78a9b90d8e5c1,2023-06-01,"We were keeping them
when we originally thought we would come back to being concurrent by
default"
30,C_kwDOAJy2KtoAKDAxOGM1OGM5YzY1NDUyY2ZmMjVhYWYxZjM4Zjc4YTliOTBkOGU1YzE,Ricky,GitHub,"Clean up enableSyncDefaultUpdates flag a bit (#26858)

## Overview

Does a few things:
- Renames `enableSyncDefaultUpdates` to
`forceConcurrentByDefaultForTesting`
- Changes the way it's used so it's dead-code eliminated separate from
`allowConcurrentByDefault`
- Deletes a bunch of the gated code

The gates that are deleted are unnecessary now. We were keeping them
when we originally thought we would come back to being concurrent by
default. But we've shifted and now sync-by default is the desired
behavior long term, so there's no need to keep all these forked tests
around.

I'll follow up to delete more of the forked behavior if possible.
Ideally we wouldn't need this flag even if we're still using
`allowConcurrentByDefault`.",https://api.github.com/repos/facebook/react/git/commits/018c58c9c65452cff25aaf1f38f78a9b90d8e5c1,2023-06-01,"But we've shifted and now sync-by default is the desired
behavior long term, so there's no need to keep all these forked tests
around"
30,C_kwDOAJy2KtoAKDAxOGM1OGM5YzY1NDUyY2ZmMjVhYWYxZjM4Zjc4YTliOTBkOGU1YzE,Ricky,GitHub,"Clean up enableSyncDefaultUpdates flag a bit (#26858)

## Overview

Does a few things:
- Renames `enableSyncDefaultUpdates` to
`forceConcurrentByDefaultForTesting`
- Changes the way it's used so it's dead-code eliminated separate from
`allowConcurrentByDefault`
- Deletes a bunch of the gated code

The gates that are deleted are unnecessary now. We were keeping them
when we originally thought we would come back to being concurrent by
default. But we've shifted and now sync-by default is the desired
behavior long term, so there's no need to keep all these forked tests
around.

I'll follow up to delete more of the forked behavior if possible.
Ideally we wouldn't need this flag even if we're still using
`allowConcurrentByDefault`.",https://api.github.com/repos/facebook/react/git/commits/018c58c9c65452cff25aaf1f38f78a9b90d8e5c1,2023-06-01,"
I'll follow up to delete more of the forked behavior if possible"
30,C_kwDOAJy2KtoAKDAxOGM1OGM5YzY1NDUyY2ZmMjVhYWYxZjM4Zjc4YTliOTBkOGU1YzE,Ricky,GitHub,"Clean up enableSyncDefaultUpdates flag a bit (#26858)

## Overview

Does a few things:
- Renames `enableSyncDefaultUpdates` to
`forceConcurrentByDefaultForTesting`
- Changes the way it's used so it's dead-code eliminated separate from
`allowConcurrentByDefault`
- Deletes a bunch of the gated code

The gates that are deleted are unnecessary now. We were keeping them
when we originally thought we would come back to being concurrent by
default. But we've shifted and now sync-by default is the desired
behavior long term, so there's no need to keep all these forked tests
around.

I'll follow up to delete more of the forked behavior if possible.
Ideally we wouldn't need this flag even if we're still using
`allowConcurrentByDefault`.",https://api.github.com/repos/facebook/react/git/commits/018c58c9c65452cff25aaf1f38f78a9b90d8e5c1,2023-06-01,"
Ideally we wouldn't need this flag even if we're still using
`allowConcurrentByDefault`."
31,C_kwDOAJy2KtoAKGI1NWQzMTk1NTk4Mjg1MTI4NGJiNDM3YTUxODdhNmM1NmUzNjY1Mzk,Josh Story,GitHub,"Rename HostConfig files to FiberConfig to clarify they are configs fo… (#26592)

part of https://github.com/facebook/react/pull/26571

merging separately to improve tracking of files renames in git

Rename HostConfig files to FiberConfig to clarify they are configs for
Fiber and not Fizz/Flight. This better conforms to the naming used in
Flight and now Fizz of `ReactFlightServerConfig` and `ReactFizzConfig`",https://api.github.com/repos/facebook/react/git/commits/b55d31955982851284bb437a5187a6c56e366539,2023-04-10,Rename HostConfig files to FiberConfig to clarify they are configs fo… (#26592)
31,C_kwDOAJy2KtoAKGI1NWQzMTk1NTk4Mjg1MTI4NGJiNDM3YTUxODdhNmM1NmUzNjY1Mzk,Josh Story,GitHub,"Rename HostConfig files to FiberConfig to clarify they are configs fo… (#26592)

part of https://github.com/facebook/react/pull/26571

merging separately to improve tracking of files renames in git

Rename HostConfig files to FiberConfig to clarify they are configs for
Fiber and not Fizz/Flight. This better conforms to the naming used in
Flight and now Fizz of `ReactFlightServerConfig` and `ReactFizzConfig`",https://api.github.com/repos/facebook/react/git/commits/b55d31955982851284bb437a5187a6c56e366539,2023-04-10,"part of 
merging separately to improve tracking of files renames in git
Rename HostConfig files to FiberConfig to clarify they are configs for
Fiber and not Fizz/Flight"
31,C_kwDOAJy2KtoAKGI1NWQzMTk1NTk4Mjg1MTI4NGJiNDM3YTUxODdhNmM1NmUzNjY1Mzk,Josh Story,GitHub,"Rename HostConfig files to FiberConfig to clarify they are configs fo… (#26592)

part of https://github.com/facebook/react/pull/26571

merging separately to improve tracking of files renames in git

Rename HostConfig files to FiberConfig to clarify they are configs for
Fiber and not Fizz/Flight. This better conforms to the naming used in
Flight and now Fizz of `ReactFlightServerConfig` and `ReactFizzConfig`",https://api.github.com/repos/facebook/react/git/commits/b55d31955982851284bb437a5187a6c56e366539,2023-04-10,"This better conforms to the naming used in
Flight and now Fizz of `ReactFlightServerConfig` and `ReactFizzConfig`"
32,C_kwDOAJy2KtoAKDc5MGViYzk2MmRlNTczYTM3ZTQ3NTUyMDdlYmE5MWIwN2EwZmExNzI,Sophie Alpert,GitHub,"Remove no-fallthrough lint suppressions (#26553)

The lint rule already understands a normal comment. Also a bunch of
these were unnecessary.",https://api.github.com/repos/facebook/react/git/commits/790ebc962de573a37e4755207eba91b07a0fa172,2023-04-05,Remove no-fallthrough lint suppressions (#26553)
32,C_kwDOAJy2KtoAKDc5MGViYzk2MmRlNTczYTM3ZTQ3NTUyMDdlYmE5MWIwN2EwZmExNzI,Sophie Alpert,GitHub,"Remove no-fallthrough lint suppressions (#26553)

The lint rule already understands a normal comment. Also a bunch of
these were unnecessary.",https://api.github.com/repos/facebook/react/git/commits/790ebc962de573a37e4755207eba91b07a0fa172,2023-04-05,The lint rule already understands a normal comment
32,C_kwDOAJy2KtoAKDc5MGViYzk2MmRlNTczYTM3ZTQ3NTUyMDdlYmE5MWIwN2EwZmExNzI,Sophie Alpert,GitHub,"Remove no-fallthrough lint suppressions (#26553)

The lint rule already understands a normal comment. Also a bunch of
these were unnecessary.",https://api.github.com/repos/facebook/react/git/commits/790ebc962de573a37e4755207eba91b07a0fa172,2023-04-05,"Also a bunch of
these were unnecessary."
33,C_kwDOAJy2KtoAKGRhOTRlOGIyNGEzZjMxYTNlODA1ZjliZjZiYmE3MzA1NWFhZDlkNDE,Jan Kassens,GitHub,"Revert ""Cleanup enableSyncDefaultUpdate flag (#26236)"" (#26528)

This reverts commit b2ae9ddb3b497d16a7c27c051da1827d08871138.

While the feature flag is fully rolled out, these tests are also testing
behavior set with an unstable flag on root, which for now we want to
preserve.

Not sure if there's a better way then adding a dynamic feature flag to
the www build?",https://api.github.com/repos/facebook/react/git/commits/da94e8b24a3f31a3e805f9bf6bba73055aad9d41,2023-04-04,"Revert ""Cleanup enableSyncDefaultUpdate flag (#26236)"" (#26528)"
33,C_kwDOAJy2KtoAKGRhOTRlOGIyNGEzZjMxYTNlODA1ZjliZjZiYmE3MzA1NWFhZDlkNDE,Jan Kassens,GitHub,"Revert ""Cleanup enableSyncDefaultUpdate flag (#26236)"" (#26528)

This reverts commit b2ae9ddb3b497d16a7c27c051da1827d08871138.

While the feature flag is fully rolled out, these tests are also testing
behavior set with an unstable flag on root, which for now we want to
preserve.

Not sure if there's a better way then adding a dynamic feature flag to
the www build?",https://api.github.com/repos/facebook/react/git/commits/da94e8b24a3f31a3e805f9bf6bba73055aad9d41,2023-04-04,This reverts commit b2ae9ddb3b497d16a7c27c051da1827d08871138
33,C_kwDOAJy2KtoAKGRhOTRlOGIyNGEzZjMxYTNlODA1ZjliZjZiYmE3MzA1NWFhZDlkNDE,Jan Kassens,GitHub,"Revert ""Cleanup enableSyncDefaultUpdate flag (#26236)"" (#26528)

This reverts commit b2ae9ddb3b497d16a7c27c051da1827d08871138.

While the feature flag is fully rolled out, these tests are also testing
behavior set with an unstable flag on root, which for now we want to
preserve.

Not sure if there's a better way then adding a dynamic feature flag to
the www build?",https://api.github.com/repos/facebook/react/git/commits/da94e8b24a3f31a3e805f9bf6bba73055aad9d41,2023-04-04,"
While the feature flag is fully rolled out, these tests are also testing
behavior set with an unstable flag on root, which for now we want to
preserve"
33,C_kwDOAJy2KtoAKGRhOTRlOGIyNGEzZjMxYTNlODA1ZjliZjZiYmE3MzA1NWFhZDlkNDE,Jan Kassens,GitHub,"Revert ""Cleanup enableSyncDefaultUpdate flag (#26236)"" (#26528)

This reverts commit b2ae9ddb3b497d16a7c27c051da1827d08871138.

While the feature flag is fully rolled out, these tests are also testing
behavior set with an unstable flag on root, which for now we want to
preserve.

Not sure if there's a better way then adding a dynamic feature flag to
the www build?",https://api.github.com/repos/facebook/react/git/commits/da94e8b24a3f31a3e805f9bf6bba73055aad9d41,2023-04-04,"
Not sure if there's a better way then adding a dynamic feature flag to
the www build?"
34,C_kwDOAJy2KtoAKGFmZWExZDBjNTM2ZTAzMzY3MzViMGVhNWM3NGY2MzU1MjdiNjU3ODU,Jan Kassens,GitHub,"[flow] make Flow suppressions explicit on the error (#26487)

Added an explicit type to all $FlowFixMe suppressions to reduce
over-suppressions of new errors that might be caused on the same lines.

Also removes suppressions that aren't used (e.g. in a `@noflow` file as
they're purely misleading)

Test Plan:
yarn flow-ci",https://api.github.com/repos/facebook/react/git/commits/afea1d0c536e0336735b0ea5c74f635527b65785,2023-03-27,[flow] make Flow suppressions explicit on the error (#26487)
34,C_kwDOAJy2KtoAKGFmZWExZDBjNTM2ZTAzMzY3MzViMGVhNWM3NGY2MzU1MjdiNjU3ODU,Jan Kassens,GitHub,"[flow] make Flow suppressions explicit on the error (#26487)

Added an explicit type to all $FlowFixMe suppressions to reduce
over-suppressions of new errors that might be caused on the same lines.

Also removes suppressions that aren't used (e.g. in a `@noflow` file as
they're purely misleading)

Test Plan:
yarn flow-ci",https://api.github.com/repos/facebook/react/git/commits/afea1d0c536e0336735b0ea5c74f635527b65785,2023-03-27,"Added an explicit type to all $FlowFixMe suppressions to reduce
over-suppressions of new errors that might be caused on the same lines"
34,C_kwDOAJy2KtoAKGFmZWExZDBjNTM2ZTAzMzY3MzViMGVhNWM3NGY2MzU1MjdiNjU3ODU,Jan Kassens,GitHub,"[flow] make Flow suppressions explicit on the error (#26487)

Added an explicit type to all $FlowFixMe suppressions to reduce
over-suppressions of new errors that might be caused on the same lines.

Also removes suppressions that aren't used (e.g. in a `@noflow` file as
they're purely misleading)

Test Plan:
yarn flow-ci",https://api.github.com/repos/facebook/react/git/commits/afea1d0c536e0336735b0ea5c74f635527b65785,2023-03-27,"
Also removes suppressions that aren't used (e.g"
34,C_kwDOAJy2KtoAKGFmZWExZDBjNTM2ZTAzMzY3MzViMGVhNWM3NGY2MzU1MjdiNjU3ODU,Jan Kassens,GitHub,"[flow] make Flow suppressions explicit on the error (#26487)

Added an explicit type to all $FlowFixMe suppressions to reduce
over-suppressions of new errors that might be caused on the same lines.

Also removes suppressions that aren't used (e.g. in a `@noflow` file as
they're purely misleading)

Test Plan:
yarn flow-ci",https://api.github.com/repos/facebook/react/git/commits/afea1d0c536e0336735b0ea5c74f635527b65785,2023-03-27,"in a `@noflow` file as
they're purely misleading)
Test Plan:
yarn flow-ci"
35,C_kwDOAJy2KtoAKGQzMTBkNjU0YTdjN2FhYjZjODIxM2RhODRlZjM2ZGZiYTgyNzExYjA,Sebastian Markbåge,GitHub,"Avoid meta programming to initialize functions in module scope  (#26388)

I'm trying to get rid of all meta programming in the module scope so
that closure can do a better job figuring out cyclic dependencies and
ability to reorder.

This is converting a lot of the patterns that assign functions
conditionally to using function declarations instead.

```
let fn;
if (__DEV__) {
  fn = function() {
    ...
  };
}
```
->
```
function fn() {
  if (__DEV__) {
    ...
  }
}
```",https://api.github.com/repos/facebook/react/git/commits/d310d654a7c7aab6c8213da84ef36dfba82711b0,2023-03-15,Avoid meta programming to initialize functions in module scope  (#26388)
35,C_kwDOAJy2KtoAKGQzMTBkNjU0YTdjN2FhYjZjODIxM2RhODRlZjM2ZGZiYTgyNzExYjA,Sebastian Markbåge,GitHub,"Avoid meta programming to initialize functions in module scope  (#26388)

I'm trying to get rid of all meta programming in the module scope so
that closure can do a better job figuring out cyclic dependencies and
ability to reorder.

This is converting a lot of the patterns that assign functions
conditionally to using function declarations instead.

```
let fn;
if (__DEV__) {
  fn = function() {
    ...
  };
}
```
->
```
function fn() {
  if (__DEV__) {
    ...
  }
}
```",https://api.github.com/repos/facebook/react/git/commits/d310d654a7c7aab6c8213da84ef36dfba82711b0,2023-03-15,"I'm trying to get rid of all meta programming in the module scope so
that closure can do a better job figuring out cyclic dependencies and
ability to reorder"
35,C_kwDOAJy2KtoAKGQzMTBkNjU0YTdjN2FhYjZjODIxM2RhODRlZjM2ZGZiYTgyNzExYjA,Sebastian Markbåge,GitHub,"Avoid meta programming to initialize functions in module scope  (#26388)

I'm trying to get rid of all meta programming in the module scope so
that closure can do a better job figuring out cyclic dependencies and
ability to reorder.

This is converting a lot of the patterns that assign functions
conditionally to using function declarations instead.

```
let fn;
if (__DEV__) {
  fn = function() {
    ...
  };
}
```
->
```
function fn() {
  if (__DEV__) {
    ...
  }
}
```",https://api.github.com/repos/facebook/react/git/commits/d310d654a7c7aab6c8213da84ef36dfba82711b0,2023-03-15,"
This is converting a lot of the patterns that assign functions
conditionally to using function declarations instead"
35,C_kwDOAJy2KtoAKGQzMTBkNjU0YTdjN2FhYjZjODIxM2RhODRlZjM2ZGZiYTgyNzExYjA,Sebastian Markbåge,GitHub,"Avoid meta programming to initialize functions in module scope  (#26388)

I'm trying to get rid of all meta programming in the module scope so
that closure can do a better job figuring out cyclic dependencies and
ability to reorder.

This is converting a lot of the patterns that assign functions
conditionally to using function declarations instead.

```
let fn;
if (__DEV__) {
  fn = function() {
    ...
  };
}
```
->
```
function fn() {
  if (__DEV__) {
    ...
  }
}
```",https://api.github.com/repos/facebook/react/git/commits/d310d654a7c7aab6c8213da84ef36dfba82711b0,2023-03-15,"
let fn;"
36,C_kwDOAJy2KtoAKGIyYWU5ZGRiM2I0OTdkMTZhN2MyN2MwNTFkYTE4MjdkMDg4NzExMzg,Jan Kassens,GitHub,"Cleanup enableSyncDefaultUpdate flag (#26236)

This feature flag is enabled everywhere.",https://api.github.com/repos/facebook/react/git/commits/b2ae9ddb3b497d16a7c27c051da1827d08871138,2023-02-27,Cleanup enableSyncDefaultUpdate flag (#26236)
36,C_kwDOAJy2KtoAKGIyYWU5ZGRiM2I0OTdkMTZhN2MyN2MwNTFkYTE4MjdkMDg4NzExMzg,Jan Kassens,GitHub,"Cleanup enableSyncDefaultUpdate flag (#26236)

This feature flag is enabled everywhere.",https://api.github.com/repos/facebook/react/git/commits/b2ae9ddb3b497d16a7c27c051da1827d08871138,2023-02-27,This feature flag is enabled everywhere.
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,Model Float on Hoistables semantics (#26106)
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"## Hoistables
In the original implementation of Float, all hoisted elements were
treated like Resources"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"They had deduplication semantics and hydrated
based on a key"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"The reason is
each tag along is not dedupable based on only it's intrinsic properties"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)
Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"We could try merging props, but
that is still really hard to reason about for authors"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"We
should be able to update props on these instances"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
Hoistable is a generalization of what Float tries to model for hoisting"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float
### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`)"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
On the client, hoistable elements largely operate like HostComponents"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
The most notable difference is in the hydration strategy"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"We also do this
in the commit phase rather than the render phase"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
Resources hoist and dedupe via an `href` key and are ref counted"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references
## `<style>` support
In earlier implementations there was no support for <style> tags"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`
It may seem odd at first to require an href to get Resource semantics
for a style tag"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
and the precedence is there to allow for interleaving of both kinds of
Style resources"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"
## refactor notes
generalization of the concept
checks and to use less memory overall
Fiber has a memoizedState"
37,C_kwDOAJy2KtoAKDYzOTZiNjY0MTE4NDQyZjNjMmVhZTdiZjEzNzMyZmNiMjdiZGE5OGY,Josh Story,GitHub,"Model Float on Hoistables semantics (#26106)

## Hoistables

In the original implementation of Float, all hoisted elements were
treated like Resources. They had deduplication semantics and hydrated
based on a key. This made certain kinds of hoists very challenging such
as sequences of meta tags for `og:image:...` metadata. The reason is
each tag along is not dedupable based on only it's intrinsic properties.
two identical tags may need to be included and hoisted together with
preceding meta tags that describe a semantic object with a linear set of
html nodes.

It was clear that the concept of Browser Resources (stylesheets /
scripts / preloads) did not extend universally to all hositable tags
(title, meta, other links, etc...)

Additionally while Resources benefit from deduping they suffer an
inability to update because while we may have multiple rendered elements
that refer to a single Resource it isn't unambiguous which element owns
the props on the underlying resource. We could try merging props, but
that is still really hard to reason about for authors. Instead we
restrict Resource semantics to freezing the props at the time the
Resource is first constructed and warn if you attempt to render the same
Resource with different props via another rendered element or by
updating an existing element for that Resource.

This lack of updating restriction is however way more extreme than
necessary for instances that get hoisted but otherwise do not dedupe;
where there is a well defined DOM instance for each rendered element. We
should be able to update props on these instances.

Hoistable is a generalization of what Float tries to model for hoisting.
Instead of assuming every hoistable element is a Resource we now have
two distinct categories, hoistable elements and hoistable resources. As
one might guess the former has semantics that match regular Host
Components except the placement of the node is usually in the <head>.
The latter continues to behave how the original implementation of
HostResource behaved with the first iteration of Float

### Hoistable Element
On the server hoistable elements render just like regular tags except
the output is stored in special queues that can be emitted in the stream
earlier than they otherwise would be if rendered in place. This also
allow for instance the ability to render a hoistable before even
rendering the <html> tag because the queues for hoistable elements won't
flush until after we have flushed the preamble (`<DOCTYPE
html><html><head>`).

On the client, hoistable elements largely operate like HostComponents.
The most notable difference is in the hydration strategy. If we are
hydrating and encounter a hoistable element we will look for all tags in
the document that could potentially be a match and we check whether the
attributes match the props for this particular instance. We also do this
in the commit phase rather than the render phase. The reason hydration
can be done for HostComponents in render is the instance will be removed
from the document if hydration fails so mutating it in render is safe.
For hoistables the nodes are not in a hydration boundary (Root or
SuspenseBoundary at time of writing) and thus if hydration fails and we
may have an instance marked as bound to some Fiber when that Fiber never
commits. Moving the hydration matching to commit ensures we will always
succeed in pairing the hoisted DOM instance with a Fiber that has
committed.

### Hoistable Resource
On the server and client the semantics of Resources are largely the same
they just don't apply to title, meta, and most link tags anymore.
Resources hoist and dedupe via an `href` key and are ref counted. In a
future update we will add a garbage collector so we can clean up
Resources that no longer have any references

## `<style>` support
In earlier implementations there was no support for <style> tags. This
PR adds support for treating `<style href=""...""
precedence=""..."">...</style>` as a Resource analagous to `<link
rel=""stylesheet"" href=""..."" precedence=""..."" />`

It may seem odd at first to require an href to get Resource semantics
for a style tag. The rationale is that these are for inlining of actual
external stylesheets as an optimization and for URI like scoping of
inline styles for css-in-js libraries. The href indicates that the key
space for `<style>` and `<link rel=""stylesheet"" />` Resources is shared.
and the precedence is there to allow for interleaving of both kinds of
Style resources. This is an advanced feature that we do not expect most
app developers to use directly but will be quite handy for various
styling libraries and for folks who want to inline as much as possible
once Fizz supports this feature.

## refactor notes
* HostResource Fiber type is renamed HostHoistable to reflect the
generalization of the concept
* The Resource object representation is modified to reduce hidden class
checks and to use less memory overall
* The thing that distinguishes a resource from an element is whether the
Fiber has a memoizedState. If it does, it will use resource semantics,
otherwise element semantics
* The time complexity of matching hositable elements for hydration
should be improved",https://api.github.com/repos/facebook/react/git/commits/6396b664118442f3c2eae7bf13732fcb27bda98f,2023-02-10,"If it does, it will use resource semantics,
otherwise element semantics
should be improved"
38,C_kwDOAJy2KtoAKDZiMzA4MzI2NjY4NmY2MmIyOTQ2MmQzMmRlNzVjNmU3MWY3YmEzZTM,Jan Kassens,GitHub,"Upgrade prettier (#26081)

The old version of prettier we were using didn't support the Flow syntax
to access properties in a type using `SomeType['prop']`. This updates
`prettier` and `rollup-plugin-prettier` to the latest versions.

I added the prettier config `arrowParens: ""avoid""` to reduce the diff
size as the default has changed in Prettier 2.0. The largest amount of
changes comes from function expressions now having a space. This doesn't
have an option to preserve the old behavior, so we have to update this.",https://api.github.com/repos/facebook/react/git/commits/6b3083266686f62b29462d32de75c6e71f7ba3e3,2023-01-31,Upgrade prettier (#26081)
38,C_kwDOAJy2KtoAKDZiMzA4MzI2NjY4NmY2MmIyOTQ2MmQzMmRlNzVjNmU3MWY3YmEzZTM,Jan Kassens,GitHub,"Upgrade prettier (#26081)

The old version of prettier we were using didn't support the Flow syntax
to access properties in a type using `SomeType['prop']`. This updates
`prettier` and `rollup-plugin-prettier` to the latest versions.

I added the prettier config `arrowParens: ""avoid""` to reduce the diff
size as the default has changed in Prettier 2.0. The largest amount of
changes comes from function expressions now having a space. This doesn't
have an option to preserve the old behavior, so we have to update this.",https://api.github.com/repos/facebook/react/git/commits/6b3083266686f62b29462d32de75c6e71f7ba3e3,2023-01-31,"The old version of prettier we were using didn't support the Flow syntax
to access properties in a type using `SomeType['prop']`"
38,C_kwDOAJy2KtoAKDZiMzA4MzI2NjY4NmY2MmIyOTQ2MmQzMmRlNzVjNmU3MWY3YmEzZTM,Jan Kassens,GitHub,"Upgrade prettier (#26081)

The old version of prettier we were using didn't support the Flow syntax
to access properties in a type using `SomeType['prop']`. This updates
`prettier` and `rollup-plugin-prettier` to the latest versions.

I added the prettier config `arrowParens: ""avoid""` to reduce the diff
size as the default has changed in Prettier 2.0. The largest amount of
changes comes from function expressions now having a space. This doesn't
have an option to preserve the old behavior, so we have to update this.",https://api.github.com/repos/facebook/react/git/commits/6b3083266686f62b29462d32de75c6e71f7ba3e3,2023-01-31,"This updates
`prettier` and `rollup-plugin-prettier` to the latest versions"
38,C_kwDOAJy2KtoAKDZiMzA4MzI2NjY4NmY2MmIyOTQ2MmQzMmRlNzVjNmU3MWY3YmEzZTM,Jan Kassens,GitHub,"Upgrade prettier (#26081)

The old version of prettier we were using didn't support the Flow syntax
to access properties in a type using `SomeType['prop']`. This updates
`prettier` and `rollup-plugin-prettier` to the latest versions.

I added the prettier config `arrowParens: ""avoid""` to reduce the diff
size as the default has changed in Prettier 2.0. The largest amount of
changes comes from function expressions now having a space. This doesn't
have an option to preserve the old behavior, so we have to update this.",https://api.github.com/repos/facebook/react/git/commits/6b3083266686f62b29462d32de75c6e71f7ba3e3,2023-01-31,"
I added the prettier config `arrowParens: ""avoid""` to reduce the diff
size as the default has changed in Prettier 2.0"
38,C_kwDOAJy2KtoAKDZiMzA4MzI2NjY4NmY2MmIyOTQ2MmQzMmRlNzVjNmU3MWY3YmEzZTM,Jan Kassens,GitHub,"Upgrade prettier (#26081)

The old version of prettier we were using didn't support the Flow syntax
to access properties in a type using `SomeType['prop']`. This updates
`prettier` and `rollup-plugin-prettier` to the latest versions.

I added the prettier config `arrowParens: ""avoid""` to reduce the diff
size as the default has changed in Prettier 2.0. The largest amount of
changes comes from function expressions now having a space. This doesn't
have an option to preserve the old behavior, so we have to update this.",https://api.github.com/repos/facebook/react/git/commits/6b3083266686f62b29462d32de75c6e71f7ba3e3,2023-01-31,"The largest amount of
changes comes from function expressions now having a space"
38,C_kwDOAJy2KtoAKDZiMzA4MzI2NjY4NmY2MmIyOTQ2MmQzMmRlNzVjNmU3MWY3YmEzZTM,Jan Kassens,GitHub,"Upgrade prettier (#26081)

The old version of prettier we were using didn't support the Flow syntax
to access properties in a type using `SomeType['prop']`. This updates
`prettier` and `rollup-plugin-prettier` to the latest versions.

I added the prettier config `arrowParens: ""avoid""` to reduce the diff
size as the default has changed in Prettier 2.0. The largest amount of
changes comes from function expressions now having a space. This doesn't
have an option to preserve the old behavior, so we have to update this.",https://api.github.com/repos/facebook/react/git/commits/6b3083266686f62b29462d32de75c6e71f7ba3e3,2023-01-31,"This doesn't
have an option to preserve the old behavior, so we have to update this."
39,C_kwDOAJy2KtoAKDBiNGY0NDMwMjBhZjM4NmYyYjQ4YzQ3YzA3NGNiNTA0ZWQ2NzJkYzg,Jan Kassens,GitHub,"[flow] enable enforce_local_inference_annotations (#25921)

This setting is an incremental path to the next Flow version enforcing
type annotations on most functions (except some inline callbacks).

Used
```
node_modules/.bin/flow codemod annotate-functions-and-classes --write .
```
to add a majority of the types with some hand cleanup when for large
inferred objects that should just be `Fiber` or weird constructs
including `any`.

Suppressed the remaining issues.

Builds on #25918",https://api.github.com/repos/facebook/react/git/commits/0b4f443020af386f2b48c47c074cb504ed672dc8,2023-01-09,[flow] enable enforce_local_inference_annotations (#25921)
39,C_kwDOAJy2KtoAKDBiNGY0NDMwMjBhZjM4NmYyYjQ4YzQ3YzA3NGNiNTA0ZWQ2NzJkYzg,Jan Kassens,GitHub,"[flow] enable enforce_local_inference_annotations (#25921)

This setting is an incremental path to the next Flow version enforcing
type annotations on most functions (except some inline callbacks).

Used
```
node_modules/.bin/flow codemod annotate-functions-and-classes --write .
```
to add a majority of the types with some hand cleanup when for large
inferred objects that should just be `Fiber` or weird constructs
including `any`.

Suppressed the remaining issues.

Builds on #25918",https://api.github.com/repos/facebook/react/git/commits/0b4f443020af386f2b48c47c074cb504ed672dc8,2023-01-09,"This setting is an incremental path to the next Flow version enforcing
type annotations on most functions (except some inline callbacks)"
39,C_kwDOAJy2KtoAKDBiNGY0NDMwMjBhZjM4NmYyYjQ4YzQ3YzA3NGNiNTA0ZWQ2NzJkYzg,Jan Kassens,GitHub,"[flow] enable enforce_local_inference_annotations (#25921)

This setting is an incremental path to the next Flow version enforcing
type annotations on most functions (except some inline callbacks).

Used
```
node_modules/.bin/flow codemod annotate-functions-and-classes --write .
```
to add a majority of the types with some hand cleanup when for large
inferred objects that should just be `Fiber` or weird constructs
including `any`.

Suppressed the remaining issues.

Builds on #25918",https://api.github.com/repos/facebook/react/git/commits/0b4f443020af386f2b48c47c074cb504ed672dc8,2023-01-09,"
Used
node_modules/.bin/flow codemod annotate-functions-and-classes --write "
39,C_kwDOAJy2KtoAKDBiNGY0NDMwMjBhZjM4NmYyYjQ4YzQ3YzA3NGNiNTA0ZWQ2NzJkYzg,Jan Kassens,GitHub,"[flow] enable enforce_local_inference_annotations (#25921)

This setting is an incremental path to the next Flow version enforcing
type annotations on most functions (except some inline callbacks).

Used
```
node_modules/.bin/flow codemod annotate-functions-and-classes --write .
```
to add a majority of the types with some hand cleanup when for large
inferred objects that should just be `Fiber` or weird constructs
including `any`.

Suppressed the remaining issues.

Builds on #25918",https://api.github.com/repos/facebook/react/git/commits/0b4f443020af386f2b48c47c074cb504ed672dc8,2023-01-09,"
to add a majority of the types with some hand cleanup when for large
inferred objects that should just be `Fiber` or weird constructs
including `any`"
39,C_kwDOAJy2KtoAKDBiNGY0NDMwMjBhZjM4NmYyYjQ4YzQ3YzA3NGNiNTA0ZWQ2NzJkYzg,Jan Kassens,GitHub,"[flow] enable enforce_local_inference_annotations (#25921)

This setting is an incremental path to the next Flow version enforcing
type annotations on most functions (except some inline callbacks).

Used
```
node_modules/.bin/flow codemod annotate-functions-and-classes --write .
```
to add a majority of the types with some hand cleanup when for large
inferred objects that should just be `Fiber` or weird constructs
including `any`.

Suppressed the remaining issues.

Builds on #25918",https://api.github.com/repos/facebook/react/git/commits/0b4f443020af386f2b48c47c074cb504ed672dc8,2023-01-09,"
Suppressed the remaining issues"
39,C_kwDOAJy2KtoAKDBiNGY0NDMwMjBhZjM4NmYyYjQ4YzQ3YzA3NGNiNTA0ZWQ2NzJkYzg,Jan Kassens,GitHub,"[flow] enable enforce_local_inference_annotations (#25921)

This setting is an incremental path to the next Flow version enforcing
type annotations on most functions (except some inline callbacks).

Used
```
node_modules/.bin/flow codemod annotate-functions-and-classes --write .
```
to add a majority of the types with some hand cleanup when for large
inferred objects that should just be `Fiber` or weird constructs
including `any`.

Suppressed the remaining issues.

Builds on #25918",https://api.github.com/repos/facebook/react/git/commits/0b4f443020af386f2b48c47c074cb504ed672dc8,2023-01-09,"
Builds on #25918"
40,C_kwDOAJy2KtoAKDk5NmU0YzBkNTZkYWJhYjM4MmNhOTMyY2Q1Yjg1MTdlNjMwMjA5OTk,Samuel Susla,GitHub,"Offscreen add attach (#25603)

`Offscreen.attach` is imperative API to signal to Offscreen that its
updates should be high priority and effects should be mounted. Coupled
with `Offscreen.detach` it gives ability to manually control Offscreen.
Unlike with mode `visible` and `hidden`, it is developers job to make
sure contents of Offscreen are not visible to users.
`Offscreen.attach` only works if mode is `manual`.

Example uses:
```jsx
let offscreenRef = useRef(null);
<Offscreen mode={'manual'} ref={offscreenRef)}>
  <Child />
</Offscreen>

// ------

// Offscreen is attached by default. 
// For example user scrolls away and Offscreen subtree is not visible anymore.
offscreenRef.current.detach();


// User scrolls back and Offscreen subtree is visible again.
offscreenRef.current.attach();
```

Co-authored-by: Andrew Clark <git@andrewclark.io>",https://api.github.com/repos/facebook/react/git/commits/996e4c0d56dabab382ca932cd5b8517e63020999,2022-12-12,Offscreen add attach (#25603)
40,C_kwDOAJy2KtoAKDk5NmU0YzBkNTZkYWJhYjM4MmNhOTMyY2Q1Yjg1MTdlNjMwMjA5OTk,Samuel Susla,GitHub,"Offscreen add attach (#25603)

`Offscreen.attach` is imperative API to signal to Offscreen that its
updates should be high priority and effects should be mounted. Coupled
with `Offscreen.detach` it gives ability to manually control Offscreen.
Unlike with mode `visible` and `hidden`, it is developers job to make
sure contents of Offscreen are not visible to users.
`Offscreen.attach` only works if mode is `manual`.

Example uses:
```jsx
let offscreenRef = useRef(null);
<Offscreen mode={'manual'} ref={offscreenRef)}>
  <Child />
</Offscreen>

// ------

// Offscreen is attached by default. 
// For example user scrolls away and Offscreen subtree is not visible anymore.
offscreenRef.current.detach();


// User scrolls back and Offscreen subtree is visible again.
offscreenRef.current.attach();
```

Co-authored-by: Andrew Clark <git@andrewclark.io>",https://api.github.com/repos/facebook/react/git/commits/996e4c0d56dabab382ca932cd5b8517e63020999,2022-12-12,"`Offscreen.attach` is imperative API to signal to Offscreen that its
updates should be high priority and effects should be mounted"
40,C_kwDOAJy2KtoAKDk5NmU0YzBkNTZkYWJhYjM4MmNhOTMyY2Q1Yjg1MTdlNjMwMjA5OTk,Samuel Susla,GitHub,"Offscreen add attach (#25603)

`Offscreen.attach` is imperative API to signal to Offscreen that its
updates should be high priority and effects should be mounted. Coupled
with `Offscreen.detach` it gives ability to manually control Offscreen.
Unlike with mode `visible` and `hidden`, it is developers job to make
sure contents of Offscreen are not visible to users.
`Offscreen.attach` only works if mode is `manual`.

Example uses:
```jsx
let offscreenRef = useRef(null);
<Offscreen mode={'manual'} ref={offscreenRef)}>
  <Child />
</Offscreen>

// ------

// Offscreen is attached by default. 
// For example user scrolls away and Offscreen subtree is not visible anymore.
offscreenRef.current.detach();


// User scrolls back and Offscreen subtree is visible again.
offscreenRef.current.attach();
```

Co-authored-by: Andrew Clark <git@andrewclark.io>",https://api.github.com/repos/facebook/react/git/commits/996e4c0d56dabab382ca932cd5b8517e63020999,2022-12-12,"Coupled
with `Offscreen.detach` it gives ability to manually control Offscreen"
40,C_kwDOAJy2KtoAKDk5NmU0YzBkNTZkYWJhYjM4MmNhOTMyY2Q1Yjg1MTdlNjMwMjA5OTk,Samuel Susla,GitHub,"Offscreen add attach (#25603)

`Offscreen.attach` is imperative API to signal to Offscreen that its
updates should be high priority and effects should be mounted. Coupled
with `Offscreen.detach` it gives ability to manually control Offscreen.
Unlike with mode `visible` and `hidden`, it is developers job to make
sure contents of Offscreen are not visible to users.
`Offscreen.attach` only works if mode is `manual`.

Example uses:
```jsx
let offscreenRef = useRef(null);
<Offscreen mode={'manual'} ref={offscreenRef)}>
  <Child />
</Offscreen>

// ------

// Offscreen is attached by default. 
// For example user scrolls away and Offscreen subtree is not visible anymore.
offscreenRef.current.detach();


// User scrolls back and Offscreen subtree is visible again.
offscreenRef.current.attach();
```

Co-authored-by: Andrew Clark <git@andrewclark.io>",https://api.github.com/repos/facebook/react/git/commits/996e4c0d56dabab382ca932cd5b8517e63020999,2022-12-12,"
Unlike with mode `visible` and `hidden`, it is developers job to make
sure contents of Offscreen are not visible to users"
40,C_kwDOAJy2KtoAKDk5NmU0YzBkNTZkYWJhYjM4MmNhOTMyY2Q1Yjg1MTdlNjMwMjA5OTk,Samuel Susla,GitHub,"Offscreen add attach (#25603)

`Offscreen.attach` is imperative API to signal to Offscreen that its
updates should be high priority and effects should be mounted. Coupled
with `Offscreen.detach` it gives ability to manually control Offscreen.
Unlike with mode `visible` and `hidden`, it is developers job to make
sure contents of Offscreen are not visible to users.
`Offscreen.attach` only works if mode is `manual`.

Example uses:
```jsx
let offscreenRef = useRef(null);
<Offscreen mode={'manual'} ref={offscreenRef)}>
  <Child />
</Offscreen>

// ------

// Offscreen is attached by default. 
// For example user scrolls away and Offscreen subtree is not visible anymore.
offscreenRef.current.detach();


// User scrolls back and Offscreen subtree is visible again.
offscreenRef.current.attach();
```

Co-authored-by: Andrew Clark <git@andrewclark.io>",https://api.github.com/repos/facebook/react/git/commits/996e4c0d56dabab382ca932cd5b8517e63020999,2022-12-12,"
`Offscreen.attach` only works if mode is `manual`"
40,C_kwDOAJy2KtoAKDk5NmU0YzBkNTZkYWJhYjM4MmNhOTMyY2Q1Yjg1MTdlNjMwMjA5OTk,Samuel Susla,GitHub,"Offscreen add attach (#25603)

`Offscreen.attach` is imperative API to signal to Offscreen that its
updates should be high priority and effects should be mounted. Coupled
with `Offscreen.detach` it gives ability to manually control Offscreen.
Unlike with mode `visible` and `hidden`, it is developers job to make
sure contents of Offscreen are not visible to users.
`Offscreen.attach` only works if mode is `manual`.

Example uses:
```jsx
let offscreenRef = useRef(null);
<Offscreen mode={'manual'} ref={offscreenRef)}>
  <Child />
</Offscreen>

// ------

// Offscreen is attached by default. 
// For example user scrolls away and Offscreen subtree is not visible anymore.
offscreenRef.current.detach();


// User scrolls back and Offscreen subtree is visible again.
offscreenRef.current.attach();
```

Co-authored-by: Andrew Clark <git@andrewclark.io>",https://api.github.com/repos/facebook/react/git/commits/996e4c0d56dabab382ca932cd5b8517e63020999,2022-12-12,"
Example uses:
```jsx
let offscreenRef = useRef(null);
<Offscreen mode={'manual'} ref={offscreenRef)}>
  <Child />
</Offscreen>
// Offscreen is attached by default"
40,C_kwDOAJy2KtoAKDk5NmU0YzBkNTZkYWJhYjM4MmNhOTMyY2Q1Yjg1MTdlNjMwMjA5OTk,Samuel Susla,GitHub,"Offscreen add attach (#25603)

`Offscreen.attach` is imperative API to signal to Offscreen that its
updates should be high priority and effects should be mounted. Coupled
with `Offscreen.detach` it gives ability to manually control Offscreen.
Unlike with mode `visible` and `hidden`, it is developers job to make
sure contents of Offscreen are not visible to users.
`Offscreen.attach` only works if mode is `manual`.

Example uses:
```jsx
let offscreenRef = useRef(null);
<Offscreen mode={'manual'} ref={offscreenRef)}>
  <Child />
</Offscreen>

// ------

// Offscreen is attached by default. 
// For example user scrolls away and Offscreen subtree is not visible anymore.
offscreenRef.current.detach();


// User scrolls back and Offscreen subtree is visible again.
offscreenRef.current.attach();
```

Co-authored-by: Andrew Clark <git@andrewclark.io>",https://api.github.com/repos/facebook/react/git/commits/996e4c0d56dabab382ca932cd5b8517e63020999,2022-12-12,"
// For example user scrolls away and Offscreen subtree is not visible anymore"
40,C_kwDOAJy2KtoAKDk5NmU0YzBkNTZkYWJhYjM4MmNhOTMyY2Q1Yjg1MTdlNjMwMjA5OTk,Samuel Susla,GitHub,"Offscreen add attach (#25603)

`Offscreen.attach` is imperative API to signal to Offscreen that its
updates should be high priority and effects should be mounted. Coupled
with `Offscreen.detach` it gives ability to manually control Offscreen.
Unlike with mode `visible` and `hidden`, it is developers job to make
sure contents of Offscreen are not visible to users.
`Offscreen.attach` only works if mode is `manual`.

Example uses:
```jsx
let offscreenRef = useRef(null);
<Offscreen mode={'manual'} ref={offscreenRef)}>
  <Child />
</Offscreen>

// ------

// Offscreen is attached by default. 
// For example user scrolls away and Offscreen subtree is not visible anymore.
offscreenRef.current.detach();


// User scrolls back and Offscreen subtree is visible again.
offscreenRef.current.attach();
```

Co-authored-by: Andrew Clark <git@andrewclark.io>",https://api.github.com/repos/facebook/react/git/commits/996e4c0d56dabab382ca932cd5b8517e63020999,2022-12-12,"
offscreenRef.current.detach();
// User scrolls back and Offscreen subtree is visible again"
40,C_kwDOAJy2KtoAKDk5NmU0YzBkNTZkYWJhYjM4MmNhOTMyY2Q1Yjg1MTdlNjMwMjA5OTk,Samuel Susla,GitHub,"Offscreen add attach (#25603)

`Offscreen.attach` is imperative API to signal to Offscreen that its
updates should be high priority and effects should be mounted. Coupled
with `Offscreen.detach` it gives ability to manually control Offscreen.
Unlike with mode `visible` and `hidden`, it is developers job to make
sure contents of Offscreen are not visible to users.
`Offscreen.attach` only works if mode is `manual`.

Example uses:
```jsx
let offscreenRef = useRef(null);
<Offscreen mode={'manual'} ref={offscreenRef)}>
  <Child />
</Offscreen>

// ------

// Offscreen is attached by default. 
// For example user scrolls away and Offscreen subtree is not visible anymore.
offscreenRef.current.detach();


// User scrolls back and Offscreen subtree is visible again.
offscreenRef.current.attach();
```

Co-authored-by: Andrew Clark <git@andrewclark.io>",https://api.github.com/repos/facebook/react/git/commits/996e4c0d56dabab382ca932cd5b8517e63020999,2022-12-12,"
offscreenRef.current.attach();
Co-authored-by: Andrew Clark <git@andrewclark.io>"
41,C_kwDOAJy2KtoAKGYxMDFjMmQwZDNhNmNiNWE3ODhhM2Q5MWZhZWY0ODQ2MmU0NWY1MTU,Jan Kassens,GitHub,"Remove Reconciler fork (2/2) (#25775)

We've heard from multiple contributors that the Reconciler forking
mechanism was confusing and/or annoying to deal with. Since it's
currently unused and there's no immediate plans to start using it again,
this removes the forking.

Fully removing the fork is split into 2 steps to preserve file history:

**#25774 previous PR that did the bulk of the work:**
- remove `enableNewReconciler` feature flag.
- remove `unstable_isNewReconciler` export
- remove eslint rules for cross fork imports
- remove `*.new.js` files and update imports
- merge non-suffixed files into `*.old` files where both exist
(sometimes types were defined there)

**This PR**
- rename `*.old` files",https://api.github.com/repos/facebook/react/git/commits/f101c2d0d3a6cb5a788a3d91faef48462e45f515,2022-12-02,Remove Reconciler fork (2/2) (#25775)
41,C_kwDOAJy2KtoAKGYxMDFjMmQwZDNhNmNiNWE3ODhhM2Q5MWZhZWY0ODQ2MmU0NWY1MTU,Jan Kassens,GitHub,"Remove Reconciler fork (2/2) (#25775)

We've heard from multiple contributors that the Reconciler forking
mechanism was confusing and/or annoying to deal with. Since it's
currently unused and there's no immediate plans to start using it again,
this removes the forking.

Fully removing the fork is split into 2 steps to preserve file history:

**#25774 previous PR that did the bulk of the work:**
- remove `enableNewReconciler` feature flag.
- remove `unstable_isNewReconciler` export
- remove eslint rules for cross fork imports
- remove `*.new.js` files and update imports
- merge non-suffixed files into `*.old` files where both exist
(sometimes types were defined there)

**This PR**
- rename `*.old` files",https://api.github.com/repos/facebook/react/git/commits/f101c2d0d3a6cb5a788a3d91faef48462e45f515,2022-12-02,"We've heard from multiple contributors that the Reconciler forking
mechanism was confusing and/or annoying to deal with"
41,C_kwDOAJy2KtoAKGYxMDFjMmQwZDNhNmNiNWE3ODhhM2Q5MWZhZWY0ODQ2MmU0NWY1MTU,Jan Kassens,GitHub,"Remove Reconciler fork (2/2) (#25775)

We've heard from multiple contributors that the Reconciler forking
mechanism was confusing and/or annoying to deal with. Since it's
currently unused and there's no immediate plans to start using it again,
this removes the forking.

Fully removing the fork is split into 2 steps to preserve file history:

**#25774 previous PR that did the bulk of the work:**
- remove `enableNewReconciler` feature flag.
- remove `unstable_isNewReconciler` export
- remove eslint rules for cross fork imports
- remove `*.new.js` files and update imports
- merge non-suffixed files into `*.old` files where both exist
(sometimes types were defined there)

**This PR**
- rename `*.old` files",https://api.github.com/repos/facebook/react/git/commits/f101c2d0d3a6cb5a788a3d91faef48462e45f515,2022-12-02,"Since it's
currently unused and there's no immediate plans to start using it again,
this removes the forking"
41,C_kwDOAJy2KtoAKGYxMDFjMmQwZDNhNmNiNWE3ODhhM2Q5MWZhZWY0ODQ2MmU0NWY1MTU,Jan Kassens,GitHub,"Remove Reconciler fork (2/2) (#25775)

We've heard from multiple contributors that the Reconciler forking
mechanism was confusing and/or annoying to deal with. Since it's
currently unused and there's no immediate plans to start using it again,
this removes the forking.

Fully removing the fork is split into 2 steps to preserve file history:

**#25774 previous PR that did the bulk of the work:**
- remove `enableNewReconciler` feature flag.
- remove `unstable_isNewReconciler` export
- remove eslint rules for cross fork imports
- remove `*.new.js` files and update imports
- merge non-suffixed files into `*.old` files where both exist
(sometimes types were defined there)

**This PR**
- rename `*.old` files",https://api.github.com/repos/facebook/react/git/commits/f101c2d0d3a6cb5a788a3d91faef48462e45f515,2022-12-02,"
Fully removing the fork is split into 2 steps to preserve file history:
- remove `enableNewReconciler` feature flag"
41,C_kwDOAJy2KtoAKGYxMDFjMmQwZDNhNmNiNWE3ODhhM2Q5MWZhZWY0ODQ2MmU0NWY1MTU,Jan Kassens,GitHub,"Remove Reconciler fork (2/2) (#25775)

We've heard from multiple contributors that the Reconciler forking
mechanism was confusing and/or annoying to deal with. Since it's
currently unused and there's no immediate plans to start using it again,
this removes the forking.

Fully removing the fork is split into 2 steps to preserve file history:

**#25774 previous PR that did the bulk of the work:**
- remove `enableNewReconciler` feature flag.
- remove `unstable_isNewReconciler` export
- remove eslint rules for cross fork imports
- remove `*.new.js` files and update imports
- merge non-suffixed files into `*.old` files where both exist
(sometimes types were defined there)

**This PR**
- rename `*.old` files",https://api.github.com/repos/facebook/react/git/commits/f101c2d0d3a6cb5a788a3d91faef48462e45f515,2022-12-02,"
- remove `unstable_isNewReconciler` export
- remove eslint rules for cross fork imports
- remove `*.new.js` files and update imports
- merge non-suffixed files into `*.old` files where both exist
(sometimes types were defined there)
- rename `*.old` files"
42,MDY6Q29tbWl0MTAyNzAyNTA6ZDY4NmYzZjE2YTc5NjAyNWNlMzJjZmI0MzFiNzBlZWY2ZGUxOTM0ZQ==,Andrew Clark,Andrew Clark,Add `.old` prefix to reconciler modules,https://api.github.com/repos/facebook/react/git/commits/d686f3f16a796025ce32cfb431b70eef6de1934e,2020-04-09,Add `.old` prefix to reconciler modules
42,MDY6Q29tbWl0MTAyNzAyNTA6ZDY4NmYzZjE2YTc5NjAyNWNlMzJjZmI0MzFiNzBlZWY2ZGUxOTM0ZQ==,Andrew Clark,Andrew Clark,Add `.old` prefix to reconciler modules,https://api.github.com/repos/facebook/react/git/commits/d686f3f16a796025ce32cfb431b70eef6de1934e,2020-04-09,
43,MDY6Q29tbWl0MTAyNzAyNTA6M2U5NGJjZTc2NWQzNTVkNzRmNmE2MGZlYjRhZGRiNmQxOTZlMzQ4Mg==,Sebastian Markbåge,GitHub,"Enable prefer-const lint rules (#18451)

* Enable prefer-const rule

Stylistically I don't like this but Closure Compiler takes advantage of
this information.

* Auto-fix lints

* Manually fix the remaining callsites",https://api.github.com/repos/facebook/react/git/commits/3e94bce765d355d74f6a60feb4addb6d196e3482,2020-04-01,Enable prefer-const lint rules (#18451)
43,MDY6Q29tbWl0MTAyNzAyNTA6M2U5NGJjZTc2NWQzNTVkNzRmNmE2MGZlYjRhZGRiNmQxOTZlMzQ4Mg==,Sebastian Markbåge,GitHub,"Enable prefer-const lint rules (#18451)

* Enable prefer-const rule

Stylistically I don't like this but Closure Compiler takes advantage of
this information.

* Auto-fix lints

* Manually fix the remaining callsites",https://api.github.com/repos/facebook/react/git/commits/3e94bce765d355d74f6a60feb4addb6d196e3482,2020-04-01,"Stylistically I don't like this but Closure Compiler takes advantage of
this information"
43,MDY6Q29tbWl0MTAyNzAyNTA6M2U5NGJjZTc2NWQzNTVkNzRmNmE2MGZlYjRhZGRiNmQxOTZlMzQ4Mg==,Sebastian Markbåge,GitHub,"Enable prefer-const lint rules (#18451)

* Enable prefer-const rule

Stylistically I don't like this but Closure Compiler takes advantage of
this information.

* Auto-fix lints

* Manually fix the remaining callsites",https://api.github.com/repos/facebook/react/git/commits/3e94bce765d355d74f6a60feb4addb6d196e3482,2020-04-01,
44,MDY6Q29tbWl0MTAyNzAyNTA6ZTJjNjcwMmZjYWFlZTM1Y2EwODk1N2JlNzY0NTgyMDE5MmQwZGFmMw==,Sebastian Markbåge,GitHub,"Remove ConcurrentMode and AsyncMode symbols (#18450)

This API was never released.",https://api.github.com/repos/facebook/react/git/commits/e2c6702fcaaee35ca08957be7645820192d0daf3,2020-04-01,Remove ConcurrentMode and AsyncMode symbols (#18450)
44,MDY6Q29tbWl0MTAyNzAyNTA6ZTJjNjcwMmZjYWFlZTM1Y2EwODk1N2JlNzY0NTgyMDE5MmQwZGFmMw==,Sebastian Markbåge,GitHub,"Remove ConcurrentMode and AsyncMode symbols (#18450)

This API was never released.",https://api.github.com/repos/facebook/react/git/commits/e2c6702fcaaee35ca08957be7645820192d0daf3,2020-04-01,This API was never released.
45,MDY6Q29tbWl0MTAyNzAyNTA6MGYzMzQ1NTNjOTU1OGE1NjAzN2I0ODFmZWRjOWI5ZmNhZDM2NDNlNw==,Sebastian Markbåge,GitHub,"Reset stateNode in resetWorkInProgress (#18448)

* test(SuspenseList): Add failing test for class component

* Reset stateNode when resetWorkInProgress

This is supposed to put the Fiber into the same state as if it was just
created by child fiber reconciliation. For newly created fibers, that means
that stateNode is null.

Co-authored-by: Sebastian Silbermann <silbermann.sebastian@gmail.com>",https://api.github.com/repos/facebook/react/git/commits/0f334553c9558a56037b481fedc9b9fcad3643e7,2020-04-01,Reset stateNode in resetWorkInProgress (#18448)
45,MDY6Q29tbWl0MTAyNzAyNTA6MGYzMzQ1NTNjOTU1OGE1NjAzN2I0ODFmZWRjOWI5ZmNhZDM2NDNlNw==,Sebastian Markbåge,GitHub,"Reset stateNode in resetWorkInProgress (#18448)

* test(SuspenseList): Add failing test for class component

* Reset stateNode when resetWorkInProgress

This is supposed to put the Fiber into the same state as if it was just
created by child fiber reconciliation. For newly created fibers, that means
that stateNode is null.

Co-authored-by: Sebastian Silbermann <silbermann.sebastian@gmail.com>",https://api.github.com/repos/facebook/react/git/commits/0f334553c9558a56037b481fedc9b9fcad3643e7,2020-04-01,"This is supposed to put the Fiber into the same state as if it was just
created by child fiber reconciliation"
45,MDY6Q29tbWl0MTAyNzAyNTA6MGYzMzQ1NTNjOTU1OGE1NjAzN2I0ODFmZWRjOWI5ZmNhZDM2NDNlNw==,Sebastian Markbåge,GitHub,"Reset stateNode in resetWorkInProgress (#18448)

* test(SuspenseList): Add failing test for class component

* Reset stateNode when resetWorkInProgress

This is supposed to put the Fiber into the same state as if it was just
created by child fiber reconciliation. For newly created fibers, that means
that stateNode is null.

Co-authored-by: Sebastian Silbermann <silbermann.sebastian@gmail.com>",https://api.github.com/repos/facebook/react/git/commits/0f334553c9558a56037b481fedc9b9fcad3643e7,2020-04-01,"For newly created fibers, that means
that stateNode is null"
45,MDY6Q29tbWl0MTAyNzAyNTA6MGYzMzQ1NTNjOTU1OGE1NjAzN2I0ODFmZWRjOWI5ZmNhZDM2NDNlNw==,Sebastian Markbåge,GitHub,"Reset stateNode in resetWorkInProgress (#18448)

* test(SuspenseList): Add failing test for class component

* Reset stateNode when resetWorkInProgress

This is supposed to put the Fiber into the same state as if it was just
created by child fiber reconciliation. For newly created fibers, that means
that stateNode is null.

Co-authored-by: Sebastian Silbermann <silbermann.sebastian@gmail.com>",https://api.github.com/repos/facebook/react/git/commits/0f334553c9558a56037b481fedc9b9fcad3643e7,2020-04-01,"
Co-authored-by: Sebastian Silbermann <silbermann.sebastian@gmail.com>"
46,MDY6Q29tbWl0MTAyNzAyNTA6YmYzMGUzNzBhNTAzY2M1Nzg3YTBiMjBlOWQ1MGVjZTZhMTQ4ZDZjOQ==,Dan Abramov,GitHub,Remove User Timings (#18417),https://api.github.com/repos/facebook/react/git/commits/bf30e370a503cc5787a0b20e9d50ece6a148d6c9,2020-03-30,Remove User Timings (#18417)
46,MDY6Q29tbWl0MTAyNzAyNTA6YmYzMGUzNzBhNTAzY2M1Nzg3YTBiMjBlOWQ1MGVjZTZhMTQ4ZDZjOQ==,Dan Abramov,GitHub,Remove User Timings (#18417),https://api.github.com/repos/facebook/react/git/commits/bf30e370a503cc5787a0b20e9d50ece6a148d6c9,2020-03-30,
47,MDY6Q29tbWl0MTAyNzAyNTA6MzFhOWUzOTFmNzU3ZDM3NGNlMDA2NWRhNjczNWYwODEzNzE1MTUwNw==,Mohammad Aziz,GitHub,Remove unnecessary lines for `hasBadMapPolyfill` issue for rollup (#16231),https://api.github.com/repos/facebook/react/git/commits/31a9e391f757d374ce0065da6735f08137151507,2020-03-22,Remove unnecessary lines for `hasBadMapPolyfill` issue for rollup (#16231)
47,MDY6Q29tbWl0MTAyNzAyNTA6MzFhOWUzOTFmNzU3ZDM3NGNlMDA2NWRhNjczNWYwODEzNzE1MTUwNw==,Mohammad Aziz,GitHub,Remove unnecessary lines for `hasBadMapPolyfill` issue for rollup (#16231),https://api.github.com/repos/facebook/react/git/commits/31a9e391f757d374ce0065da6735f08137151507,2020-03-22,
48,MDY6Q29tbWl0MTAyNzAyNTA6YzVkMmZjNzEyNzY1NGU0M2RlNTlmZmY4NjViNzQ3NjVhMTAzYzRhNQ==,Sebastian Markbåge,GitHub,"Move some files out of /shared and rename to upper case (#18363)

* Rename lower case isomorphic default exports modules to upper case named exports

We're somewhat inconsistent here between e.g. ReactLazy and memo.

Let's pick one.

This also moves the responder, fundamental, scope creators from shared
since they're isomorphic and same as the other creators.

* Move some files that are specific to the react-reconciler from shared

Individual renderers are allowed to deep require into the reconciler.

* Move files specific to react-dom from shared

react-interactions is right now dom specific (it wasn't before) so we can
type check it together with other dom stuff. Avoids the need for
a shared ReactDOMTypes to be checked by RN for example.

* Move ReactWorkTags to the reconciler

* Move createPortal to export from reconciler

Otherwise Noop can't access it since it's not allowed deep requires.",https://api.github.com/repos/facebook/react/git/commits/c5d2fc7127654e43de59fff865b74765a103c4a5,2020-03-21,Move some files out of /shared and rename to upper case (#18363)
48,MDY6Q29tbWl0MTAyNzAyNTA6YzVkMmZjNzEyNzY1NGU0M2RlNTlmZmY4NjViNzQ3NjVhMTAzYzRhNQ==,Sebastian Markbåge,GitHub,"Move some files out of /shared and rename to upper case (#18363)

* Rename lower case isomorphic default exports modules to upper case named exports

We're somewhat inconsistent here between e.g. ReactLazy and memo.

Let's pick one.

This also moves the responder, fundamental, scope creators from shared
since they're isomorphic and same as the other creators.

* Move some files that are specific to the react-reconciler from shared

Individual renderers are allowed to deep require into the reconciler.

* Move files specific to react-dom from shared

react-interactions is right now dom specific (it wasn't before) so we can
type check it together with other dom stuff. Avoids the need for
a shared ReactDOMTypes to be checked by RN for example.

* Move ReactWorkTags to the reconciler

* Move createPortal to export from reconciler

Otherwise Noop can't access it since it's not allowed deep requires.",https://api.github.com/repos/facebook/react/git/commits/c5d2fc7127654e43de59fff865b74765a103c4a5,2020-03-21,We're somewhat inconsistent here between e.g
48,MDY6Q29tbWl0MTAyNzAyNTA6YzVkMmZjNzEyNzY1NGU0M2RlNTlmZmY4NjViNzQ3NjVhMTAzYzRhNQ==,Sebastian Markbåge,GitHub,"Move some files out of /shared and rename to upper case (#18363)

* Rename lower case isomorphic default exports modules to upper case named exports

We're somewhat inconsistent here between e.g. ReactLazy and memo.

Let's pick one.

This also moves the responder, fundamental, scope creators from shared
since they're isomorphic and same as the other creators.

* Move some files that are specific to the react-reconciler from shared

Individual renderers are allowed to deep require into the reconciler.

* Move files specific to react-dom from shared

react-interactions is right now dom specific (it wasn't before) so we can
type check it together with other dom stuff. Avoids the need for
a shared ReactDOMTypes to be checked by RN for example.

* Move ReactWorkTags to the reconciler

* Move createPortal to export from reconciler

Otherwise Noop can't access it since it's not allowed deep requires.",https://api.github.com/repos/facebook/react/git/commits/c5d2fc7127654e43de59fff865b74765a103c4a5,2020-03-21,ReactLazy and memo
48,MDY6Q29tbWl0MTAyNzAyNTA6YzVkMmZjNzEyNzY1NGU0M2RlNTlmZmY4NjViNzQ3NjVhMTAzYzRhNQ==,Sebastian Markbåge,GitHub,"Move some files out of /shared and rename to upper case (#18363)

* Rename lower case isomorphic default exports modules to upper case named exports

We're somewhat inconsistent here between e.g. ReactLazy and memo.

Let's pick one.

This also moves the responder, fundamental, scope creators from shared
since they're isomorphic and same as the other creators.

* Move some files that are specific to the react-reconciler from shared

Individual renderers are allowed to deep require into the reconciler.

* Move files specific to react-dom from shared

react-interactions is right now dom specific (it wasn't before) so we can
type check it together with other dom stuff. Avoids the need for
a shared ReactDOMTypes to be checked by RN for example.

* Move ReactWorkTags to the reconciler

* Move createPortal to export from reconciler

Otherwise Noop can't access it since it's not allowed deep requires.",https://api.github.com/repos/facebook/react/git/commits/c5d2fc7127654e43de59fff865b74765a103c4a5,2020-03-21,"
Let's pick one"
48,MDY6Q29tbWl0MTAyNzAyNTA6YzVkMmZjNzEyNzY1NGU0M2RlNTlmZmY4NjViNzQ3NjVhMTAzYzRhNQ==,Sebastian Markbåge,GitHub,"Move some files out of /shared and rename to upper case (#18363)

* Rename lower case isomorphic default exports modules to upper case named exports

We're somewhat inconsistent here between e.g. ReactLazy and memo.

Let's pick one.

This also moves the responder, fundamental, scope creators from shared
since they're isomorphic and same as the other creators.

* Move some files that are specific to the react-reconciler from shared

Individual renderers are allowed to deep require into the reconciler.

* Move files specific to react-dom from shared

react-interactions is right now dom specific (it wasn't before) so we can
type check it together with other dom stuff. Avoids the need for
a shared ReactDOMTypes to be checked by RN for example.

* Move ReactWorkTags to the reconciler

* Move createPortal to export from reconciler

Otherwise Noop can't access it since it's not allowed deep requires.",https://api.github.com/repos/facebook/react/git/commits/c5d2fc7127654e43de59fff865b74765a103c4a5,2020-03-21,"
This also moves the responder, fundamental, scope creators from shared
since they're isomorphic and same as the other creators"
48,MDY6Q29tbWl0MTAyNzAyNTA6YzVkMmZjNzEyNzY1NGU0M2RlNTlmZmY4NjViNzQ3NjVhMTAzYzRhNQ==,Sebastian Markbåge,GitHub,"Move some files out of /shared and rename to upper case (#18363)

* Rename lower case isomorphic default exports modules to upper case named exports

We're somewhat inconsistent here between e.g. ReactLazy and memo.

Let's pick one.

This also moves the responder, fundamental, scope creators from shared
since they're isomorphic and same as the other creators.

* Move some files that are specific to the react-reconciler from shared

Individual renderers are allowed to deep require into the reconciler.

* Move files specific to react-dom from shared

react-interactions is right now dom specific (it wasn't before) so we can
type check it together with other dom stuff. Avoids the need for
a shared ReactDOMTypes to be checked by RN for example.

* Move ReactWorkTags to the reconciler

* Move createPortal to export from reconciler

Otherwise Noop can't access it since it's not allowed deep requires.",https://api.github.com/repos/facebook/react/git/commits/c5d2fc7127654e43de59fff865b74765a103c4a5,2020-03-21,"
Individual renderers are allowed to deep require into the reconciler"
48,MDY6Q29tbWl0MTAyNzAyNTA6YzVkMmZjNzEyNzY1NGU0M2RlNTlmZmY4NjViNzQ3NjVhMTAzYzRhNQ==,Sebastian Markbåge,GitHub,"Move some files out of /shared and rename to upper case (#18363)

* Rename lower case isomorphic default exports modules to upper case named exports

We're somewhat inconsistent here between e.g. ReactLazy and memo.

Let's pick one.

This also moves the responder, fundamental, scope creators from shared
since they're isomorphic and same as the other creators.

* Move some files that are specific to the react-reconciler from shared

Individual renderers are allowed to deep require into the reconciler.

* Move files specific to react-dom from shared

react-interactions is right now dom specific (it wasn't before) so we can
type check it together with other dom stuff. Avoids the need for
a shared ReactDOMTypes to be checked by RN for example.

* Move ReactWorkTags to the reconciler

* Move createPortal to export from reconciler

Otherwise Noop can't access it since it's not allowed deep requires.",https://api.github.com/repos/facebook/react/git/commits/c5d2fc7127654e43de59fff865b74765a103c4a5,2020-03-21,"
react-interactions is right now dom specific (it wasn't before) so we can
type check it together with other dom stuff"
48,MDY6Q29tbWl0MTAyNzAyNTA6YzVkMmZjNzEyNzY1NGU0M2RlNTlmZmY4NjViNzQ3NjVhMTAzYzRhNQ==,Sebastian Markbåge,GitHub,"Move some files out of /shared and rename to upper case (#18363)

* Rename lower case isomorphic default exports modules to upper case named exports

We're somewhat inconsistent here between e.g. ReactLazy and memo.

Let's pick one.

This also moves the responder, fundamental, scope creators from shared
since they're isomorphic and same as the other creators.

* Move some files that are specific to the react-reconciler from shared

Individual renderers are allowed to deep require into the reconciler.

* Move files specific to react-dom from shared

react-interactions is right now dom specific (it wasn't before) so we can
type check it together with other dom stuff. Avoids the need for
a shared ReactDOMTypes to be checked by RN for example.

* Move ReactWorkTags to the reconciler

* Move createPortal to export from reconciler

Otherwise Noop can't access it since it's not allowed deep requires.",https://api.github.com/repos/facebook/react/git/commits/c5d2fc7127654e43de59fff865b74765a103c4a5,2020-03-21,"Avoids the need for
a shared ReactDOMTypes to be checked by RN for example"
48,MDY6Q29tbWl0MTAyNzAyNTA6YzVkMmZjNzEyNzY1NGU0M2RlNTlmZmY4NjViNzQ3NjVhMTAzYzRhNQ==,Sebastian Markbåge,GitHub,"Move some files out of /shared and rename to upper case (#18363)

* Rename lower case isomorphic default exports modules to upper case named exports

We're somewhat inconsistent here between e.g. ReactLazy and memo.

Let's pick one.

This also moves the responder, fundamental, scope creators from shared
since they're isomorphic and same as the other creators.

* Move some files that are specific to the react-reconciler from shared

Individual renderers are allowed to deep require into the reconciler.

* Move files specific to react-dom from shared

react-interactions is right now dom specific (it wasn't before) so we can
type check it together with other dom stuff. Avoids the need for
a shared ReactDOMTypes to be checked by RN for example.

* Move ReactWorkTags to the reconciler

* Move createPortal to export from reconciler

Otherwise Noop can't access it since it's not allowed deep requires.",https://api.github.com/repos/facebook/react/git/commits/c5d2fc7127654e43de59fff865b74765a103c4a5,2020-03-21,"
Otherwise Noop can't access it since it's not allowed deep requires."
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,Add test run that uses www feature flags (#18234)
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"In CI, we run our test suite against multiple build configurations"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"This is to prevent accidental
deviations in behavior between the different builds"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"If there's an
intentional deviation in behavior, the test author must account
for them"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
However, we currently don't run tests against the www builds"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"There are a few downsides to this
approach, though"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"The flag is only overridden for the specific tests or
test suites where you apply the override"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"I've added a new
command, `yarn test-www`"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,It automatically runs in CI
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,a GK)
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"These flags are imported from an
external module that lives in www"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"`__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"We generally assume that
flags can be toggled independently, so in practice this should
be enough"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
You can also refer to `__VARIANT__` in tests to detect which mode you're
running in"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"However, we should stop mutating that
module going forward"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,Treat it as read-only
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
In this commit, I have only setup the www tests to run against source"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
I'll leave running against build for a follow up"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"
Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,"Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values"
49,MDY6Q29tbWl0MTAyNzAyNTA6MTE1Y2QxMmQ5YmJiMmJmZjMwM2U1MmZlYjEzOTRlM2EyY2VmMjBjYQ==,Andrew Clark,GitHub,"Add test run that uses www feature flags (#18234)

In CI, we run our test suite against multiple build configurations. For
example, we run our tests in both dev and prod, and in both the
experimental and stable release channels. This is to prevent accidental
deviations in behavior between the different builds. If there's an
intentional deviation in behavior, the test author must account
for them.

However, we currently don't run tests against the www builds. That's
a problem, because it's common for features to land in www before they
land anywhere else, including the experimental release channel.
Typically we do this so we can gradually roll out the feature behind
a flag before deciding to enable it.

The way we test those features today is by mutating the
`shared/ReactFeatureFlags` module. There are a few downsides to this
approach, though. The flag is only overridden for the specific tests or
test suites where you apply the override. But usually what you want is
to run *all* tests with the flag enabled, to protect against unexpected
regressions.

Also, mutating the feature flags module only works when running the
tests against source, not against the final build artifacts, because the
ReactFeatureFlags module is inlined by the build script.

Instead, we should run the test suite against the www configuration,
just like we do for prod, experimental, and so on. I've added a new
command, `yarn test-www`. It automatically runs in CI.

Some of the www feature flags are dynamic; that is, they depend on
a runtime condition (i.e. a GK). These flags are imported from an
external module that lives in www. Those flags will be enabled for some
clients and disabled for others, so we should run the tests against
*both* modes.

So I've added a new global `__VARIANT__`, and a new test command `yarn
test-www-variant`. `__VARIANT__` is set to false by default; when
running `test-www-variant`, it's set to true.

If we were going for *really* comprehensive coverage, we would run the
tests against every possible configuration of feature flags: 2 ^
numberOfFlags total combinations. That's not practical, though, so
instead we only run against two combinations: once with `__VARIANT__`
set to `true`, and once with it set to `false`. We generally assume that
flags can be toggled independently, so in practice this should
be enough.

You can also refer to `__VARIANT__` in tests to detect which mode you're
running in. Or, you can import `shared/ReactFeatureFlags` and read the
specific flag you can about. However, we should stop mutating that
module going forward. Treat it as read-only.

In this commit, I have only setup the www tests to run against source.
I'll leave running against build for a follow up.

Many of our tests currently assume they run only in the default
configuration, and break when certain flags are toggled. Rather than fix
these all up front, I've hard-coded the relevant flags to the default
values. We can incrementally migrate those tests later.",https://api.github.com/repos/facebook/react/git/commits/115cd12d9bbb2bff303e52feb1394e3a2cef20ca,2020-03-06,We can incrementally migrate those tests later.
50,MDY6Q29tbWl0MTAyNzAyNTA6MDI0YTc2NDMxMGU2NGVmMzg5NjNkZjE2OTcwMzY0Yjk5NDJhNjBjZA==,Brian Vaughn,GitHub,"Implemented Profiler onCommit() and onPostCommit() hooks (#17910)

* Implemented Profiler onCommit() and onPostCommit() hooks
* Added enableProfilerCommitHooks feature flag for commit hooks
* Moved onCommit and onPassiveCommit behind separate feature flag",https://api.github.com/repos/facebook/react/git/commits/024a764310e64ef38963df16970364b9942a60cd,2020-03-05,Implemented Profiler onCommit() and onPostCommit() hooks (#17910)
50,MDY6Q29tbWl0MTAyNzAyNTA6MDI0YTc2NDMxMGU2NGVmMzg5NjNkZjE2OTcwMzY0Yjk5NDJhNjBjZA==,Brian Vaughn,GitHub,"Implemented Profiler onCommit() and onPostCommit() hooks (#17910)

* Implemented Profiler onCommit() and onPostCommit() hooks
* Added enableProfilerCommitHooks feature flag for commit hooks
* Moved onCommit and onPassiveCommit behind separate feature flag",https://api.github.com/repos/facebook/react/git/commits/024a764310e64ef38963df16970364b9942a60cd,2020-03-05,
51,MDY6Q29tbWl0MTAyNzAyNTA6NGVlNTkyZTk1YTVmNzhkYWVkNTc1YTA0N2Q0N2Y3NGYwNDY5NDBmMw==,Dan Abramov,GitHub,Add an early invariant to debug a mystery crash (#18159),https://api.github.com/repos/facebook/react/git/commits/4ee592e95a5f78daed575a047d47f74f046940f3,2020-02-28,Add an early invariant to debug a mystery crash (#18159)
51,MDY6Q29tbWl0MTAyNzAyNTA6NGVlNTkyZTk1YTVmNzhkYWVkNTc1YTA0N2Q0N2Y3NGYwNDY5NDBmMw==,Dan Abramov,GitHub,Add an early invariant to debug a mystery crash (#18159),https://api.github.com/repos/facebook/react/git/commits/4ee592e95a5f78daed575a047d47f74f046940f3,2020-02-28,
52,MDY6Q29tbWl0MTAyNzAyNTA6NjViYmRhN2YxNjkzOTQwMDUyNTJiNDZhNTk5MmVjZTVhMmZmYWRhZA==,Sebastian Markbåge,GitHub,"Rename Chunks API to Blocks (#18086)

Sounds like this is the name we're going with. This also helps us
distinguish it from other ""chunking"" implementation details.",https://api.github.com/repos/facebook/react/git/commits/65bbda7f169394005252b46a5992ece5a2ffadad,2020-02-21,Rename Chunks API to Blocks (#18086)
52,MDY6Q29tbWl0MTAyNzAyNTA6NjViYmRhN2YxNjkzOTQwMDUyNTJiNDZhNTk5MmVjZTVhMmZmYWRhZA==,Sebastian Markbåge,GitHub,"Rename Chunks API to Blocks (#18086)

Sounds like this is the name we're going with. This also helps us
distinguish it from other ""chunking"" implementation details.",https://api.github.com/repos/facebook/react/git/commits/65bbda7f169394005252b46a5992ece5a2ffadad,2020-02-21,Sounds like this is the name we're going with
52,MDY6Q29tbWl0MTAyNzAyNTA6NjViYmRhN2YxNjkzOTQwMDUyNTJiNDZhNTk5MmVjZTVhMmZmYWRhZA==,Sebastian Markbåge,GitHub,"Rename Chunks API to Blocks (#18086)

Sounds like this is the name we're going with. This also helps us
distinguish it from other ""chunking"" implementation details.",https://api.github.com/repos/facebook/react/git/commits/65bbda7f169394005252b46a5992ece5a2ffadad,2020-02-21,"This also helps us
distinguish it from other ""chunking"" implementation details."
53,MDY6Q29tbWl0MTAyNzAyNTA6OGI1OTZlMDBhNGZmZmQ2YmI1ZTY5OTBmNGRkNTllNDBlODBhNWVhMA==,Dan Abramov,GitHub,Remove unused arguments in the reconciler (#18092),https://api.github.com/repos/facebook/react/git/commits/8b596e00a4fffd6bb5e6990f4dd59e40e80a5ea0,2020-02-21,Remove unused arguments in the reconciler (#18092)
53,MDY6Q29tbWl0MTAyNzAyNTA6OGI1OTZlMDBhNGZmZmQ2YmI1ZTY5OTBmNGRkNTllNDBlODBhNWVhMA==,Dan Abramov,GitHub,Remove unused arguments in the reconciler (#18092),https://api.github.com/repos/facebook/react/git/commits/8b596e00a4fffd6bb5e6990f4dd59e40e80a5ea0,2020-02-21,
54,MDY6Q29tbWl0MTAyNzAyNTA6ODc3N2I0NGU5ODJlN2RkZWRkYTYyYWVlMDJmMWZkMzcwNzk1ZGI0NA==,Dan Abramov,GitHub,"Add Modern WWW build (#18028)

* Build both stable and experimental WWW builds

* Flip already experimental WWW flags to true

* Remove FB-specific internals from modern FB builds

We think we're not going to need these.

* Disable classic features in modern WWW builds

* Disable legacy ReactDOM API for modern WWW build

* Don’t include user timing in prod

* Fix bad copy paste and add missing flags to test renderer

* Add testing WWW feature flag file

We need it because WWW has a different meaning of experimental now.",https://api.github.com/repos/facebook/react/git/commits/8777b44e982e7ddedda62aee02f1fd370795db44,2020-02-13,Add Modern WWW build (#18028)
54,MDY6Q29tbWl0MTAyNzAyNTA6ODc3N2I0NGU5ODJlN2RkZWRkYTYyYWVlMDJmMWZkMzcwNzk1ZGI0NA==,Dan Abramov,GitHub,"Add Modern WWW build (#18028)

* Build both stable and experimental WWW builds

* Flip already experimental WWW flags to true

* Remove FB-specific internals from modern FB builds

We think we're not going to need these.

* Disable classic features in modern WWW builds

* Disable legacy ReactDOM API for modern WWW build

* Don’t include user timing in prod

* Fix bad copy paste and add missing flags to test renderer

* Add testing WWW feature flag file

We need it because WWW has a different meaning of experimental now.",https://api.github.com/repos/facebook/react/git/commits/8777b44e982e7ddedda62aee02f1fd370795db44,2020-02-13,We think we're not going to need these
54,MDY6Q29tbWl0MTAyNzAyNTA6ODc3N2I0NGU5ODJlN2RkZWRkYTYyYWVlMDJmMWZkMzcwNzk1ZGI0NA==,Dan Abramov,GitHub,"Add Modern WWW build (#18028)

* Build both stable and experimental WWW builds

* Flip already experimental WWW flags to true

* Remove FB-specific internals from modern FB builds

We think we're not going to need these.

* Disable classic features in modern WWW builds

* Disable legacy ReactDOM API for modern WWW build

* Don’t include user timing in prod

* Fix bad copy paste and add missing flags to test renderer

* Add testing WWW feature flag file

We need it because WWW has a different meaning of experimental now.",https://api.github.com/repos/facebook/react/git/commits/8777b44e982e7ddedda62aee02f1fd370795db44,2020-02-13,"
We need it because WWW has a different meaning of experimental now."
55,MDY6Q29tbWl0MTAyNzAyNTA6ZTcwNjcyMTQ5MGU1MGQwYmQ2YWYyY2Q5MzNkYmY4NTdmZDhiNjFlZA==,Dan Abramov,GitHub,"Update Flow to 0.84 (#17805)

* Update Flow to 0.84

* Fix violations

* Use inexact object syntax in files from fbsource

* Fix warning extraction to use a modern parser

* Codemod inexact objects to new syntax

* Tighten types that can be exact

* Revert unintentional formatting changes from codemod",https://api.github.com/repos/facebook/react/git/commits/e706721490e50d0bd6af2cd933dbf857fd8b61ed,2020-01-09,Update Flow to 0.84 (#17805)
55,MDY6Q29tbWl0MTAyNzAyNTA6ZTcwNjcyMTQ5MGU1MGQwYmQ2YWYyY2Q5MzNkYmY4NTdmZDhiNjFlZA==,Dan Abramov,GitHub,"Update Flow to 0.84 (#17805)

* Update Flow to 0.84

* Fix violations

* Use inexact object syntax in files from fbsource

* Fix warning extraction to use a modern parser

* Codemod inexact objects to new syntax

* Tighten types that can be exact

* Revert unintentional formatting changes from codemod",https://api.github.com/repos/facebook/react/git/commits/e706721490e50d0bd6af2cd933dbf857fd8b61ed,2020-01-09,
56,MDY6Q29tbWl0MTAyNzAyNTA6N2RjOTc0NTQyNzA0NmQ0NjI1MDZlOTc4ODg3OGJhMzg5ZTE3NmI4YQ==,Sebastian Markbåge,GitHub,"[Flight] Chunks API (#17398)

* Add feature flags

* Add Chunk type and constructor

* Wire up Chunk support in the reconciler

* Update reconciler to reconcile Chunks against the render method

This allows the query and args to be updated.

* Drop the ref. Chunks cannot have refs anyway.

* Add Chunk checks in more missing cases

* Rename secondArg

* Add test and fix lazy chunks

Not really a supported use case but for consistency I guess.

* Fix fragment test",https://api.github.com/repos/facebook/react/git/commits/7dc9745427046d462506e9788878ba389e176b8a,2019-12-18,[Flight] Chunks API (#17398)
56,MDY6Q29tbWl0MTAyNzAyNTA6N2RjOTc0NTQyNzA0NmQ0NjI1MDZlOTc4ODg3OGJhMzg5ZTE3NmI4YQ==,Sebastian Markbåge,GitHub,"[Flight] Chunks API (#17398)

* Add feature flags

* Add Chunk type and constructor

* Wire up Chunk support in the reconciler

* Update reconciler to reconcile Chunks against the render method

This allows the query and args to be updated.

* Drop the ref. Chunks cannot have refs anyway.

* Add Chunk checks in more missing cases

* Rename secondArg

* Add test and fix lazy chunks

Not really a supported use case but for consistency I guess.

* Fix fragment test",https://api.github.com/repos/facebook/react/git/commits/7dc9745427046d462506e9788878ba389e176b8a,2019-12-18,This allows the query and args to be updated
56,MDY6Q29tbWl0MTAyNzAyNTA6N2RjOTc0NTQyNzA0NmQ0NjI1MDZlOTc4ODg3OGJhMzg5ZTE3NmI4YQ==,Sebastian Markbåge,GitHub,"[Flight] Chunks API (#17398)

* Add feature flags

* Add Chunk type and constructor

* Wire up Chunk support in the reconciler

* Update reconciler to reconcile Chunks against the render method

This allows the query and args to be updated.

* Drop the ref. Chunks cannot have refs anyway.

* Add Chunk checks in more missing cases

* Rename secondArg

* Add test and fix lazy chunks

Not really a supported use case but for consistency I guess.

* Fix fragment test",https://api.github.com/repos/facebook/react/git/commits/7dc9745427046d462506e9788878ba389e176b8a,2019-12-18,"
Not really a supported use case but for consistency I guess"
56,MDY6Q29tbWl0MTAyNzAyNTA6N2RjOTc0NTQyNzA0NmQ0NjI1MDZlOTc4ODg3OGJhMzg5ZTE3NmI4YQ==,Sebastian Markbåge,GitHub,"[Flight] Chunks API (#17398)

* Add feature flags

* Add Chunk type and constructor

* Wire up Chunk support in the reconciler

* Update reconciler to reconcile Chunks against the render method

This allows the query and args to be updated.

* Drop the ref. Chunks cannot have refs anyway.

* Add Chunk checks in more missing cases

* Rename secondArg

* Add test and fix lazy chunks

Not really a supported use case but for consistency I guess.

* Fix fragment test",https://api.github.com/repos/facebook/react/git/commits/7dc9745427046d462506e9788878ba389e176b8a,2019-12-18,
57,MDY6Q29tbWl0MTAyNzAyNTA6MGNmMjJhNTZhMTg3OTBlZjM0YzcxYmVmMTRmNjQ2OTVjMDQ5ODYxOQ==,Dan Abramov,GitHub,"Use console directly instead of warning() modules (#17599)

* Replace all warning/lowPriWarning with console calls

* Replace console.warn/error with a custom wrapper at build time

* Fail the build for console.error/warn() where we can't read the stack",https://api.github.com/repos/facebook/react/git/commits/0cf22a56a18790ef34c71bef14f64695c0498619,2019-12-14,Use console directly instead of warning() modules (#17599)
57,MDY6Q29tbWl0MTAyNzAyNTA6MGNmMjJhNTZhMTg3OTBlZjM0YzcxYmVmMTRmNjQ2OTVjMDQ5ODYxOQ==,Dan Abramov,GitHub,"Use console directly instead of warning() modules (#17599)

* Replace all warning/lowPriWarning with console calls

* Replace console.warn/error with a custom wrapper at build time

* Fail the build for console.error/warn() where we can't read the stack",https://api.github.com/repos/facebook/react/git/commits/0cf22a56a18790ef34c71bef14f64695c0498619,2019-12-14,
58,MDY6Q29tbWl0MTAyNzAyNTA6YjE1YmYzNjc1MGNhNGM0YTVhMDlmMmRlNzZjNTMxNWRlZDEyNThkMA==,Dan Abramov,GitHub,Add component stacks to (almost) all warnings (#17586),https://api.github.com/repos/facebook/react/git/commits/b15bf36750ca4c4a5a09f2de76c5315ded1258d0,2019-12-12,Add component stacks to (almost) all warnings (#17586)
58,MDY6Q29tbWl0MTAyNzAyNTA6YjE1YmYzNjc1MGNhNGM0YTVhMDlmMmRlNzZjNTMxNWRlZDEyNThkMA==,Dan Abramov,GitHub,Add component stacks to (almost) all warnings (#17586),https://api.github.com/repos/facebook/react/git/commits/b15bf36750ca4c4a5a09f2de76c5315ded1258d0,2019-12-12,
59,MDY6Q29tbWl0MTAyNzAyNTA6OWFjNDJkZDA3NGM0MmI2NmVjYzAzMzRiNzUyMDBiMWQyOTg5Zjg5Mg==,Laura buns,Dan Abramov,"Remove the condition argument from warning() (#17568)

* prep for codemod

* prep warnings

* rename lint rules

* codemod for ifs

* shim www functions

* Handle more cases in the transform

* Thanks De Morgan

* Run the codemod

* Delete the transform

* Fix up confusing conditions manually

* Fix up www shims to match expected API

* Also check for low-pri warning in the lint rule",https://api.github.com/repos/facebook/react/git/commits/9ac42dd074c42b66ecc0334b75200b1d2989f892,2019-12-11,Remove the condition argument from warning() (#17568)
59,MDY6Q29tbWl0MTAyNzAyNTA6OWFjNDJkZDA3NGM0MmI2NmVjYzAzMzRiNzUyMDBiMWQyOTg5Zjg5Mg==,Laura buns,Dan Abramov,"Remove the condition argument from warning() (#17568)

* prep for codemod

* prep warnings

* rename lint rules

* codemod for ifs

* shim www functions

* Handle more cases in the transform

* Thanks De Morgan

* Run the codemod

* Delete the transform

* Fix up confusing conditions manually

* Fix up www shims to match expected API

* Also check for low-pri warning in the lint rule",https://api.github.com/repos/facebook/react/git/commits/9ac42dd074c42b66ecc0334b75200b1d2989f892,2019-12-11,
60,MDY6Q29tbWl0MTAyNzAyNTA6YjhmODI1ODc3NTIxMWQyZDNiMWIxNDRjYzZjNzUxNDhlY2Q0YjhkOA==,Dan Abramov,GitHub,"Split ReactDOM entry point (#17331)

* Split ReactDOM entry point

* BatchedRoot -> BlockingRoot",https://api.github.com/repos/facebook/react/git/commits/b8f8258775211d2d3b1b144cc6c75148ecd4b8d8,2019-11-10,Split ReactDOM entry point (#17331)
60,MDY6Q29tbWl0MTAyNzAyNTA6YjhmODI1ODc3NTIxMWQyZDNiMWIxNDRjYzZjNzUxNDhlY2Q0YjhkOA==,Dan Abramov,GitHub,"Split ReactDOM entry point (#17331)

* Split ReactDOM entry point

* BatchedRoot -> BlockingRoot",https://api.github.com/repos/facebook/react/git/commits/b8f8258775211d2d3b1b144cc6c75148ecd4b8d8,2019-11-10,
61,MDY6Q29tbWl0MTAyNzAyNTA6ZjZiOGQzMWE3NmNiYmNiYmViMmYxZDU5MDc0ZGZlNzJlMGM4MjgwNg==,Dan Abramov,GitHub,"Rename createSyncRoot to createBlockingRoot (#17165)

* Rename createSyncRoot to createBlockingRoot

* Fix up",https://api.github.com/repos/facebook/react/git/commits/f6b8d31a76cbbcbbeb2f1d59074dfe72e0c82806,2019-10-23,Rename createSyncRoot to createBlockingRoot (#17165)
61,MDY6Q29tbWl0MTAyNzAyNTA6ZjZiOGQzMWE3NmNiYmNiYmViMmYxZDU5MDc0ZGZlNzJlMGM4MjgwNg==,Dan Abramov,GitHub,"Rename createSyncRoot to createBlockingRoot (#17165)

* Rename createSyncRoot to createBlockingRoot

* Fix up",https://api.github.com/repos/facebook/react/git/commits/f6b8d31a76cbbcbbeb2f1d59074dfe72e0c82806,2019-10-23,
62,MDY6Q29tbWl0MTAyNzAyNTA6NzA3NTRmMTBkNDExOWE5OTlhYzlhNDZiNmVhOGMxMWExMmExYTcyZA==,Dominic Gannaway,GitHub,[react-interaction] Tweak Focus Table component (#16862),https://api.github.com/repos/facebook/react/git/commits/70754f10d4119a999ac9a46b6ea8c11a12a1a72d,2019-09-23,[react-interaction] Tweak Focus Table component (#16862)
62,MDY6Q29tbWl0MTAyNzAyNTA6NzA3NTRmMTBkNDExOWE5OTlhYzlhNDZiNmVhOGMxMWExMmExYTcyZA==,Dominic Gannaway,GitHub,[react-interaction] Tweak Focus Table component (#16862),https://api.github.com/repos/facebook/react/git/commits/70754f10d4119a999ac9a46b6ea8c11a12a1a72d,2019-09-23,
63,MDY6Q29tbWl0MTAyNzAyNTA6YmQ3OWJlOWI2ODcxNTYwNjc0MTZmZmU1MjE5ZTQ5YTExYmQwZjFlNw==,Dominic Gannaway,GitHub,[react-core] Add experimental React Scope component API (#16587),https://api.github.com/repos/facebook/react/git/commits/bd79be9b687156067416ffe5219e49a11bd0f1e7,2019-08-29,[react-core] Add experimental React Scope component API (#16587)
63,MDY6Q29tbWl0MTAyNzAyNTA6YmQ3OWJlOWI2ODcxNTYwNjc0MTZmZmU1MjE5ZTQ5YTExYmQwZjFlNw==,Dominic Gannaway,GitHub,[react-core] Add experimental React Scope component API (#16587),https://api.github.com/repos/facebook/react/git/commits/bd79be9b687156067416ffe5219e49a11bd0f1e7,2019-08-29,
64,MDY6Q29tbWl0MTAyNzAyNTA6MWZkMzkwNmU5MmVhMjMxODQ4YzViNTBhOTkzMDNkNGFjM2RjNzk3Nw==,Dan Abramov,GitHub,"Remove ""Waiting for async callback"" User Timing measurement (#16379)

* Remove ""Waiting for async callback"" User Timing measurement

* Fix User Timing in PROD mode",https://api.github.com/repos/facebook/react/git/commits/1fd3906e92ea231848c5b50a99303d4ac3dc7977,2019-08-13,"Remove ""Waiting for async callback"" User Timing measurement (#16379)"
64,MDY6Q29tbWl0MTAyNzAyNTA6MWZkMzkwNmU5MmVhMjMxODQ4YzViNTBhOTkzMDNkNGFjM2RjNzk3Nw==,Dan Abramov,GitHub,"Remove ""Waiting for async callback"" User Timing measurement (#16379)

* Remove ""Waiting for async callback"" User Timing measurement

* Fix User Timing in PROD mode",https://api.github.com/repos/facebook/react/git/commits/1fd3906e92ea231848c5b50a99303d4ac3dc7977,2019-08-13,
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,Refactor Partial Hydration (#16346)
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
Forked based on SuspenseState.dehydrated instead"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
We can now simplify the logic for retrying dehydrated boundaries without
hydrating"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
Instead we use the regular Suspense path"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"To save code, we attach retry
listeners in the commit phase even though technically we don't have to"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
I think this is right...?
The DidCapture flag isn't used consistently in the same way"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"We need
further refactor for this"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,Since there is no fragment child etc
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
However, we must readd the deletion"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
It does a two pass render that client renders the content"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
This now doesn't represent a suspense boundary itself"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,Its parent does
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
This Fiber represents the fragment around the dehydrated content"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
Avoids the temporary mutable variables"
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,I kept losing track of them
65,MDY6Q29tbWl0MTAyNzAyNTA6NTBhZGRmNGMwZTQxMWUzNTFkZTcyOTBjOGM2MGVjNzc1YzI1YzhjNA==,Sebastian Markbåge,GitHub,"Refactor Partial Hydration (#16346)

* Move dehydrated to be child of regular SuspenseComponent

We now store the comment node on SuspenseState instead and that indicates
that this SuspenseComponent is still dehydrated.

We also store a child but that is only used to represent the DOM node for
deletions and getNextHostSibling.

* Move logic from DehydratedSuspenseComponent to SuspenseComponent

Forked based on SuspenseState.dehydrated instead.

* Retry logic for dehydrated boundary

We can now simplify the logic for retrying dehydrated boundaries without
hydrating. This is becomes simply a reconciliation against the dehydrated
fragment which gets deleted, and the new children gets inserted.

* Remove dehydrated from throw

Instead we use the regular Suspense path. To save code, we attach retry
listeners in the commit phase even though technically we don't have to.

* Pop to nearest Suspense

I think this is right...?

* Popping hydration state should skip past the dehydrated instance

* Split mount from update and special case suspended second pass

The DidCapture flag isn't used consistently in the same way. We need
further refactor for this.

* Reorganize update path

If we remove the dehydration status in the first pass and then do a second
pass because we suspended, then we need to continue as if it didn't
previously suspend. Since there is no fragment child etc.

However, we must readd the deletion.

* Schedule context work on the boundary and not the child

* Warn for Suspense hydration in legacy mode

It does a two pass render that client renders the content.

* Rename DehydratedSuspenseComponent -> DehydratedFragment

This now doesn't represent a suspense boundary itself. Its parent does.

This Fiber represents the fragment around the dehydrated content.

* Refactor returns

Avoids the temporary mutable variables. I kept losing track of them.

* Add a comment explaining the type.

Placing it in the type since that's the central point as opposed to spread
out.",https://api.github.com/repos/facebook/react/git/commits/50addf4c0e411e351de7290c8c60ec775c25c8c4,2019-08-12,"
Placing it in the type since that's the central point as opposed to spread
out."
66,MDY6Q29tbWl0MTAyNzAyNTA6NDI3OTQ1NTdjYTQ0YThjMDVjNzFhYWI2OThkNDRkMTI5NDIzNjUzOA==,Dominic Gannaway,GitHub,[Flare] Tweaks to Flare system design and API (#16264),https://api.github.com/repos/facebook/react/git/commits/42794557ca44a8c05c71aab698d44d1294236538,2019-08-01,[Flare] Tweaks to Flare system design and API (#16264)
66,MDY6Q29tbWl0MTAyNzAyNTA6NDI3OTQ1NTdjYTQ0YThjMDVjNzFhYWI2OThkNDRkMTI5NDIzNjUzOA==,Dominic Gannaway,GitHub,[Flare] Tweaks to Flare system design and API (#16264),https://api.github.com/repos/facebook/react/git/commits/42794557ca44a8c05c71aab698d44d1294236538,2019-08-01,
67,MDY6Q29tbWl0MTAyNzAyNTA6NTA5ODg5MTE5MzYwZWQ4M2NhNmVmM2Y4M2JjZjAxZTVhYTdkY2Q4MQ==,Dominic Gannaway,GitHub,[Flare] Redesign core event system (#16163),https://api.github.com/repos/facebook/react/git/commits/509889119360ed83ca6ef3f83bcf01e5aa7dcd81,2019-07-23,[Flare] Redesign core event system (#16163)
67,MDY6Q29tbWl0MTAyNzAyNTA6NTA5ODg5MTE5MzYwZWQ4M2NhNmVmM2Y4M2JjZjAxZTVhYTdkY2Q4MQ==,Dominic Gannaway,GitHub,[Flare] Redesign core event system (#16163),https://api.github.com/repos/facebook/react/git/commits/509889119360ed83ca6ef3f83bcf01e5aa7dcd81,2019-07-23,
68,MDY6Q29tbWl0MTAyNzAyNTA6MmM0ZDYxZTEwMjJhZTM4M2RkMTFmZTIzN2Y2ZGY4NDUxZTZmMDMxMA==,Dominic Gannaway,GitHub,Adds experimental fundamental interface (#16049),https://api.github.com/repos/facebook/react/git/commits/2c4d61e1022ae383dd11fe237f6df8451e6f0310,2019-07-19,Adds experimental fundamental interface (#16049)
68,MDY6Q29tbWl0MTAyNzAyNTA6MmM0ZDYxZTEwMjJhZTM4M2RkMTFmZTIzN2Y2ZGY4NDUxZTZmMDMxMA==,Dominic Gannaway,GitHub,Adds experimental fundamental interface (#16049),https://api.github.com/repos/facebook/react/git/commits/2c4d61e1022ae383dd11fe237f6df8451e6f0310,2019-07-19,
69,MDY6Q29tbWl0MTAyNzAyNTA6ZmNmZjljNTdiYzQxZjU4ZTg4MDIwMTZiNGRiYzBhN2I3MmNjNjNhZA==,Sebastian Markbåge,GitHub,"Add tail=""hidden"" option to SuspenseList (#16024)

* Move misaligned comment

* Add tail=""hidden"" option

* isShowingAnyFallbacks -> findFirstSuspended

* We can't reset Placement tags or we'll forget to insert them

* Delete hasSuspendedChildrenAndNewContent optimization",https://api.github.com/repos/facebook/react/git/commits/fcff9c57bc41f58e8802016b4dbc0a7b72cc63ad,2019-07-12,"Add tail=""hidden"" option to SuspenseList (#16024)"
69,MDY6Q29tbWl0MTAyNzAyNTA6ZmNmZjljNTdiYzQxZjU4ZTg4MDIwMTZiNGRiYzBhN2I3MmNjNjNhZA==,Sebastian Markbåge,GitHub,"Add tail=""hidden"" option to SuspenseList (#16024)

* Move misaligned comment

* Add tail=""hidden"" option

* isShowingAnyFallbacks -> findFirstSuspended

* We can't reset Placement tags or we'll forget to insert them

* Delete hasSuspendedChildrenAndNewContent optimization",https://api.github.com/repos/facebook/react/git/commits/fcff9c57bc41f58e8802016b4dbc0a7b72cc63ad,2019-07-12,
70,MDY6Q29tbWl0MTAyNzAyNTA6NjdlM2YzZmI2ZTM0MmY5NWYwMDIxNWM4NGQ1ZDAxM2Q3YjBlMWIzMw==,Dominic Gannaway,GitHub,[Flare] Revise responder event types (#16081),https://api.github.com/repos/facebook/react/git/commits/67e3f3fb6e342f95f00215c84d5d013d7b0e1b33,2019-07-08,[Flare] Revise responder event types (#16081)
70,MDY6Q29tbWl0MTAyNzAyNTA6NjdlM2YzZmI2ZTM0MmY5NWYwMDIxNWM4NGQ1ZDAxM2Q3YjBlMWIzMw==,Dominic Gannaway,GitHub,[Flare] Revise responder event types (#16081),https://api.github.com/repos/facebook/react/git/commits/67e3f3fb6e342f95f00215c84d5d013d7b0e1b33,2019-07-08,
71,MDY6Q29tbWl0MTAyNzAyNTA6MmEwZjYzOTBlZDY1N2ZhOGUyYzE0YzFjZjZkOWZhYTJmN2I0MjUyNQ==,Min ho Kim,Sunil Pai,Fix typos (#16076),https://api.github.com/repos/facebook/react/git/commits/2a0f6390ed657fa8e2c14c1cf6d9faa2f7b42525,2019-07-08,Fix typos (#16076)
71,MDY6Q29tbWl0MTAyNzAyNTA6MmEwZjYzOTBlZDY1N2ZhOGUyYzE0YzFjZjZkOWZhYTJmN2I0MjUyNQ==,Min ho Kim,Sunil Pai,Fix typos (#16076),https://api.github.com/repos/facebook/react/git/commits/2a0f6390ed657fa8e2c14c1cf6d9faa2f7b42525,2019-07-08,
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,SuspenseList Optimizations (#16005)
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"This only
works while the list wasn't suspended before"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"
I also moved the second render of the ""head"" to the complete phase"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"This
cleans it up a bit for the tail collapsing PR"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"
For this second pass I also use a new technique of resetting the child
Fibers for the second pass"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"This is effectively a fast path to avoid
reconciling the children against props again"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"
The effectTag now tracks whether the previous commit was suspended"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"
This frees up SuspenseListState to be render-phase only state"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"
We use null to mean the default ""independent"" mode"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"
This optimized the deep update case or initial render without anything
suspending"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"
We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"
This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender"
72,MDY6Q29tbWl0MTAyNzAyNTA6OTMzYzY2NGFkNjE3M2FkZGExMDIxZWUxY2MyZDkyMzNjM2MxM2UyMg==,Sebastian Markbåge,GitHub,"SuspenseList Optimizations (#16005)

* Add a bunch of optimizations to SuspenseList

We now are able to bail out of reconciliation and splitting out the tail
during deep updates that hasn't changed the child props. This only
works while the list wasn't suspended before.

I also moved the second render of the ""head"" to the complete phase. This
cleans it up a bit for the tail collapsing PR.

For this second pass I also use a new technique of resetting the child
Fibers for the second pass. This is effectively a fast path to avoid
reconciling the children against props again.

* Move to didSuspend from SuspenseListState to the effectTag

The effectTag now tracks whether the previous commit was suspended.

This frees up SuspenseListState to be render-phase only state.

We use null to mean the default ""independent"" mode.

* Rename to SuspenseListState to SuspenseListRenderState

* Reuse SuspenseListRenderState across render passes

* Add optimization to bail out of scanning children if they can't be suspended

This optimized the deep update case or initial render without anything
suspending.

We have some information available to us that tell us if nothing has
suspended in the past and nothing has suspended this render pass.

This also fixes a bug where we didn't tag the previous render as having
suspended boundaries if we didn't need to force a rerender.

* rm printChildren

oops",https://api.github.com/repos/facebook/react/git/commits/933c664ad6173adda1021ee1cc2d9233c3c13e22,2019-07-01,"
oops"
73,MDY6Q29tbWl0MTAyNzAyNTA6OWIwYmQ0MzU1MDIwNmUwNGJmZTljYTY5NWU1OTgxZWZmMGUyZDAzZg==,Dominic Gannaway,GitHub,[Flare] Re-label Flare flag (#16014),https://api.github.com/repos/facebook/react/git/commits/9b0bd43550206e04bfe9ca695e5981eff0e2d03f,2019-06-28,[Flare] Re-label Flare flag (#16014)
73,MDY6Q29tbWl0MTAyNzAyNTA6OWIwYmQ0MzU1MDIwNmUwNGJmZTljYTY5NWU1OTgxZWZmMGUyZDAzZg==,Dominic Gannaway,GitHub,[Flare] Re-label Flare flag (#16014),https://api.github.com/repos/facebook/react/git/commits/9b0bd43550206e04bfe9ca695e5981eff0e2d03f,2019-06-28,
74,MDY6Q29tbWl0MTAyNzAyNTA6OGI4OGFjMjU5MmM1ZjU1NWYzMTVmOTQ0MGNiYjY2NWRkMWU3NDU3YQ==,Dominic Gannaway,GitHub,[Flare] Remove event targets including TouchHitTarget (#16011),https://api.github.com/repos/facebook/react/git/commits/8b88ac2592c5f555f315f9440cbb665dd1e7457a,2019-06-27,[Flare] Remove event targets including TouchHitTarget (#16011)
74,MDY6Q29tbWl0MTAyNzAyNTA6OGI4OGFjMjU5MmM1ZjU1NWYzMTVmOTQ0MGNiYjY2NWRkMWU3NDU3YQ==,Dominic Gannaway,GitHub,[Flare] Remove event targets including TouchHitTarget (#16011),https://api.github.com/repos/facebook/react/git/commits/8b88ac2592c5f555f315f9440cbb665dd1e7457a,2019-06-27,
75,MDY6Q29tbWl0MTAyNzAyNTA6MzRjZTU3YWU3NTFlMDk1MmZkMTJhYjUzMmEzZTU2OTQ0NDU4OTdlYQ==,Dominic Gannaway,GitHub,[Flare] Refine flow type annotations (#15950),https://api.github.com/repos/facebook/react/git/commits/34ce57ae751e0952fd12ab532a3e5694445897ea,2019-06-21,[Flare] Refine flow type annotations (#15950)
75,MDY6Q29tbWl0MTAyNzAyNTA6MzRjZTU3YWU3NTFlMDk1MmZkMTJhYjUzMmEzZTU2OTQ0NDU4OTdlYQ==,Dominic Gannaway,GitHub,[Flare] Refine flow type annotations (#15950),https://api.github.com/repos/facebook/react/git/commits/34ce57ae751e0952fd12ab532a3e5694445897ea,2019-06-21,
76,MDY6Q29tbWl0MTAyNzAyNTA6MTc1MTExZGU3MjM5NzkxNjFiNzNjMjc1MWMzMzk2ZDIyZjQwNWRmYQ==,Andrew Clark,GitHub,"Lazily initialize dependencies object (#15944)

Most fibers do not have events or context, so we save memory lazily
initializing this container node.

Follow-up from #15927",https://api.github.com/repos/facebook/react/git/commits/175111de723979161b73c2751c3396d22f405dfa,2019-06-21,Lazily initialize dependencies object (#15944)
76,MDY6Q29tbWl0MTAyNzAyNTA6MTc1MTExZGU3MjM5NzkxNjFiNzNjMjc1MWMzMzk2ZDIyZjQwNWRmYQ==,Andrew Clark,GitHub,"Lazily initialize dependencies object (#15944)

Most fibers do not have events or context, so we save memory lazily
initializing this container node.

Follow-up from #15927",https://api.github.com/repos/facebook/react/git/commits/175111de723979161b73c2751c3396d22f405dfa,2019-06-21,"Most fibers do not have events or context, so we save memory lazily
initializing this container node"
76,MDY6Q29tbWl0MTAyNzAyNTA6MTc1MTExZGU3MjM5NzkxNjFiNzNjMjc1MWMzMzk2ZDIyZjQwNWRmYQ==,Andrew Clark,GitHub,"Lazily initialize dependencies object (#15944)

Most fibers do not have events or context, so we save memory lazily
initializing this container node.

Follow-up from #15927",https://api.github.com/repos/facebook/react/git/commits/175111de723979161b73c2751c3396d22f405dfa,2019-06-21,"
Follow-up from #15927"
77,MDY6Q29tbWl0MTAyNzAyNTA6NzIwZGI0Y2JlNjc1ZTgwODIwZWM4MWFiYWI0OTk0OTIzMDliOTI1Mg==,Dominic Gannaway,Andrew Clark,"[Flare] Add useEvent hook implementation (#15927)

* [Flare] Add useEvent hook implementation

Validate hooks have decendent event components

Few fixes and displayName changes

Fix more responder bugs

Update error codes

* Add another test

* Address feedback",https://api.github.com/repos/facebook/react/git/commits/720db4cbe675e80820ec81abab499492309b9252,2019-06-21,[Flare] Add useEvent hook implementation (#15927)
77,MDY6Q29tbWl0MTAyNzAyNTA6NzIwZGI0Y2JlNjc1ZTgwODIwZWM4MWFiYWI0OTk0OTIzMDliOTI1Mg==,Dominic Gannaway,Andrew Clark,"[Flare] Add useEvent hook implementation (#15927)

* [Flare] Add useEvent hook implementation

Validate hooks have decendent event components

Few fixes and displayName changes

Fix more responder bugs

Update error codes

* Add another test

* Address feedback",https://api.github.com/repos/facebook/react/git/commits/720db4cbe675e80820ec81abab499492309b9252,2019-06-21,"Validate hooks have decendent event components
Few fixes and displayName changes
Fix more responder bugs
Update error codes"
78,MDY6Q29tbWl0MTAyNzAyNTA6NzY4NjRmN2ZmNzI5ZjgyOTNlOGU3NzJkYTdhZDg0MTZkN2RlZjZiMw==,Sebastian Markbåge,GitHub,"Add SuspenseList Component (#15902)

* Add SuspenseList component type

* Push SuspenseContext for SuspenseList

* Force Suspense boundaries into their fallback state

In the ""together"" mode, we do a second render pass that forces the
fallbacks to stay in place, if not all can unsuspend at once.

* Add test

* Transfer thennables to the SuspenseList

This way, we end up retrying the SuspenseList in case the nested boundary
that just suspended doesn't actually get mounted with this set of
thennables. This happens when the second pass renders the fallback
directly without first attempting to render the content.

* Add warning for unsupported displayOrder

* Add tests for nested sibling boundaries and nested lists

* Fix nested SuspenseList forwarding thennables

* Rename displayOrder to revealOrder

Display order has some ""display list"" connotations making it sound like
a z-index thing.

Reveal indicates that this isn't really about when something gets rendered
or is ready to be rendered. It's about when content that is already there
gets to be revealed.

* Add test for avoided boundaries

* Make SuspenseList a noop in legacy mode

* Use an explicit suspense list state object

This will be used for more things in the directional case.",https://api.github.com/repos/facebook/react/git/commits/76864f7ff729f8293e8e772da7ad8416d7def6b3,2019-06-20,Add SuspenseList Component (#15902)
78,MDY6Q29tbWl0MTAyNzAyNTA6NzY4NjRmN2ZmNzI5ZjgyOTNlOGU3NzJkYTdhZDg0MTZkN2RlZjZiMw==,Sebastian Markbåge,GitHub,"Add SuspenseList Component (#15902)

* Add SuspenseList component type

* Push SuspenseContext for SuspenseList

* Force Suspense boundaries into their fallback state

In the ""together"" mode, we do a second render pass that forces the
fallbacks to stay in place, if not all can unsuspend at once.

* Add test

* Transfer thennables to the SuspenseList

This way, we end up retrying the SuspenseList in case the nested boundary
that just suspended doesn't actually get mounted with this set of
thennables. This happens when the second pass renders the fallback
directly without first attempting to render the content.

* Add warning for unsupported displayOrder

* Add tests for nested sibling boundaries and nested lists

* Fix nested SuspenseList forwarding thennables

* Rename displayOrder to revealOrder

Display order has some ""display list"" connotations making it sound like
a z-index thing.

Reveal indicates that this isn't really about when something gets rendered
or is ready to be rendered. It's about when content that is already there
gets to be revealed.

* Add test for avoided boundaries

* Make SuspenseList a noop in legacy mode

* Use an explicit suspense list state object

This will be used for more things in the directional case.",https://api.github.com/repos/facebook/react/git/commits/76864f7ff729f8293e8e772da7ad8416d7def6b3,2019-06-20,"In the ""together"" mode, we do a second render pass that forces the
fallbacks to stay in place, if not all can unsuspend at once"
78,MDY6Q29tbWl0MTAyNzAyNTA6NzY4NjRmN2ZmNzI5ZjgyOTNlOGU3NzJkYTdhZDg0MTZkN2RlZjZiMw==,Sebastian Markbåge,GitHub,"Add SuspenseList Component (#15902)

* Add SuspenseList component type

* Push SuspenseContext for SuspenseList

* Force Suspense boundaries into their fallback state

In the ""together"" mode, we do a second render pass that forces the
fallbacks to stay in place, if not all can unsuspend at once.

* Add test

* Transfer thennables to the SuspenseList

This way, we end up retrying the SuspenseList in case the nested boundary
that just suspended doesn't actually get mounted with this set of
thennables. This happens when the second pass renders the fallback
directly without first attempting to render the content.

* Add warning for unsupported displayOrder

* Add tests for nested sibling boundaries and nested lists

* Fix nested SuspenseList forwarding thennables

* Rename displayOrder to revealOrder

Display order has some ""display list"" connotations making it sound like
a z-index thing.

Reveal indicates that this isn't really about when something gets rendered
or is ready to be rendered. It's about when content that is already there
gets to be revealed.

* Add test for avoided boundaries

* Make SuspenseList a noop in legacy mode

* Use an explicit suspense list state object

This will be used for more things in the directional case.",https://api.github.com/repos/facebook/react/git/commits/76864f7ff729f8293e8e772da7ad8416d7def6b3,2019-06-20,"
This way, we end up retrying the SuspenseList in case the nested boundary
that just suspended doesn't actually get mounted with this set of
thennables"
78,MDY6Q29tbWl0MTAyNzAyNTA6NzY4NjRmN2ZmNzI5ZjgyOTNlOGU3NzJkYTdhZDg0MTZkN2RlZjZiMw==,Sebastian Markbåge,GitHub,"Add SuspenseList Component (#15902)

* Add SuspenseList component type

* Push SuspenseContext for SuspenseList

* Force Suspense boundaries into their fallback state

In the ""together"" mode, we do a second render pass that forces the
fallbacks to stay in place, if not all can unsuspend at once.

* Add test

* Transfer thennables to the SuspenseList

This way, we end up retrying the SuspenseList in case the nested boundary
that just suspended doesn't actually get mounted with this set of
thennables. This happens when the second pass renders the fallback
directly without first attempting to render the content.

* Add warning for unsupported displayOrder

* Add tests for nested sibling boundaries and nested lists

* Fix nested SuspenseList forwarding thennables

* Rename displayOrder to revealOrder

Display order has some ""display list"" connotations making it sound like
a z-index thing.

Reveal indicates that this isn't really about when something gets rendered
or is ready to be rendered. It's about when content that is already there
gets to be revealed.

* Add test for avoided boundaries

* Make SuspenseList a noop in legacy mode

* Use an explicit suspense list state object

This will be used for more things in the directional case.",https://api.github.com/repos/facebook/react/git/commits/76864f7ff729f8293e8e772da7ad8416d7def6b3,2019-06-20,"This happens when the second pass renders the fallback
directly without first attempting to render the content"
78,MDY6Q29tbWl0MTAyNzAyNTA6NzY4NjRmN2ZmNzI5ZjgyOTNlOGU3NzJkYTdhZDg0MTZkN2RlZjZiMw==,Sebastian Markbåge,GitHub,"Add SuspenseList Component (#15902)

* Add SuspenseList component type

* Push SuspenseContext for SuspenseList

* Force Suspense boundaries into their fallback state

In the ""together"" mode, we do a second render pass that forces the
fallbacks to stay in place, if not all can unsuspend at once.

* Add test

* Transfer thennables to the SuspenseList

This way, we end up retrying the SuspenseList in case the nested boundary
that just suspended doesn't actually get mounted with this set of
thennables. This happens when the second pass renders the fallback
directly without first attempting to render the content.

* Add warning for unsupported displayOrder

* Add tests for nested sibling boundaries and nested lists

* Fix nested SuspenseList forwarding thennables

* Rename displayOrder to revealOrder

Display order has some ""display list"" connotations making it sound like
a z-index thing.

Reveal indicates that this isn't really about when something gets rendered
or is ready to be rendered. It's about when content that is already there
gets to be revealed.

* Add test for avoided boundaries

* Make SuspenseList a noop in legacy mode

* Use an explicit suspense list state object

This will be used for more things in the directional case.",https://api.github.com/repos/facebook/react/git/commits/76864f7ff729f8293e8e772da7ad8416d7def6b3,2019-06-20,"
Display order has some ""display list"" connotations making it sound like
a z-index thing"
78,MDY6Q29tbWl0MTAyNzAyNTA6NzY4NjRmN2ZmNzI5ZjgyOTNlOGU3NzJkYTdhZDg0MTZkN2RlZjZiMw==,Sebastian Markbåge,GitHub,"Add SuspenseList Component (#15902)

* Add SuspenseList component type

* Push SuspenseContext for SuspenseList

* Force Suspense boundaries into their fallback state

In the ""together"" mode, we do a second render pass that forces the
fallbacks to stay in place, if not all can unsuspend at once.

* Add test

* Transfer thennables to the SuspenseList

This way, we end up retrying the SuspenseList in case the nested boundary
that just suspended doesn't actually get mounted with this set of
thennables. This happens when the second pass renders the fallback
directly without first attempting to render the content.

* Add warning for unsupported displayOrder

* Add tests for nested sibling boundaries and nested lists

* Fix nested SuspenseList forwarding thennables

* Rename displayOrder to revealOrder

Display order has some ""display list"" connotations making it sound like
a z-index thing.

Reveal indicates that this isn't really about when something gets rendered
or is ready to be rendered. It's about when content that is already there
gets to be revealed.

* Add test for avoided boundaries

* Make SuspenseList a noop in legacy mode

* Use an explicit suspense list state object

This will be used for more things in the directional case.",https://api.github.com/repos/facebook/react/git/commits/76864f7ff729f8293e8e772da7ad8416d7def6b3,2019-06-20,"
Reveal indicates that this isn't really about when something gets rendered
or is ready to be rendered"
78,MDY6Q29tbWl0MTAyNzAyNTA6NzY4NjRmN2ZmNzI5ZjgyOTNlOGU3NzJkYTdhZDg0MTZkN2RlZjZiMw==,Sebastian Markbåge,GitHub,"Add SuspenseList Component (#15902)

* Add SuspenseList component type

* Push SuspenseContext for SuspenseList

* Force Suspense boundaries into their fallback state

In the ""together"" mode, we do a second render pass that forces the
fallbacks to stay in place, if not all can unsuspend at once.

* Add test

* Transfer thennables to the SuspenseList

This way, we end up retrying the SuspenseList in case the nested boundary
that just suspended doesn't actually get mounted with this set of
thennables. This happens when the second pass renders the fallback
directly without first attempting to render the content.

* Add warning for unsupported displayOrder

* Add tests for nested sibling boundaries and nested lists

* Fix nested SuspenseList forwarding thennables

* Rename displayOrder to revealOrder

Display order has some ""display list"" connotations making it sound like
a z-index thing.

Reveal indicates that this isn't really about when something gets rendered
or is ready to be rendered. It's about when content that is already there
gets to be revealed.

* Add test for avoided boundaries

* Make SuspenseList a noop in legacy mode

* Use an explicit suspense list state object

This will be used for more things in the directional case.",https://api.github.com/repos/facebook/react/git/commits/76864f7ff729f8293e8e772da7ad8416d7def6b3,2019-06-20,"It's about when content that is already there
gets to be revealed"
78,MDY6Q29tbWl0MTAyNzAyNTA6NzY4NjRmN2ZmNzI5ZjgyOTNlOGU3NzJkYTdhZDg0MTZkN2RlZjZiMw==,Sebastian Markbåge,GitHub,"Add SuspenseList Component (#15902)

* Add SuspenseList component type

* Push SuspenseContext for SuspenseList

* Force Suspense boundaries into their fallback state

In the ""together"" mode, we do a second render pass that forces the
fallbacks to stay in place, if not all can unsuspend at once.

* Add test

* Transfer thennables to the SuspenseList

This way, we end up retrying the SuspenseList in case the nested boundary
that just suspended doesn't actually get mounted with this set of
thennables. This happens when the second pass renders the fallback
directly without first attempting to render the content.

* Add warning for unsupported displayOrder

* Add tests for nested sibling boundaries and nested lists

* Fix nested SuspenseList forwarding thennables

* Rename displayOrder to revealOrder

Display order has some ""display list"" connotations making it sound like
a z-index thing.

Reveal indicates that this isn't really about when something gets rendered
or is ready to be rendered. It's about when content that is already there
gets to be revealed.

* Add test for avoided boundaries

* Make SuspenseList a noop in legacy mode

* Use an explicit suspense list state object

This will be used for more things in the directional case.",https://api.github.com/repos/facebook/react/git/commits/76864f7ff729f8293e8e772da7ad8416d7def6b3,2019-06-20,"
This will be used for more things in the directional case."
79,MDY6Q29tbWl0MTAyNzAyNTA6ZDBlMDQxYWVlODNiNTBlNTQxNzZkMmRjOTU3ZDg2YzBmNTcxMjU3ZQ==,Dan Abramov,GitHub,"[Fresh] Support classes by force-remounting them on edit (#15801)

* Remount classes during hot reload

* Fix a crash when Hook isn't in scope inside the signature

* Minor tweaks

* Support a comment annotation to force state reset

* Refactoring: pass a function instead of WeakMap

This hides the implementation a little bit and reduces how much React knows about the underlying mechanism.

* Refactor: use forceReset to remount unknown Hooks

We already have the logic to reset a component, so let's just reuse it instead of that special case.",https://api.github.com/repos/facebook/react/git/commits/d0e041aee83b50e54176d2dc957d86c0f571257e,2019-06-05,[Fresh] Support classes by force-remounting them on edit (#15801)
79,MDY6Q29tbWl0MTAyNzAyNTA6ZDBlMDQxYWVlODNiNTBlNTQxNzZkMmRjOTU3ZDg2YzBmNTcxMjU3ZQ==,Dan Abramov,GitHub,"[Fresh] Support classes by force-remounting them on edit (#15801)

* Remount classes during hot reload

* Fix a crash when Hook isn't in scope inside the signature

* Minor tweaks

* Support a comment annotation to force state reset

* Refactoring: pass a function instead of WeakMap

This hides the implementation a little bit and reduces how much React knows about the underlying mechanism.

* Refactor: use forceReset to remount unknown Hooks

We already have the logic to reset a component, so let's just reuse it instead of that special case.",https://api.github.com/repos/facebook/react/git/commits/d0e041aee83b50e54176d2dc957d86c0f571257e,2019-06-05,This hides the implementation a little bit and reduces how much React knows about the underlying mechanism
79,MDY6Q29tbWl0MTAyNzAyNTA6ZDBlMDQxYWVlODNiNTBlNTQxNzZkMmRjOTU3ZDg2YzBmNTcxMjU3ZQ==,Dan Abramov,GitHub,"[Fresh] Support classes by force-remounting them on edit (#15801)

* Remount classes during hot reload

* Fix a crash when Hook isn't in scope inside the signature

* Minor tweaks

* Support a comment annotation to force state reset

* Refactoring: pass a function instead of WeakMap

This hides the implementation a little bit and reduces how much React knows about the underlying mechanism.

* Refactor: use forceReset to remount unknown Hooks

We already have the logic to reset a component, so let's just reuse it instead of that special case.",https://api.github.com/repos/facebook/react/git/commits/d0e041aee83b50e54176d2dc957d86c0f571257e,2019-06-05,"
We already have the logic to reset a component, so let's just reuse it instead of that special case."
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,[Fresh] Set up initial scaffolding (#15619)
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,Rendering an element with stale type should not cause it to remount
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
We only do this for FunctionComponent tag since checking is unnecessary for classes or host components"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
Initially I thought I would compare families of inner .render functions"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
However, there is a corner case where this can create false positives"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,Such as when you forwardRef(X) the same X twice
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,Those are supposed to be distinct
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"But if we compare .render functions, we wouldn't be able to distinguish them after first reload"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
It seems safer to rely on explicit registration for those"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"This should be easy when forwardRef() call is in the same file, and usually it would be"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
The __register__ implementation can read the inner identity itself"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This adds rudimentary support for memo components"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"However, we don't actually skip bailouts yet, so this is not very useful by itself alone"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,Tests have TODOs that we need to remove after bailout skipping is done
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This fixes the checks so that we only schedule updates for things that were actually edited"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This forces even memo() with shallow comparison to re-render on hot update"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
It's unnecessary because if they haven't been edited, there's no special reconciliation logic"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
Signatures let us force a remount of a type even if from React's point of view, type is the same"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
A type has one current signature"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"If that signature changes during next hot update, all Fibers with that type should be deleted and remounted"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
We do this by mutating elementType scheduling a parent"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This will be handy to force remount of mismatching Hooks, as well as failed error boundaries"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,This will be the most invasive and annoying change
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,I did it for HostRoot in this PR but there's more
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,I'll add an automated test case that catches the missing bailout bailouts
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This teaches all parent component types to remount their child if necessary"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
It also adds tests for them"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This makes sure that changes to *code* always propagate"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This moves resolving to set up the right .type early instead of doing this before render"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
A bit more future-proof in case we want to restructure the begin phase later"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
So we have a special overload for it that reconstucts the wrapper type if needed"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This gets rid of one of the sets"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
We still use a set for forced remount though"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This also disables the remounting tests"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,They need a separate approach
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
It has a TODO because it seems like offscreen updates are incorrectly applied too soon"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,"
This test is manual so I don't actually want act here"
80,MDY6Q29tbWl0MTAyNzAyNTA6MzE0ODdkZDgyZTgyZWY2MjI0MzgwNmIyZTc2YjIzYTZmYjIxZDBiYw==,Dan Abramov,GitHub,"[Fresh] Set up initial scaffolding (#15619)

* Add a minimal failing test for hot reload

* Set up scaffolding for React Fresh

* Consider type family when comparing elementType

Rendering an element with stale type should not cause it to remount.

We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.

* Add support for forwardRef()

Initially I thought I would compare families of inner .render functions.

However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.

It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself ""dig deeper"" and register the inner function.

* Show how forwardRef inner identity can be inferred

The __register__ implementation can read the inner identity itself.

* Add missing __DEV__ to tests

* Add support for memo() (without fixing bailouts)

This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.

* Refactor type comparison for clarity

* Hot update shouldn't re-render ancestor components unnecessarily

My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.

This fixes the checks so that we only schedule updates for things that were actually edited.

* Add test coverage for memo(fn, areEqual)

* Explicitly skip bailouts for hot reloading fibers

This forces even memo() with shallow comparison to re-render on hot update.

* Refactor scheduling update to reduce duplication

* Remove unused variable in test

* Don't check presence in a set while not hot reloading

* Make scheduleHotUpdate() take named arguments

* Don't keep unedited component types in the type => family map

It's unnecessary because if they haven't been edited, there's no special reconciliation logic.

* Add signatures that force remounting

Signatures let us force a remount of a type even if from React's point of view, type is the same.

A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.

We do this by mutating elementType scheduling a parent.

This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.

For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.

* Support forced remounting for all component types

This teaches all parent component types to remount their child if necessary.

It also adds tests for them.

* Remount effects while preserving state for hot reloaded components

This makes sure that changes to *code* always propagate.

It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.

* Add missing __DEV__ blocks to tests

* Fix unused variables in tests

* Remove outdated TODO

* Expose scheduleHotUpdate directly

* Inline isCompatibleType

* Run one check per component for invalidating deps

This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.

* Resolve .type early

This moves resolving to set up the right .type early instead of doing this before render.
A bit more future-proof in case we want to restructure the begin phase later.

ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
So we have a special overload for it that reconstucts the wrapper type if needed.

* Add a Suspense todo

* Use current.type !== workInProgress.type for ignoring deps

This gets rid of one of the sets.

* Use workInProgress.type !== current.type check for force re-render

We still use a set for forced remount though.

* Use wip.type !== current.type check in more places

This also disables the remounting tests. They need a separate approach.

* Use a dedicated remount mechanism

* Add a test for offscreen trees

It has a TODO because it seems like offscreen updates are incorrectly applied too soon.

* Enable offscreen test now that it is fixed

* Fix corner cases in the new remounting mechanism

* Remount failed error boundaries on hot reload

* Fix test now that act() flushes

This test is manual so I don't actually want act here.

* Nits

* Add comments",https://api.github.com/repos/facebook/react/git/commits/31487dd82e82ef62243806b2e76b23a6fb21d0bc,2019-05-18,
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,Add Batched Mode (#15502)
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"Any update that originates within the call
stack of the React event system is batched"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"It also includes updates triggered by lifecycle
methods or effects"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers)"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"
Ideally all updates would be batched by default"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"
One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental)"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"
This commit introduces an additional mode called Batched Mode"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"Batched
Mode enables a batched-by-default model that defers all updates to the
next React event"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"Once it begins rendering, React will not yield to
the browser until the entire render is finished"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"
Batched Mode is superset of Strict Mode"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,It fires all the same warnings
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"
I have not added any public APIs that expose the new mode yet"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"I'll do
that in subsequent commits"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"
Should have same semantics as Concurrent Mode"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"
There are three types of roots: Legacy, Batched, and Concurrent"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"
Treat Sync and Batched expiration times separately"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"Only Sync updates
are pushed to our internal queue of synchronous callbacks"
81,MDY6Q29tbWl0MTAyNzAyNTA6ODYyZjQ5OWZhY2ZiYTk2MzVmMjFjMjViMTczNjhjYjk4MGIxN2M3ZQ==,Andrew Clark,GitHub,"Add Batched Mode (#15502)

* Add Batched Mode

React has an unfortunate quirk where updates are sometimes synchronous
-- where React starts rendering immediately within the call stack of
`setState` — and sometimes batched, where updates are flushed at the
end of the current event. Any update that originates within the call
stack of the React event system is batched. This encompasses most
updates, since most updates originate from an event handler like
`onClick` or `onChange`. It also includes updates triggered by lifecycle
methods or effects. But there are also updates that originate outside
React's event system, like timer events, network events, and microtasks
(promise resolution handlers). These are not batched, which results in
both worse performance (multiple render passes instead of single one)
and confusing semantics.

Ideally all updates would be batched by default. Unfortunately, it's
easy for components to accidentally rely on this behavior, so changing
it could break existing apps in subtle ways.

One way to move to a batched-by-default model is to opt into Concurrent
Mode (still experimental). But Concurrent Mode introduces additional
semantic changes that apps may not be ready to adopt.

This commit introduces an additional mode called Batched Mode. Batched
Mode enables a batched-by-default model that defers all updates to the
next React event. Once it begins rendering, React will not yield to
the browser until the entire render is finished.

Batched Mode is superset of Strict Mode. It fires all the same warnings.
It also drops the forked Suspense behavior used by Legacy Mode, in favor
of the proper semantics used by Concurrent Mode.

I have not added any public APIs that expose the new mode yet. I'll do
that in subsequent commits.

* Suspense in Batched Mode

Should have same semantics as Concurrent Mode.

* Use RootTag field to configure type of root

There are three types of roots: Legacy, Batched, and Concurrent.

* flushSync should not flush batched work

Treat Sync and Batched expiration times separately. Only Sync updates
are pushed to our internal queue of synchronous callbacks.

Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.",https://api.github.com/repos/facebook/react/git/commits/862f499facfba9635f21c25b17368cb980b17c7e,2019-05-13,"
Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity."
82,MDY6Q29tbWl0MTAyNzAyNTA6ZGQ5Y2VmOWZjMDAxZTE3NGUxNzdiYWM0N2Q4OGZkMjhmZjhkZTMxNg==,Dominic Gannaway,GitHub,Experimental Event API: Add targets and responder utility method for finding targets (#15372),https://api.github.com/repos/facebook/react/git/commits/dd9cef9fc001e174e177bac47d88fd28ff8de316,2019-04-10,Experimental Event API: Add targets and responder utility method for finding targets (#15372)
82,MDY6Q29tbWl0MTAyNzAyNTA6ZGQ5Y2VmOWZjMDAxZTE3NGUxNzdiYWM0N2Q4OGZkMjhmZjhkZTMxNg==,Dominic Gannaway,GitHub,Experimental Event API: Add targets and responder utility method for finding targets (#15372),https://api.github.com/repos/facebook/react/git/commits/dd9cef9fc001e174e177bac47d88fd28ff8de316,2019-04-10,
83,MDY6Q29tbWl0MTAyNzAyNTA6YWVjZTgxMTljZjgyYTZlZmYwMmQ5YWQ4MTk3NThiN2FjMmM5YjMyOQ==,Dominic Gannaway,GitHub,Refactor EventComponent logic + add onOwnershipChange callback (#15354),https://api.github.com/repos/facebook/react/git/commits/aece8119cf82a6eff02d9ad819758b7ac2c9b329,2019-04-09,Refactor EventComponent logic + add onOwnershipChange callback (#15354)
83,MDY6Q29tbWl0MTAyNzAyNTA6YWVjZTgxMTljZjgyYTZlZmYwMmQ5YWQ4MTk3NThiN2FjMmM5YjMyOQ==,Dominic Gannaway,GitHub,Refactor EventComponent logic + add onOwnershipChange callback (#15354),https://api.github.com/repos/facebook/react/git/commits/aece8119cf82a6eff02d9ad819758b7ac2c9b329,2019-04-09,
84,MDY6Q29tbWl0MTAyNzAyNTA6NDA2NGVhOWZhNjM4N2M5MmE5ODViNTJiZmM2Njc0NmY4MWNjZDRmZA==,Dominic Gannaway,GitHub,Experimental event API: Support EventComponent onUnmount responder callback (#15335),https://api.github.com/repos/facebook/react/git/commits/4064ea9fa6387c92a985b52bfc66746f81ccd4fd,2019-04-06,Experimental event API: Support EventComponent onUnmount responder callback (#15335)
84,MDY6Q29tbWl0MTAyNzAyNTA6NDA2NGVhOWZhNjM4N2M5MmE5ODViNTJiZmM2Njc0NmY4MWNjZDRmZA==,Dominic Gannaway,GitHub,Experimental event API: Support EventComponent onUnmount responder callback (#15335),https://api.github.com/repos/facebook/react/git/commits/4064ea9fa6387c92a985b52bfc66746f81ccd4fd,2019-04-06,
85,MDY6Q29tbWl0MTAyNzAyNTA6YjkzYThhOWJiODQ2MGEzZDU4MjA3MmQzYjI1MmVjYzE1YzZlYTBmNQ==,Dominic Gannaway,GitHub,Experimental event API: refactor responder modules for lifecycle inclusion (#15322),https://api.github.com/repos/facebook/react/git/commits/b93a8a9bb8460a3d582072d3b252ecc15c6ea0f5,2019-04-04,Experimental event API: refactor responder modules for lifecycle inclusion (#15322)
85,MDY6Q29tbWl0MTAyNzAyNTA6YjkzYThhOWJiODQ2MGEzZDU4MjA3MmQzYjI1MmVjYzE1YzZlYTBmNQ==,Dominic Gannaway,GitHub,Experimental event API: refactor responder modules for lifecycle inclusion (#15322),https://api.github.com/repos/facebook/react/git/commits/b93a8a9bb8460a3d582072d3b252ecc15c6ea0f5,2019-04-04,
86,MDY6Q29tbWl0MTAyNzAyNTA6ODBmOGIwZDUxMjM5ODE5Njk5OTdlMDdjMDcxYmRjNmUzODg0ZWY1OA==,Dominic Gannaway,GitHub,"Add part of the event responder system for experimental event API (#15179)

* Add part of the event responder system",https://api.github.com/repos/facebook/react/git/commits/80f8b0d5123981969997e07c071bdc6e3884ef58,2019-03-26,Add part of the event responder system for experimental event API (#15179)
86,MDY6Q29tbWl0MTAyNzAyNTA6ODBmOGIwZDUxMjM5ODE5Njk5OTdlMDdjMDcxYmRjNmUzODg0ZWY1OA==,Dominic Gannaway,GitHub,"Add part of the event responder system for experimental event API (#15179)

* Add part of the event responder system",https://api.github.com/repos/facebook/react/git/commits/80f8b0d5123981969997e07c071bdc6e3884ef58,2019-03-26,
87,MDY6Q29tbWl0MTAyNzAyNTA6YjgzZTAxY2FkZTZmODZiOWExMjdiZGZkZGE2MGY2MjVmZDE0ZmRjZA==,Dominic Gannaway,GitHub,"Adds more scaffolding for experimental event API (#15112)

* Adds more scaffolding for experimental event API",https://api.github.com/repos/facebook/react/git/commits/b83e01cade6f86b9a127bdfdda60f625fd14fdcd,2019-03-20,Adds more scaffolding for experimental event API (#15112)
87,MDY6Q29tbWl0MTAyNzAyNTA6YjgzZTAxY2FkZTZmODZiOWExMjdiZGZkZGE2MGY2MjVmZDE0ZmRjZA==,Dominic Gannaway,GitHub,"Adds more scaffolding for experimental event API (#15112)

* Adds more scaffolding for experimental event API",https://api.github.com/repos/facebook/react/git/commits/b83e01cade6f86b9a127bdfdda60f625fd14fdcd,2019-03-20,
88,MDY6Q29tbWl0MTAyNzAyNTA6NDE4Njk1MmE2ZjM1NThlYjRmYWU5ZjZjNWY2NjliZDg5OGRjMWQ5Nw==,Brian Vaughn,GitHub,"Fixed incompatibility between react-debug-tools and useContext() (#14940)

* Refactor hook ordering check to use DEV-only data structure. This enables us to warn about more cases (e.g. useContext, useDebugValue) withou the need to add any overhead to production bundles.",https://api.github.com/repos/facebook/react/git/commits/4186952a6f3558eb4fae9f6c5f669bd898dc1d97,2019-02-26,Fixed incompatibility between react-debug-tools and useContext() (#14940)
88,MDY6Q29tbWl0MTAyNzAyNTA6NDE4Njk1MmE2ZjM1NThlYjRmYWU5ZjZjNWY2NjliZDg5OGRjMWQ5Nw==,Brian Vaughn,GitHub,"Fixed incompatibility between react-debug-tools and useContext() (#14940)

* Refactor hook ordering check to use DEV-only data structure. This enables us to warn about more cases (e.g. useContext, useDebugValue) withou the need to add any overhead to production bundles.",https://api.github.com/repos/facebook/react/git/commits/4186952a6f3558eb4fae9f6c5f669bd898dc1d97,2019-02-26,
89,MDY6Q29tbWl0MTAyNzAyNTA6NzkwYzhlZjA0MTk1ZjBmYzExY2EzZmIwOGU2M2Y4NzBmODE0ODNhYw==,Andrew Clark,GitHub,"Allow useReducer to bail out of rendering by returning previous state (#14569)

* Allow useReducer to bail out of rendering by returning previous state

This is conceptually similar to `shouldComponentUpdate`, except because
there could be multiple useReducer (or useState) Hooks in a single
component, we can only bail out if none of the Hooks produce a new
value. We also can't bail out if any the other types of inputs — state
and context — have changed.

These optimizations rely on the constraint that components are pure
functions of props, state, and context.

In some cases, we can bail out without entering the render phase by
eagerly computing the next state and comparing it to the current one.
This only works if we are absolutely certain that the queue is empty at
the time of the update. In concurrent mode, this is difficult to
determine, because there could be multiple copies of the queue and we
don't know which one is current without doing lots of extra work, which
would defeat the purpose of the optimization. However, in our
implementation, there are at most only two copies of the queue, and if
*both* are empty then we know that the current queue must be.

* Add test for context consumers inside hidden subtree

Should not bail out during subsequent update. (This isn't directly
related to this PR because we should have had this test, anyway.)

* Refactor to use module-level variable instead of effect bit

* Add test combining state bailout and props bailout (memo)",https://api.github.com/repos/facebook/react/git/commits/790c8ef04195f0fc11ca3fb08e63f870f81483ac,2019-01-17,Allow useReducer to bail out of rendering by returning previous state (#14569)
89,MDY6Q29tbWl0MTAyNzAyNTA6NzkwYzhlZjA0MTk1ZjBmYzExY2EzZmIwOGU2M2Y4NzBmODE0ODNhYw==,Andrew Clark,GitHub,"Allow useReducer to bail out of rendering by returning previous state (#14569)

* Allow useReducer to bail out of rendering by returning previous state

This is conceptually similar to `shouldComponentUpdate`, except because
there could be multiple useReducer (or useState) Hooks in a single
component, we can only bail out if none of the Hooks produce a new
value. We also can't bail out if any the other types of inputs — state
and context — have changed.

These optimizations rely on the constraint that components are pure
functions of props, state, and context.

In some cases, we can bail out without entering the render phase by
eagerly computing the next state and comparing it to the current one.
This only works if we are absolutely certain that the queue is empty at
the time of the update. In concurrent mode, this is difficult to
determine, because there could be multiple copies of the queue and we
don't know which one is current without doing lots of extra work, which
would defeat the purpose of the optimization. However, in our
implementation, there are at most only two copies of the queue, and if
*both* are empty then we know that the current queue must be.

* Add test for context consumers inside hidden subtree

Should not bail out during subsequent update. (This isn't directly
related to this PR because we should have had this test, anyway.)

* Refactor to use module-level variable instead of effect bit

* Add test combining state bailout and props bailout (memo)",https://api.github.com/repos/facebook/react/git/commits/790c8ef04195f0fc11ca3fb08e63f870f81483ac,2019-01-17,"This is conceptually similar to `shouldComponentUpdate`, except because
there could be multiple useReducer (or useState) Hooks in a single
component, we can only bail out if none of the Hooks produce a new
value"
89,MDY6Q29tbWl0MTAyNzAyNTA6NzkwYzhlZjA0MTk1ZjBmYzExY2EzZmIwOGU2M2Y4NzBmODE0ODNhYw==,Andrew Clark,GitHub,"Allow useReducer to bail out of rendering by returning previous state (#14569)

* Allow useReducer to bail out of rendering by returning previous state

This is conceptually similar to `shouldComponentUpdate`, except because
there could be multiple useReducer (or useState) Hooks in a single
component, we can only bail out if none of the Hooks produce a new
value. We also can't bail out if any the other types of inputs — state
and context — have changed.

These optimizations rely on the constraint that components are pure
functions of props, state, and context.

In some cases, we can bail out without entering the render phase by
eagerly computing the next state and comparing it to the current one.
This only works if we are absolutely certain that the queue is empty at
the time of the update. In concurrent mode, this is difficult to
determine, because there could be multiple copies of the queue and we
don't know which one is current without doing lots of extra work, which
would defeat the purpose of the optimization. However, in our
implementation, there are at most only two copies of the queue, and if
*both* are empty then we know that the current queue must be.

* Add test for context consumers inside hidden subtree

Should not bail out during subsequent update. (This isn't directly
related to this PR because we should have had this test, anyway.)

* Refactor to use module-level variable instead of effect bit

* Add test combining state bailout and props bailout (memo)",https://api.github.com/repos/facebook/react/git/commits/790c8ef04195f0fc11ca3fb08e63f870f81483ac,2019-01-17,"We also can't bail out if any the other types of inputs — state
and context — have changed"
89,MDY6Q29tbWl0MTAyNzAyNTA6NzkwYzhlZjA0MTk1ZjBmYzExY2EzZmIwOGU2M2Y4NzBmODE0ODNhYw==,Andrew Clark,GitHub,"Allow useReducer to bail out of rendering by returning previous state (#14569)

* Allow useReducer to bail out of rendering by returning previous state

This is conceptually similar to `shouldComponentUpdate`, except because
there could be multiple useReducer (or useState) Hooks in a single
component, we can only bail out if none of the Hooks produce a new
value. We also can't bail out if any the other types of inputs — state
and context — have changed.

These optimizations rely on the constraint that components are pure
functions of props, state, and context.

In some cases, we can bail out without entering the render phase by
eagerly computing the next state and comparing it to the current one.
This only works if we are absolutely certain that the queue is empty at
the time of the update. In concurrent mode, this is difficult to
determine, because there could be multiple copies of the queue and we
don't know which one is current without doing lots of extra work, which
would defeat the purpose of the optimization. However, in our
implementation, there are at most only two copies of the queue, and if
*both* are empty then we know that the current queue must be.

* Add test for context consumers inside hidden subtree

Should not bail out during subsequent update. (This isn't directly
related to this PR because we should have had this test, anyway.)

* Refactor to use module-level variable instead of effect bit

* Add test combining state bailout and props bailout (memo)",https://api.github.com/repos/facebook/react/git/commits/790c8ef04195f0fc11ca3fb08e63f870f81483ac,2019-01-17,"
These optimizations rely on the constraint that components are pure
functions of props, state, and context"
89,MDY6Q29tbWl0MTAyNzAyNTA6NzkwYzhlZjA0MTk1ZjBmYzExY2EzZmIwOGU2M2Y4NzBmODE0ODNhYw==,Andrew Clark,GitHub,"Allow useReducer to bail out of rendering by returning previous state (#14569)

* Allow useReducer to bail out of rendering by returning previous state

This is conceptually similar to `shouldComponentUpdate`, except because
there could be multiple useReducer (or useState) Hooks in a single
component, we can only bail out if none of the Hooks produce a new
value. We also can't bail out if any the other types of inputs — state
and context — have changed.

These optimizations rely on the constraint that components are pure
functions of props, state, and context.

In some cases, we can bail out without entering the render phase by
eagerly computing the next state and comparing it to the current one.
This only works if we are absolutely certain that the queue is empty at
the time of the update. In concurrent mode, this is difficult to
determine, because there could be multiple copies of the queue and we
don't know which one is current without doing lots of extra work, which
would defeat the purpose of the optimization. However, in our
implementation, there are at most only two copies of the queue, and if
*both* are empty then we know that the current queue must be.

* Add test for context consumers inside hidden subtree

Should not bail out during subsequent update. (This isn't directly
related to this PR because we should have had this test, anyway.)

* Refactor to use module-level variable instead of effect bit

* Add test combining state bailout and props bailout (memo)",https://api.github.com/repos/facebook/react/git/commits/790c8ef04195f0fc11ca3fb08e63f870f81483ac,2019-01-17,"
In some cases, we can bail out without entering the render phase by
eagerly computing the next state and comparing it to the current one"
89,MDY6Q29tbWl0MTAyNzAyNTA6NzkwYzhlZjA0MTk1ZjBmYzExY2EzZmIwOGU2M2Y4NzBmODE0ODNhYw==,Andrew Clark,GitHub,"Allow useReducer to bail out of rendering by returning previous state (#14569)

* Allow useReducer to bail out of rendering by returning previous state

This is conceptually similar to `shouldComponentUpdate`, except because
there could be multiple useReducer (or useState) Hooks in a single
component, we can only bail out if none of the Hooks produce a new
value. We also can't bail out if any the other types of inputs — state
and context — have changed.

These optimizations rely on the constraint that components are pure
functions of props, state, and context.

In some cases, we can bail out without entering the render phase by
eagerly computing the next state and comparing it to the current one.
This only works if we are absolutely certain that the queue is empty at
the time of the update. In concurrent mode, this is difficult to
determine, because there could be multiple copies of the queue and we
don't know which one is current without doing lots of extra work, which
would defeat the purpose of the optimization. However, in our
implementation, there are at most only two copies of the queue, and if
*both* are empty then we know that the current queue must be.

* Add test for context consumers inside hidden subtree

Should not bail out during subsequent update. (This isn't directly
related to this PR because we should have had this test, anyway.)

* Refactor to use module-level variable instead of effect bit

* Add test combining state bailout and props bailout (memo)",https://api.github.com/repos/facebook/react/git/commits/790c8ef04195f0fc11ca3fb08e63f870f81483ac,2019-01-17,"
This only works if we are absolutely certain that the queue is empty at
the time of the update"
89,MDY6Q29tbWl0MTAyNzAyNTA6NzkwYzhlZjA0MTk1ZjBmYzExY2EzZmIwOGU2M2Y4NzBmODE0ODNhYw==,Andrew Clark,GitHub,"Allow useReducer to bail out of rendering by returning previous state (#14569)

* Allow useReducer to bail out of rendering by returning previous state

This is conceptually similar to `shouldComponentUpdate`, except because
there could be multiple useReducer (or useState) Hooks in a single
component, we can only bail out if none of the Hooks produce a new
value. We also can't bail out if any the other types of inputs — state
and context — have changed.

These optimizations rely on the constraint that components are pure
functions of props, state, and context.

In some cases, we can bail out without entering the render phase by
eagerly computing the next state and comparing it to the current one.
This only works if we are absolutely certain that the queue is empty at
the time of the update. In concurrent mode, this is difficult to
determine, because there could be multiple copies of the queue and we
don't know which one is current without doing lots of extra work, which
would defeat the purpose of the optimization. However, in our
implementation, there are at most only two copies of the queue, and if
*both* are empty then we know that the current queue must be.

* Add test for context consumers inside hidden subtree

Should not bail out during subsequent update. (This isn't directly
related to this PR because we should have had this test, anyway.)

* Refactor to use module-level variable instead of effect bit

* Add test combining state bailout and props bailout (memo)",https://api.github.com/repos/facebook/react/git/commits/790c8ef04195f0fc11ca3fb08e63f870f81483ac,2019-01-17,"In concurrent mode, this is difficult to
determine, because there could be multiple copies of the queue and we
don't know which one is current without doing lots of extra work, which
would defeat the purpose of the optimization"
89,MDY6Q29tbWl0MTAyNzAyNTA6NzkwYzhlZjA0MTk1ZjBmYzExY2EzZmIwOGU2M2Y4NzBmODE0ODNhYw==,Andrew Clark,GitHub,"Allow useReducer to bail out of rendering by returning previous state (#14569)

* Allow useReducer to bail out of rendering by returning previous state

This is conceptually similar to `shouldComponentUpdate`, except because
there could be multiple useReducer (or useState) Hooks in a single
component, we can only bail out if none of the Hooks produce a new
value. We also can't bail out if any the other types of inputs — state
and context — have changed.

These optimizations rely on the constraint that components are pure
functions of props, state, and context.

In some cases, we can bail out without entering the render phase by
eagerly computing the next state and comparing it to the current one.
This only works if we are absolutely certain that the queue is empty at
the time of the update. In concurrent mode, this is difficult to
determine, because there could be multiple copies of the queue and we
don't know which one is current without doing lots of extra work, which
would defeat the purpose of the optimization. However, in our
implementation, there are at most only two copies of the queue, and if
*both* are empty then we know that the current queue must be.

* Add test for context consumers inside hidden subtree

Should not bail out during subsequent update. (This isn't directly
related to this PR because we should have had this test, anyway.)

* Refactor to use module-level variable instead of effect bit

* Add test combining state bailout and props bailout (memo)",https://api.github.com/repos/facebook/react/git/commits/790c8ef04195f0fc11ca3fb08e63f870f81483ac,2019-01-17,"However, in our
implementation, there are at most only two copies of the queue, and if
Should not bail out during subsequent update"
89,MDY6Q29tbWl0MTAyNzAyNTA6NzkwYzhlZjA0MTk1ZjBmYzExY2EzZmIwOGU2M2Y4NzBmODE0ODNhYw==,Andrew Clark,GitHub,"Allow useReducer to bail out of rendering by returning previous state (#14569)

* Allow useReducer to bail out of rendering by returning previous state

This is conceptually similar to `shouldComponentUpdate`, except because
there could be multiple useReducer (or useState) Hooks in a single
component, we can only bail out if none of the Hooks produce a new
value. We also can't bail out if any the other types of inputs — state
and context — have changed.

These optimizations rely on the constraint that components are pure
functions of props, state, and context.

In some cases, we can bail out without entering the render phase by
eagerly computing the next state and comparing it to the current one.
This only works if we are absolutely certain that the queue is empty at
the time of the update. In concurrent mode, this is difficult to
determine, because there could be multiple copies of the queue and we
don't know which one is current without doing lots of extra work, which
would defeat the purpose of the optimization. However, in our
implementation, there are at most only two copies of the queue, and if
*both* are empty then we know that the current queue must be.

* Add test for context consumers inside hidden subtree

Should not bail out during subsequent update. (This isn't directly
related to this PR because we should have had this test, anyway.)

* Refactor to use module-level variable instead of effect bit

* Add test combining state bailout and props bailout (memo)",https://api.github.com/repos/facebook/react/git/commits/790c8ef04195f0fc11ca3fb08e63f870f81483ac,2019-01-17,"(This isn't directly
related to this PR because we should have had this test, anyway.)"
90,MDY6Q29tbWl0MTAyNzAyNTA6MWRjMTA4ZTU4MjliYjhkODRmZmQzOWUyZTkzMmQ3OThlZGQ3Y2E4Yg==,Brian Vaughn,Brian Vaughn,"Tweaked wording for v8 ""performance cliff"" issue",https://api.github.com/repos/facebook/react/git/commits/1dc108e5829bb8d84ffd39e2e932d798edd7ca8b,2018-12-04,"Tweaked wording for v8 ""performance cliff"" issue"
90,MDY6Q29tbWl0MTAyNzAyNTA6MWRjMTA4ZTU4MjliYjhkODRmZmQzOWUyZTkzMmQ3OThlZGQ3Y2E4Yg==,Brian Vaughn,Brian Vaughn,"Tweaked wording for v8 ""performance cliff"" issue",https://api.github.com/repos/facebook/react/git/commits/1dc108e5829bb8d84ffd39e2e932d798edd7ca8b,2018-12-04,
91,MDY6Q29tbWl0MTAyNzAyNTA6N2E0OGM5MDBiN2Q4Yzk3NTgwZDYyYWRmYTM2MjVhN2I3NTY3Yzk5OA==,Brian Vaughn,GitHub,Prevent a v8 deopt when profiling (#14383),https://api.github.com/repos/facebook/react/git/commits/7a48c900b7d8c97580d62adfa3625a7b7567c998,2018-12-03,Prevent a v8 deopt when profiling (#14383)
91,MDY6Q29tbWl0MTAyNzAyNTA6N2E0OGM5MDBiN2Q4Yzk3NTgwZDYyYWRmYTM2MjVhN2I3NTY3Yzk5OA==,Brian Vaughn,GitHub,Prevent a v8 deopt when profiling (#14383),https://api.github.com/repos/facebook/react/git/commits/7a48c900b7d8c97580d62adfa3625a7b7567c998,2018-12-03,
92,MDY6Q29tbWl0MTAyNzAyNTA6NzY5YjFmMjcwZTEyNTFkOWRiZGNlMGZjYmQ5ZTkyZTUwMmQwNTliOA==,Dan Abramov,GitHub,pure -> memo (#13905),https://api.github.com/repos/facebook/react/git/commits/769b1f270e1251d9dbdce0fcbd9e92e502d059b8,2018-10-20,pure -> memo (#13905)
92,MDY6Q29tbWl0MTAyNzAyNTA6NzY5YjFmMjcwZTEyNTFkOWRiZGNlMGZjYmQ5ZTkyZTUwMmQwNTliOA==,Dan Abramov,GitHub,pure -> memo (#13905),https://api.github.com/repos/facebook/react/git/commits/769b1f270e1251d9dbdce0fcbd9e92e502d059b8,2018-10-20,
93,MDY6Q29tbWl0MTAyNzAyNTA6MTViMTFkMjNmOTYwYzE1OGE3ZTk5Njc5YmY2MjA0MWNlMTZhZWQ3ZQ==,Sebastian Markbåge,GitHub,"Allow arbitrary types to be wrapped in pure (#13903)

* Allow arbitrary types to be wrapped in pure

This creates an outer fiber that container the pure check and an inner
fiber that represents which ever type of component.

* Add optimized fast path for simple pure function components

Special cased when there are no defaultProps and it's a simple function
component instead of class. This doesn't require an extra fiber.

We could make it so that this also works with custom comparer but that
means we have to go through one extra indirection to get to it.
Maybe it's worth it, donno.",https://api.github.com/repos/facebook/react/git/commits/15b11d23f960c158a7e99679bf62041ce16aed7e,2018-10-20,Allow arbitrary types to be wrapped in pure (#13903)
93,MDY6Q29tbWl0MTAyNzAyNTA6MTViMTFkMjNmOTYwYzE1OGE3ZTk5Njc5YmY2MjA0MWNlMTZhZWQ3ZQ==,Sebastian Markbåge,GitHub,"Allow arbitrary types to be wrapped in pure (#13903)

* Allow arbitrary types to be wrapped in pure

This creates an outer fiber that container the pure check and an inner
fiber that represents which ever type of component.

* Add optimized fast path for simple pure function components

Special cased when there are no defaultProps and it's a simple function
component instead of class. This doesn't require an extra fiber.

We could make it so that this also works with custom comparer but that
means we have to go through one extra indirection to get to it.
Maybe it's worth it, donno.",https://api.github.com/repos/facebook/react/git/commits/15b11d23f960c158a7e99679bf62041ce16aed7e,2018-10-20,"This creates an outer fiber that container the pure check and an inner
fiber that represents which ever type of component"
93,MDY6Q29tbWl0MTAyNzAyNTA6MTViMTFkMjNmOTYwYzE1OGE3ZTk5Njc5YmY2MjA0MWNlMTZhZWQ3ZQ==,Sebastian Markbåge,GitHub,"Allow arbitrary types to be wrapped in pure (#13903)

* Allow arbitrary types to be wrapped in pure

This creates an outer fiber that container the pure check and an inner
fiber that represents which ever type of component.

* Add optimized fast path for simple pure function components

Special cased when there are no defaultProps and it's a simple function
component instead of class. This doesn't require an extra fiber.

We could make it so that this also works with custom comparer but that
means we have to go through one extra indirection to get to it.
Maybe it's worth it, donno.",https://api.github.com/repos/facebook/react/git/commits/15b11d23f960c158a7e99679bf62041ce16aed7e,2018-10-20,"
Special cased when there are no defaultProps and it's a simple function
component instead of class"
93,MDY6Q29tbWl0MTAyNzAyNTA6MTViMTFkMjNmOTYwYzE1OGE3ZTk5Njc5YmY2MjA0MWNlMTZhZWQ3ZQ==,Sebastian Markbåge,GitHub,"Allow arbitrary types to be wrapped in pure (#13903)

* Allow arbitrary types to be wrapped in pure

This creates an outer fiber that container the pure check and an inner
fiber that represents which ever type of component.

* Add optimized fast path for simple pure function components

Special cased when there are no defaultProps and it's a simple function
component instead of class. This doesn't require an extra fiber.

We could make it so that this also works with custom comparer but that
means we have to go through one extra indirection to get to it.
Maybe it's worth it, donno.",https://api.github.com/repos/facebook/react/git/commits/15b11d23f960c158a7e99679bf62041ce16aed7e,2018-10-20,This doesn't require an extra fiber
93,MDY6Q29tbWl0MTAyNzAyNTA6MTViMTFkMjNmOTYwYzE1OGE3ZTk5Njc5YmY2MjA0MWNlMTZhZWQ3ZQ==,Sebastian Markbåge,GitHub,"Allow arbitrary types to be wrapped in pure (#13903)

* Allow arbitrary types to be wrapped in pure

This creates an outer fiber that container the pure check and an inner
fiber that represents which ever type of component.

* Add optimized fast path for simple pure function components

Special cased when there are no defaultProps and it's a simple function
component instead of class. This doesn't require an extra fiber.

We could make it so that this also works with custom comparer but that
means we have to go through one extra indirection to get to it.
Maybe it's worth it, donno.",https://api.github.com/repos/facebook/react/git/commits/15b11d23f960c158a7e99679bf62041ce16aed7e,2018-10-20,"
We could make it so that this also works with custom comparer but that
means we have to go through one extra indirection to get to it"
93,MDY6Q29tbWl0MTAyNzAyNTA6MTViMTFkMjNmOTYwYzE1OGE3ZTk5Njc5YmY2MjA0MWNlMTZhZWQ3ZQ==,Sebastian Markbåge,GitHub,"Allow arbitrary types to be wrapped in pure (#13903)

* Allow arbitrary types to be wrapped in pure

This creates an outer fiber that container the pure check and an inner
fiber that represents which ever type of component.

* Add optimized fast path for simple pure function components

Special cased when there are no defaultProps and it's a simple function
component instead of class. This doesn't require an extra fiber.

We could make it so that this also works with custom comparer but that
means we have to go through one extra indirection to get to it.
Maybe it's worth it, donno.",https://api.github.com/repos/facebook/react/git/commits/15b11d23f960c158a7e99679bf62041ce16aed7e,2018-10-20,"
Maybe it's worth it, donno."
94,MDY6Q29tbWl0MTAyNzAyNTA6OTVhMzEzZWMwYjk1N2Y3MTc5OGE2OWQ4ZTgzNDA4ZjQwZTc2NzY1Yg==,Sebastian Markbåge,Andrew Clark,"Unfork Lazy Component Branches (#13902)

* Introduce elementType field

This will be used to store the wrapped type of an element. E.g. pure and
lazy.

The existing type field will be used for the unwrapped type within them.

* Store the unwrapped type on the type field of lazy components

* Use the raw tags for lazy components

Instead, we check if the elementType and type are equal to test if
we need to resolve props. This is slightly slower in the normal case
but will yield less code and branching.

* Clean up lazy branches

* Collapse work tag numbering

* Split IndeterminateComponent out from Lazy

This way we don't have to check the type in a hacky way in the
indeterminate path. Also, lets us deal with lazy that resolves to
indeterminate and such.

* Missing clean up in rebase",https://api.github.com/repos/facebook/react/git/commits/95a313ec0b957f71798a69d8e83408f40e76765b,2018-10-20,Unfork Lazy Component Branches (#13902)
94,MDY6Q29tbWl0MTAyNzAyNTA6OTVhMzEzZWMwYjk1N2Y3MTc5OGE2OWQ4ZTgzNDA4ZjQwZTc2NzY1Yg==,Sebastian Markbåge,Andrew Clark,"Unfork Lazy Component Branches (#13902)

* Introduce elementType field

This will be used to store the wrapped type of an element. E.g. pure and
lazy.

The existing type field will be used for the unwrapped type within them.

* Store the unwrapped type on the type field of lazy components

* Use the raw tags for lazy components

Instead, we check if the elementType and type are equal to test if
we need to resolve props. This is slightly slower in the normal case
but will yield less code and branching.

* Clean up lazy branches

* Collapse work tag numbering

* Split IndeterminateComponent out from Lazy

This way we don't have to check the type in a hacky way in the
indeterminate path. Also, lets us deal with lazy that resolves to
indeterminate and such.

* Missing clean up in rebase",https://api.github.com/repos/facebook/react/git/commits/95a313ec0b957f71798a69d8e83408f40e76765b,2018-10-20,This will be used to store the wrapped type of an element
94,MDY6Q29tbWl0MTAyNzAyNTA6OTVhMzEzZWMwYjk1N2Y3MTc5OGE2OWQ4ZTgzNDA4ZjQwZTc2NzY1Yg==,Sebastian Markbåge,Andrew Clark,"Unfork Lazy Component Branches (#13902)

* Introduce elementType field

This will be used to store the wrapped type of an element. E.g. pure and
lazy.

The existing type field will be used for the unwrapped type within them.

* Store the unwrapped type on the type field of lazy components

* Use the raw tags for lazy components

Instead, we check if the elementType and type are equal to test if
we need to resolve props. This is slightly slower in the normal case
but will yield less code and branching.

* Clean up lazy branches

* Collapse work tag numbering

* Split IndeterminateComponent out from Lazy

This way we don't have to check the type in a hacky way in the
indeterminate path. Also, lets us deal with lazy that resolves to
indeterminate and such.

* Missing clean up in rebase",https://api.github.com/repos/facebook/react/git/commits/95a313ec0b957f71798a69d8e83408f40e76765b,2018-10-20,E.g
94,MDY6Q29tbWl0MTAyNzAyNTA6OTVhMzEzZWMwYjk1N2Y3MTc5OGE2OWQ4ZTgzNDA4ZjQwZTc2NzY1Yg==,Sebastian Markbåge,Andrew Clark,"Unfork Lazy Component Branches (#13902)

* Introduce elementType field

This will be used to store the wrapped type of an element. E.g. pure and
lazy.

The existing type field will be used for the unwrapped type within them.

* Store the unwrapped type on the type field of lazy components

* Use the raw tags for lazy components

Instead, we check if the elementType and type are equal to test if
we need to resolve props. This is slightly slower in the normal case
but will yield less code and branching.

* Clean up lazy branches

* Collapse work tag numbering

* Split IndeterminateComponent out from Lazy

This way we don't have to check the type in a hacky way in the
indeterminate path. Also, lets us deal with lazy that resolves to
indeterminate and such.

* Missing clean up in rebase",https://api.github.com/repos/facebook/react/git/commits/95a313ec0b957f71798a69d8e83408f40e76765b,2018-10-20,"pure and
lazy"
94,MDY6Q29tbWl0MTAyNzAyNTA6OTVhMzEzZWMwYjk1N2Y3MTc5OGE2OWQ4ZTgzNDA4ZjQwZTc2NzY1Yg==,Sebastian Markbåge,Andrew Clark,"Unfork Lazy Component Branches (#13902)

* Introduce elementType field

This will be used to store the wrapped type of an element. E.g. pure and
lazy.

The existing type field will be used for the unwrapped type within them.

* Store the unwrapped type on the type field of lazy components

* Use the raw tags for lazy components

Instead, we check if the elementType and type are equal to test if
we need to resolve props. This is slightly slower in the normal case
but will yield less code and branching.

* Clean up lazy branches

* Collapse work tag numbering

* Split IndeterminateComponent out from Lazy

This way we don't have to check the type in a hacky way in the
indeterminate path. Also, lets us deal with lazy that resolves to
indeterminate and such.

* Missing clean up in rebase",https://api.github.com/repos/facebook/react/git/commits/95a313ec0b957f71798a69d8e83408f40e76765b,2018-10-20,"
The existing type field will be used for the unwrapped type within them"
94,MDY6Q29tbWl0MTAyNzAyNTA6OTVhMzEzZWMwYjk1N2Y3MTc5OGE2OWQ4ZTgzNDA4ZjQwZTc2NzY1Yg==,Sebastian Markbåge,Andrew Clark,"Unfork Lazy Component Branches (#13902)

* Introduce elementType field

This will be used to store the wrapped type of an element. E.g. pure and
lazy.

The existing type field will be used for the unwrapped type within them.

* Store the unwrapped type on the type field of lazy components

* Use the raw tags for lazy components

Instead, we check if the elementType and type are equal to test if
we need to resolve props. This is slightly slower in the normal case
but will yield less code and branching.

* Clean up lazy branches

* Collapse work tag numbering

* Split IndeterminateComponent out from Lazy

This way we don't have to check the type in a hacky way in the
indeterminate path. Also, lets us deal with lazy that resolves to
indeterminate and such.

* Missing clean up in rebase",https://api.github.com/repos/facebook/react/git/commits/95a313ec0b957f71798a69d8e83408f40e76765b,2018-10-20,"
Instead, we check if the elementType and type are equal to test if
we need to resolve props"
94,MDY6Q29tbWl0MTAyNzAyNTA6OTVhMzEzZWMwYjk1N2Y3MTc5OGE2OWQ4ZTgzNDA4ZjQwZTc2NzY1Yg==,Sebastian Markbåge,Andrew Clark,"Unfork Lazy Component Branches (#13902)

* Introduce elementType field

This will be used to store the wrapped type of an element. E.g. pure and
lazy.

The existing type field will be used for the unwrapped type within them.

* Store the unwrapped type on the type field of lazy components

* Use the raw tags for lazy components

Instead, we check if the elementType and type are equal to test if
we need to resolve props. This is slightly slower in the normal case
but will yield less code and branching.

* Clean up lazy branches

* Collapse work tag numbering

* Split IndeterminateComponent out from Lazy

This way we don't have to check the type in a hacky way in the
indeterminate path. Also, lets us deal with lazy that resolves to
indeterminate and such.

* Missing clean up in rebase",https://api.github.com/repos/facebook/react/git/commits/95a313ec0b957f71798a69d8e83408f40e76765b,2018-10-20,"This is slightly slower in the normal case
but will yield less code and branching"
94,MDY6Q29tbWl0MTAyNzAyNTA6OTVhMzEzZWMwYjk1N2Y3MTc5OGE2OWQ4ZTgzNDA4ZjQwZTc2NzY1Yg==,Sebastian Markbåge,Andrew Clark,"Unfork Lazy Component Branches (#13902)

* Introduce elementType field

This will be used to store the wrapped type of an element. E.g. pure and
lazy.

The existing type field will be used for the unwrapped type within them.

* Store the unwrapped type on the type field of lazy components

* Use the raw tags for lazy components

Instead, we check if the elementType and type are equal to test if
we need to resolve props. This is slightly slower in the normal case
but will yield less code and branching.

* Clean up lazy branches

* Collapse work tag numbering

* Split IndeterminateComponent out from Lazy

This way we don't have to check the type in a hacky way in the
indeterminate path. Also, lets us deal with lazy that resolves to
indeterminate and such.

* Missing clean up in rebase",https://api.github.com/repos/facebook/react/git/commits/95a313ec0b957f71798a69d8e83408f40e76765b,2018-10-20,"
This way we don't have to check the type in a hacky way in the
indeterminate path"
94,MDY6Q29tbWl0MTAyNzAyNTA6OTVhMzEzZWMwYjk1N2Y3MTc5OGE2OWQ4ZTgzNDA4ZjQwZTc2NzY1Yg==,Sebastian Markbåge,Andrew Clark,"Unfork Lazy Component Branches (#13902)

* Introduce elementType field

This will be used to store the wrapped type of an element. E.g. pure and
lazy.

The existing type field will be used for the unwrapped type within them.

* Store the unwrapped type on the type field of lazy components

* Use the raw tags for lazy components

Instead, we check if the elementType and type are equal to test if
we need to resolve props. This is slightly slower in the normal case
but will yield less code and branching.

* Clean up lazy branches

* Collapse work tag numbering

* Split IndeterminateComponent out from Lazy

This way we don't have to check the type in a hacky way in the
indeterminate path. Also, lets us deal with lazy that resolves to
indeterminate and such.

* Missing clean up in rebase",https://api.github.com/repos/facebook/react/git/commits/95a313ec0b957f71798a69d8e83408f40e76765b,2018-10-20,"Also, lets us deal with lazy that resolves to
indeterminate and such"
94,MDY6Q29tbWl0MTAyNzAyNTA6OTVhMzEzZWMwYjk1N2Y3MTc5OGE2OWQ4ZTgzNDA4ZjQwZTc2NzY1Yg==,Sebastian Markbåge,Andrew Clark,"Unfork Lazy Component Branches (#13902)

* Introduce elementType field

This will be used to store the wrapped type of an element. E.g. pure and
lazy.

The existing type field will be used for the unwrapped type within them.

* Store the unwrapped type on the type field of lazy components

* Use the raw tags for lazy components

Instead, we check if the elementType and type are equal to test if
we need to resolve props. This is slightly slower in the normal case
but will yield less code and branching.

* Clean up lazy branches

* Collapse work tag numbering

* Split IndeterminateComponent out from Lazy

This way we don't have to check the type in a hacky way in the
indeterminate path. Also, lets us deal with lazy that resolves to
indeterminate and such.

* Missing clean up in rebase",https://api.github.com/repos/facebook/react/git/commits/95a313ec0b957f71798a69d8e83408f40e76765b,2018-10-20,
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,Lazy components must use React.lazy (#13885)
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,"Removes support for using arbitrary promises as the type of a React
element"
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,"Instead, promises must be wrapped in React.lazy"
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,"This gives us
flexibility later if we need to change the protocol"
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,"
The reason is that promises do not provide a way to call their
constructor multiple times"
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,"For example:
const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
Given a reference to `promiseForA`, there's no way to call `fetchA`
again"
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,"Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener"
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,"
In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor"
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,"That gives us
the ability to call the constructor multiple times"
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,E.g
95,MDY6Q29tbWl0MTAyNzAyNTA6ZDk2NTllNDk5ZWJhMzA4OWIwOThjMzJjZjExMmI3YTA2N2JkZGRmMQ==,Andrew Clark,GitHub,"Lazy components must use React.lazy (#13885)

Removes support for using arbitrary promises as the type of a React
element. Instead, promises must be wrapped in React.lazy. This gives us
flexibility later if we need to change the protocol.

The reason is that promises do not provide a way to call their
constructor multiple times. For example:

const promiseForA = new Promise(resolve => {
  fetchA(a => resolve(a));
});

Given a reference to `promiseForA`, there's no way to call `fetchA`
again. Calling `then` on the promise doesn't run the constructor again;
it only attaches another listener.

In the future we will likely introduce an API like `React.eager` that
is similar to `lazy` but eagerly calls the constructor. That gives us
the ability to call the constructor multiple times. E.g. to increase
the priority, or to retry if the first operation failed.",https://api.github.com/repos/facebook/react/git/commits/d9659e499eba3089b098c32cf112b7a067bdddf1,2018-10-19,"to increase
the priority, or to retry if the first operation failed."
96,MDY6Q29tbWl0MTAyNzAyNTA6OGFmNjcyOGM2ZjEwNWQzN2Y5YzAwMDYyODhhNmQxYWMzOTAzZGM3MQ==,Dan Abramov,GitHub,"Enable Suspense + rename Placeholder (#13799)

* Enable Suspense

* <unstable_Placeholder delayMs> => <unstable_Suspense maxDuration>

* Update suspense fixture",https://api.github.com/repos/facebook/react/git/commits/8af6728c6f105d37f9c0006288a6d1ac3903dc71,2018-10-10,Enable Suspense + rename Placeholder (#13799)
96,MDY6Q29tbWl0MTAyNzAyNTA6OGFmNjcyOGM2ZjEwNWQzN2Y5YzAwMDYyODhhNmQxYWMzOTAzZGM3MQ==,Dan Abramov,GitHub,"Enable Suspense + rename Placeholder (#13799)

* Enable Suspense

* <unstable_Placeholder delayMs> => <unstable_Suspense maxDuration>

* Update suspense fixture",https://api.github.com/repos/facebook/react/git/commits/8af6728c6f105d37f9c0006288a6d1ac3903dc71,2018-10-10,
97,MDY6Q29tbWl0MTAyNzAyNTA6NDBhNTIxYWE3MjQ3ODcyZDAwODBkNWE1ODExMjBiNjQ5OTgxNTJkYQ==,Dan Abramov,GitHub,"Terminology: Functional -> Function Component (#13775)

* Terminology: Functional -> Function Component

* Drop the ""stateless"" (functions are already stateless, right?)",https://api.github.com/repos/facebook/react/git/commits/40a521aa7247872d0080d5a581120b64998152da,2018-10-04,Terminology: Functional -> Function Component (#13775)
97,MDY6Q29tbWl0MTAyNzAyNTA6NDBhNTIxYWE3MjQ3ODcyZDAwODBkNWE1ODExMjBiNjQ5OTgxNTJkYQ==,Dan Abramov,GitHub,"Terminology: Functional -> Function Component (#13775)

* Terminology: Functional -> Function Component

* Drop the ""stateless"" (functions are already stateless, right?)",https://api.github.com/repos/facebook/react/git/commits/40a521aa7247872d0080d5a581120b64998152da,2018-10-04,
98,MDY6Q29tbWl0MTAyNzAyNTA6YTA3MzNmZTEzZDU5ODMwM2Y0NWI5ZDI3Yzg0Y2UwZWM0MGQwOTAyMQ==,Andrew Clark,GitHub,"pure (#13748)

* pure

A higher-order component version of the `React.PureComponent` class.
During an update, the previous props are compared to the new props. If
they are the same, React will skip rendering the component and
its children.

Unlike userspace implementations, `pure` will not add an additional
fiber to the tree.

The first argument must be a functional component; it does not work
with classes.

`pure` uses shallow comparison by default, like `React.PureComponent`.
A custom comparison can be passed as the second argument.

Co-authored-by: Andrew Clark <acdlite@fb.com>
Co-authored-by: Sophie Alpert <sophiebits@fb.com>

* Warn if first argument is not a functional component",https://api.github.com/repos/facebook/react/git/commits/a0733fe13d598303f45b9d27c84ce0ec40d09021,2018-09-27,pure (#13748)
98,MDY6Q29tbWl0MTAyNzAyNTA6YTA3MzNmZTEzZDU5ODMwM2Y0NWI5ZDI3Yzg0Y2UwZWM0MGQwOTAyMQ==,Andrew Clark,GitHub,"pure (#13748)

* pure

A higher-order component version of the `React.PureComponent` class.
During an update, the previous props are compared to the new props. If
they are the same, React will skip rendering the component and
its children.

Unlike userspace implementations, `pure` will not add an additional
fiber to the tree.

The first argument must be a functional component; it does not work
with classes.

`pure` uses shallow comparison by default, like `React.PureComponent`.
A custom comparison can be passed as the second argument.

Co-authored-by: Andrew Clark <acdlite@fb.com>
Co-authored-by: Sophie Alpert <sophiebits@fb.com>

* Warn if first argument is not a functional component",https://api.github.com/repos/facebook/react/git/commits/a0733fe13d598303f45b9d27c84ce0ec40d09021,2018-09-27,A higher-order component version of the `React.PureComponent` class
98,MDY6Q29tbWl0MTAyNzAyNTA6YTA3MzNmZTEzZDU5ODMwM2Y0NWI5ZDI3Yzg0Y2UwZWM0MGQwOTAyMQ==,Andrew Clark,GitHub,"pure (#13748)

* pure

A higher-order component version of the `React.PureComponent` class.
During an update, the previous props are compared to the new props. If
they are the same, React will skip rendering the component and
its children.

Unlike userspace implementations, `pure` will not add an additional
fiber to the tree.

The first argument must be a functional component; it does not work
with classes.

`pure` uses shallow comparison by default, like `React.PureComponent`.
A custom comparison can be passed as the second argument.

Co-authored-by: Andrew Clark <acdlite@fb.com>
Co-authored-by: Sophie Alpert <sophiebits@fb.com>

* Warn if first argument is not a functional component",https://api.github.com/repos/facebook/react/git/commits/a0733fe13d598303f45b9d27c84ce0ec40d09021,2018-09-27,"
During an update, the previous props are compared to the new props"
98,MDY6Q29tbWl0MTAyNzAyNTA6YTA3MzNmZTEzZDU5ODMwM2Y0NWI5ZDI3Yzg0Y2UwZWM0MGQwOTAyMQ==,Andrew Clark,GitHub,"pure (#13748)

* pure

A higher-order component version of the `React.PureComponent` class.
During an update, the previous props are compared to the new props. If
they are the same, React will skip rendering the component and
its children.

Unlike userspace implementations, `pure` will not add an additional
fiber to the tree.

The first argument must be a functional component; it does not work
with classes.

`pure` uses shallow comparison by default, like `React.PureComponent`.
A custom comparison can be passed as the second argument.

Co-authored-by: Andrew Clark <acdlite@fb.com>
Co-authored-by: Sophie Alpert <sophiebits@fb.com>

* Warn if first argument is not a functional component",https://api.github.com/repos/facebook/react/git/commits/a0733fe13d598303f45b9d27c84ce0ec40d09021,2018-09-27,"If
they are the same, React will skip rendering the component and
its children"
98,MDY6Q29tbWl0MTAyNzAyNTA6YTA3MzNmZTEzZDU5ODMwM2Y0NWI5ZDI3Yzg0Y2UwZWM0MGQwOTAyMQ==,Andrew Clark,GitHub,"pure (#13748)

* pure

A higher-order component version of the `React.PureComponent` class.
During an update, the previous props are compared to the new props. If
they are the same, React will skip rendering the component and
its children.

Unlike userspace implementations, `pure` will not add an additional
fiber to the tree.

The first argument must be a functional component; it does not work
with classes.

`pure` uses shallow comparison by default, like `React.PureComponent`.
A custom comparison can be passed as the second argument.

Co-authored-by: Andrew Clark <acdlite@fb.com>
Co-authored-by: Sophie Alpert <sophiebits@fb.com>

* Warn if first argument is not a functional component",https://api.github.com/repos/facebook/react/git/commits/a0733fe13d598303f45b9d27c84ce0ec40d09021,2018-09-27,"
Unlike userspace implementations, `pure` will not add an additional
fiber to the tree"
98,MDY6Q29tbWl0MTAyNzAyNTA6YTA3MzNmZTEzZDU5ODMwM2Y0NWI5ZDI3Yzg0Y2UwZWM0MGQwOTAyMQ==,Andrew Clark,GitHub,"pure (#13748)

* pure

A higher-order component version of the `React.PureComponent` class.
During an update, the previous props are compared to the new props. If
they are the same, React will skip rendering the component and
its children.

Unlike userspace implementations, `pure` will not add an additional
fiber to the tree.

The first argument must be a functional component; it does not work
with classes.

`pure` uses shallow comparison by default, like `React.PureComponent`.
A custom comparison can be passed as the second argument.

Co-authored-by: Andrew Clark <acdlite@fb.com>
Co-authored-by: Sophie Alpert <sophiebits@fb.com>

* Warn if first argument is not a functional component",https://api.github.com/repos/facebook/react/git/commits/a0733fe13d598303f45b9d27c84ce0ec40d09021,2018-09-27,"
The first argument must be a functional component; it does not work
with classes"
98,MDY6Q29tbWl0MTAyNzAyNTA6YTA3MzNmZTEzZDU5ODMwM2Y0NWI5ZDI3Yzg0Y2UwZWM0MGQwOTAyMQ==,Andrew Clark,GitHub,"pure (#13748)

* pure

A higher-order component version of the `React.PureComponent` class.
During an update, the previous props are compared to the new props. If
they are the same, React will skip rendering the component and
its children.

Unlike userspace implementations, `pure` will not add an additional
fiber to the tree.

The first argument must be a functional component; it does not work
with classes.

`pure` uses shallow comparison by default, like `React.PureComponent`.
A custom comparison can be passed as the second argument.

Co-authored-by: Andrew Clark <acdlite@fb.com>
Co-authored-by: Sophie Alpert <sophiebits@fb.com>

* Warn if first argument is not a functional component",https://api.github.com/repos/facebook/react/git/commits/a0733fe13d598303f45b9d27c84ce0ec40d09021,2018-09-27,"
`pure` uses shallow comparison by default, like `React.PureComponent`"
98,MDY6Q29tbWl0MTAyNzAyNTA6YTA3MzNmZTEzZDU5ODMwM2Y0NWI5ZDI3Yzg0Y2UwZWM0MGQwOTAyMQ==,Andrew Clark,GitHub,"pure (#13748)

* pure

A higher-order component version of the `React.PureComponent` class.
During an update, the previous props are compared to the new props. If
they are the same, React will skip rendering the component and
its children.

Unlike userspace implementations, `pure` will not add an additional
fiber to the tree.

The first argument must be a functional component; it does not work
with classes.

`pure` uses shallow comparison by default, like `React.PureComponent`.
A custom comparison can be passed as the second argument.

Co-authored-by: Andrew Clark <acdlite@fb.com>
Co-authored-by: Sophie Alpert <sophiebits@fb.com>

* Warn if first argument is not a functional component",https://api.github.com/repos/facebook/react/git/commits/a0733fe13d598303f45b9d27c84ce0ec40d09021,2018-09-27,"
A custom comparison can be passed as the second argument"
98,MDY6Q29tbWl0MTAyNzAyNTA6YTA3MzNmZTEzZDU5ODMwM2Y0NWI5ZDI3Yzg0Y2UwZWM0MGQwOTAyMQ==,Andrew Clark,GitHub,"pure (#13748)

* pure

A higher-order component version of the `React.PureComponent` class.
During an update, the previous props are compared to the new props. If
they are the same, React will skip rendering the component and
its children.

Unlike userspace implementations, `pure` will not add an additional
fiber to the tree.

The first argument must be a functional component; it does not work
with classes.

`pure` uses shallow comparison by default, like `React.PureComponent`.
A custom comparison can be passed as the second argument.

Co-authored-by: Andrew Clark <acdlite@fb.com>
Co-authored-by: Sophie Alpert <sophiebits@fb.com>

* Warn if first argument is not a functional component",https://api.github.com/repos/facebook/react/git/commits/a0733fe13d598303f45b9d27c84ce0ec40d09021,2018-09-27,"
Co-authored-by: Andrew Clark <acdlite@fb.com>
Co-authored-by: Sophie Alpert <sophiebits@fb.com>"
99,MDY6Q29tbWl0MTAyNzAyNTA6MGRjMGRkYzFlZjVmOTBmZTQ4YjU4ZjFhMWJhNzUzNzU3OTYxZmM3NA==,Dominic Gannaway,GitHub,"Rename AsyncMode -> ConcurrentMode (#13732)

* Rename AsyncMode -> ConcurrentMode",https://api.github.com/repos/facebook/react/git/commits/0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74,2018-09-26,Rename AsyncMode -> ConcurrentMode (#13732)
99,MDY6Q29tbWl0MTAyNzAyNTA6MGRjMGRkYzFlZjVmOTBmZTQ4YjU4ZjFhMWJhNzUzNzU3OTYxZmM3NA==,Dominic Gannaway,GitHub,"Rename AsyncMode -> ConcurrentMode (#13732)

* Rename AsyncMode -> ConcurrentMode",https://api.github.com/repos/facebook/react/git/commits/0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74,2018-09-26,
100,MDY6Q29tbWl0MTAyNzAyNTA6NGE0MGQ3NjI0NTc1ZDAzMGUyZDJhYTk4YjI0MDAwZTU5YTllNGYwMg==,Dan Abramov,GitHub,Fix a regression related to isReactComponent prototype check (#13608),https://api.github.com/repos/facebook/react/git/commits/4a40d7624575d030e2d2aa98b24000e59a9e4f02,2018-09-10,Fix a regression related to isReactComponent prototype check (#13608)
100,MDY6Q29tbWl0MTAyNzAyNTA6NGE0MGQ3NjI0NTc1ZDAzMGUyZDJhYTk4YjI0MDAwZTU5YTllNGYwMg==,Dan Abramov,GitHub,Fix a regression related to isReactComponent prototype check (#13608),https://api.github.com/repos/facebook/react/git/commits/4a40d7624575d030e2d2aa98b24000e59a9e4f02,2018-09-10,
101,MDY6Q29tbWl0MTAyNzAyNTA6Yjg3YWFiZGZlMWI3NDYxZTczMzFhYmIzNjAxZDllNmJiMjc1NDRiYw==,Héctor Ramos,GitHub,Drop the year from Facebook copyright headers and the LICENSE file. (#13593),https://api.github.com/repos/facebook/react/git/commits/b87aabdfe1b7461e7331abb3601d9e6bb27544bc,2018-09-07,Drop the year from Facebook copyright headers and the LICENSE file. (#13593)
101,MDY6Q29tbWl0MTAyNzAyNTA6Yjg3YWFiZGZlMWI3NDYxZTczMzFhYmIzNjAxZDllNmJiMjc1NDRiYw==,Héctor Ramos,GitHub,Drop the year from Facebook copyright headers and the LICENSE file. (#13593),https://api.github.com/repos/facebook/react/git/commits/b87aabdfe1b7461e7331abb3601d9e6bb27544bc,2018-09-07,
102,MDY6Q29tbWl0MTAyNzAyNTA6NmU0ZjdjNzg4NjAzZGFjN2ZjY2QyMjdhNDg1MmMxMTBiMDcyZmUxNg==,Brian Vaughn,GitHub,"Profiler integration with interaction-tracking package (#13253)

* Updated suspense fixture to use new interaction-tracking API

* Integrated Profiler API with interaction-tracking API (and added tests)

* Pass interaction Set (rather than Array) to Profiler onRender callback

* Removed some :any casts for enableInteractionTracking fields in FiberRoot type

* Refactored threadID calculation into a helper method

* Errors thrown by interaction tracking hooks use unhandledError to rethrow more safely.
Reverted try/finally change to ReactTestRendererScheduling

* Added a $FlowFixMe above the FiberRoot :any cast

* Reduce overhead from calling work-started hook

* Remove interaction-tracking wrap() references from unwind work in favor of managing suspense/interaction continuations in the scheduler
* Moved the logic for calling work-started hook from performWorkOnRoot() to renderRoot()

* Add interaction-tracking to bundle externals. Set feature flag to __PROFILE__

* Renamed the freezeInteractionCount flag and replaced one use-case with a method param

* let -> const

* Updated suspense fixture to handle recent API changes",https://api.github.com/repos/facebook/react/git/commits/6e4f7c788603dac7fccd227a4852c110b072fe16,2018-08-29,Profiler integration with interaction-tracking package (#13253)
102,MDY6Q29tbWl0MTAyNzAyNTA6NmU0ZjdjNzg4NjAzZGFjN2ZjY2QyMjdhNDg1MmMxMTBiMDcyZmUxNg==,Brian Vaughn,GitHub,"Profiler integration with interaction-tracking package (#13253)

* Updated suspense fixture to use new interaction-tracking API

* Integrated Profiler API with interaction-tracking API (and added tests)

* Pass interaction Set (rather than Array) to Profiler onRender callback

* Removed some :any casts for enableInteractionTracking fields in FiberRoot type

* Refactored threadID calculation into a helper method

* Errors thrown by interaction tracking hooks use unhandledError to rethrow more safely.
Reverted try/finally change to ReactTestRendererScheduling

* Added a $FlowFixMe above the FiberRoot :any cast

* Reduce overhead from calling work-started hook

* Remove interaction-tracking wrap() references from unwind work in favor of managing suspense/interaction continuations in the scheduler
* Moved the logic for calling work-started hook from performWorkOnRoot() to renderRoot()

* Add interaction-tracking to bundle externals. Set feature flag to __PROFILE__

* Renamed the freezeInteractionCount flag and replaced one use-case with a method param

* let -> const

* Updated suspense fixture to handle recent API changes",https://api.github.com/repos/facebook/react/git/commits/6e4f7c788603dac7fccd227a4852c110b072fe16,2018-08-29,"Reverted try/finally change to ReactTestRendererScheduling"
103,MDY6Q29tbWl0MTAyNzAyNTA6MzQwYmZkOTM5M2U4MTczYWRjYTUzODBlNjU4N2UxZWExYTIzY2VmYQ==,Sophie Alpert,GitHub,"Rename ReactTypeOfWork to ReactWorkTags, ReactTypeOfSideEffect to ReactSideEffectTags (#13476)

* Rename ReactTypeOfWork to ReactWorkTags

And `type TypeOfWork` to `type WorkTag`.

* Rename ReactTypeOfSideEffect too",https://api.github.com/repos/facebook/react/git/commits/340bfd9393e8173adca5380e6587e1ea1a23cefa,2018-08-26,"Rename ReactTypeOfWork to ReactWorkTags, ReactTypeOfSideEffect to ReactSideEffectTags (#13476)"
103,MDY6Q29tbWl0MTAyNzAyNTA6MzQwYmZkOTM5M2U4MTczYWRjYTUzODBlNjU4N2UxZWExYTIzY2VmYQ==,Sophie Alpert,GitHub,"Rename ReactTypeOfWork to ReactWorkTags, ReactTypeOfSideEffect to ReactSideEffectTags (#13476)

* Rename ReactTypeOfWork to ReactWorkTags

And `type TypeOfWork` to `type WorkTag`.

* Rename ReactTypeOfSideEffect too",https://api.github.com/repos/facebook/react/git/commits/340bfd9393e8173adca5380e6587e1ea1a23cefa,2018-08-26,And `type TypeOfWork` to `type WorkTag`
103,MDY6Q29tbWl0MTAyNzAyNTA6MzQwYmZkOTM5M2U4MTczYWRjYTUzODBlNjU4N2UxZWExYTIzY2VmYQ==,Sophie Alpert,GitHub,"Rename ReactTypeOfWork to ReactWorkTags, ReactTypeOfSideEffect to ReactSideEffectTags (#13476)

* Rename ReactTypeOfWork to ReactWorkTags

And `type TypeOfWork` to `type WorkTag`.

* Rename ReactTypeOfSideEffect too",https://api.github.com/repos/facebook/react/git/commits/340bfd9393e8173adca5380e6587e1ea1a23cefa,2018-08-26,
104,MDY6Q29tbWl0MTAyNzAyNTA6MmIzMDgyODAwMGE1OGVhZjZhZGZjM2JhMmNiZWRkNGJmZjRkMDc3Yg==,Andrew Clark,Andrew Clark,Fix wrong Flow return type,https://api.github.com/repos/facebook/react/git/commits/2b30828000a58eaf6adfc3ba2cbedd4bff4d077b,2018-08-16,Fix wrong Flow return type
104,MDY6Q29tbWl0MTAyNzAyNTA6MmIzMDgyODAwMGE1OGVhZjZhZGZjM2JhMmNiZWRkNGJmZjRkMDc3Yg==,Andrew Clark,Andrew Clark,Fix wrong Flow return type,https://api.github.com/repos/facebook/react/git/commits/2b30828000a58eaf6adfc3ba2cbedd4bff4d077b,2018-08-16,
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,Accept promise as element type (#13397)
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"
When the promise resolves, rendering resumes"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"If it does not have
a `default` property, we use the resolved value itself"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"
The resolved value is stored as an expando on the promise/thenable"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"
Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"
The other types are not supported, but wouldn't be placed into a
separate module regardless"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"
isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,We should get rid of it
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"I
removed some of them in the previous commit, and deleted a few more
in this one"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"
The caller compares the result to baseProps to see if anything changed"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"
We should do this with all types of work in the future"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,"
Removes unnecessary checks"
105,MDY6Q29tbWl0MTAyNzAyNTA6NTAzMWViZjZiZWRkZjg4Y2FjMTVmNGQyYzllOTFmOGRiYjkxZDU5ZA==,Andrew Clark,GitHub,"Accept promise as element type (#13397)

* Accept promise as element type

On the initial render, the element will suspend as if a promise were
thrown from inside the body of the unresolved component. Siblings should
continue rendering and if the parent is a Placeholder, the promise
should be captured by that Placeholder.

When the promise resolves, rendering resumes. If the resolved value
has a `default` property, it is assumed to be the default export of
an ES module, and we use that as the component type. If it does not have
a `default` property, we use the resolved value itself.

The resolved value is stored as an expando on the promise/thenable.

* Use special types of work for lazy components

Because reconciliation is a hot path, this adds ClassComponentLazy,
FunctionalComponentLazy, and ForwardRefLazy as special types of work.
The other types are not supported, but wouldn't be placed into a
separate module regardless.

* Resolve defaultProps for lazy types

* Remove some calls to isContextProvider

isContextProvider checks the fiber tag, but it's typically called after
we've already refined the type of work. We should get rid of it. I
removed some of them in the previous commit, and deleted a few more
in this one. I left a few behind because the remaining ones would
require additional refactoring that feels outside the scope of this PR.

* Remove getLazyComponentTypeIfResolved

* Return baseProps instead of null

The caller compares the result to baseProps to see if anything changed.

* Avoid redundant checks by inlining getFiberTagFromObjectType

* Move tag resolution to ReactFiber module

* Pass next props to update* functions

We should do this with all types of work in the future.

* Refine component type before pushing/popping context

Removes unnecessary checks.

* Replace all occurrences of _reactResult with helper

* Move shared thenable logic to `shared` package

* Check type of wrapper object before resolving to `default` export

* Return resolved tag instead of reassigning",https://api.github.com/repos/facebook/react/git/commits/5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d,2018-08-16,
106,MDY6Q29tbWl0MTAyNzAyNTA6MDY3Y2MyNGY1NWVmMDFhMjMzYmU5ZTc1NjRiMzM3ZTM1ZmVkNzJlYQ==,Brian Vaughn,GitHub,"Profiler actualDuration bugfix (#13313)

* Simplified profiler actualDuration timing

While testing the new DevTools profiler, I noticed that sometimes– in larger, more complicated applications– the actualDuration value was incorrect (either too large, or sometimes negative). I was not able to reproduce this in a smaller application or test (which sucks) but I assume it has something to do with the way I was tracking render times across priorities/roots. So this PR replaces the previous approach with a simpler one.

* Changed bubbling logic after chatting out of band with Andrew

* Replaced __PROFILE__ with feature-flag conditionals in test

* Updated test comment",https://api.github.com/repos/facebook/react/git/commits/067cc24f55ef01a233be9e7564b337e35fed72ea,2018-08-08,Profiler actualDuration bugfix (#13313)
106,MDY6Q29tbWl0MTAyNzAyNTA6MDY3Y2MyNGY1NWVmMDFhMjMzYmU5ZTc1NjRiMzM3ZTM1ZmVkNzJlYQ==,Brian Vaughn,GitHub,"Profiler actualDuration bugfix (#13313)

* Simplified profiler actualDuration timing

While testing the new DevTools profiler, I noticed that sometimes– in larger, more complicated applications– the actualDuration value was incorrect (either too large, or sometimes negative). I was not able to reproduce this in a smaller application or test (which sucks) but I assume it has something to do with the way I was tracking render times across priorities/roots. So this PR replaces the previous approach with a simpler one.

* Changed bubbling logic after chatting out of band with Andrew

* Replaced __PROFILE__ with feature-flag conditionals in test

* Updated test comment",https://api.github.com/repos/facebook/react/git/commits/067cc24f55ef01a233be9e7564b337e35fed72ea,2018-08-08,"While testing the new DevTools profiler, I noticed that sometimes– in larger, more complicated applications– the actualDuration value was incorrect (either too large, or sometimes negative)"
106,MDY6Q29tbWl0MTAyNzAyNTA6MDY3Y2MyNGY1NWVmMDFhMjMzYmU5ZTc1NjRiMzM3ZTM1ZmVkNzJlYQ==,Brian Vaughn,GitHub,"Profiler actualDuration bugfix (#13313)

* Simplified profiler actualDuration timing

While testing the new DevTools profiler, I noticed that sometimes– in larger, more complicated applications– the actualDuration value was incorrect (either too large, or sometimes negative). I was not able to reproduce this in a smaller application or test (which sucks) but I assume it has something to do with the way I was tracking render times across priorities/roots. So this PR replaces the previous approach with a simpler one.

* Changed bubbling logic after chatting out of band with Andrew

* Replaced __PROFILE__ with feature-flag conditionals in test

* Updated test comment",https://api.github.com/repos/facebook/react/git/commits/067cc24f55ef01a233be9e7564b337e35fed72ea,2018-08-08,I was not able to reproduce this in a smaller application or test (which sucks) but I assume it has something to do with the way I was tracking render times across priorities/roots
106,MDY6Q29tbWl0MTAyNzAyNTA6MDY3Y2MyNGY1NWVmMDFhMjMzYmU5ZTc1NjRiMzM3ZTM1ZmVkNzJlYQ==,Brian Vaughn,GitHub,"Profiler actualDuration bugfix (#13313)

* Simplified profiler actualDuration timing

While testing the new DevTools profiler, I noticed that sometimes– in larger, more complicated applications– the actualDuration value was incorrect (either too large, or sometimes negative). I was not able to reproduce this in a smaller application or test (which sucks) but I assume it has something to do with the way I was tracking render times across priorities/roots. So this PR replaces the previous approach with a simpler one.

* Changed bubbling logic after chatting out of band with Andrew

* Replaced __PROFILE__ with feature-flag conditionals in test

* Updated test comment",https://api.github.com/repos/facebook/react/git/commits/067cc24f55ef01a233be9e7564b337e35fed72ea,2018-08-08,So this PR replaces the previous approach with a simpler one
106,MDY6Q29tbWl0MTAyNzAyNTA6MDY3Y2MyNGY1NWVmMDFhMjMzYmU5ZTc1NjRiMzM3ZTM1ZmVkNzJlYQ==,Brian Vaughn,GitHub,"Profiler actualDuration bugfix (#13313)

* Simplified profiler actualDuration timing

While testing the new DevTools profiler, I noticed that sometimes– in larger, more complicated applications– the actualDuration value was incorrect (either too large, or sometimes negative). I was not able to reproduce this in a smaller application or test (which sucks) but I assume it has something to do with the way I was tracking render times across priorities/roots. So this PR replaces the previous approach with a simpler one.

* Changed bubbling logic after chatting out of band with Andrew

* Replaced __PROFILE__ with feature-flag conditionals in test

* Updated test comment",https://api.github.com/repos/facebook/react/git/commits/067cc24f55ef01a233be9e7564b337e35fed72ea,2018-08-08,
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,[Experimental] API for reading context from within any render phase function (#13139)
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"Currently, context can only be read by a special type of component,
ContextConsumer"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"We want to add support to all fibers, including
classes and functional components"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"
Each fiber may read from one or more contexts"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"To enable quick, mono-
morphic access of this list, we'll store them on a fiber property"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"
unstable_read can be called anywhere within the render phase"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"
If it's called outside the render phase, an error is thrown"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"
Wasn't being used"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"
Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"
This commit adds a second field called `childExpirationTime`"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"Now
`expirationTime` only represents the pending work of the fiber itself"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"
The subtree's pending work is represented by `childExpirationTime`"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"
The biggest advantage is it requires fewer checks to bailout on already
finished work"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly"
107,MDY6Q29tbWl0MTAyNzAyNTA6MmI1MDllMmM4YzhjMWZiYzMzYWU1OWNlN2M3ZGNhMDEwNzczMmZmNA==,Andrew Clark,GitHub,"[Experimental] API for reading context from within any render phase function (#13139)

* Store list of contexts on the fiber

Currently, context can only be read by a special type of component,
ContextConsumer. We want to add support to all fibers, including
classes and functional components.

Each fiber may read from one or more contexts. To enable quick, mono-
morphic access of this list, we'll store them on a fiber property.

* Context.unstable_read

unstable_read can be called anywhere within the render phase. That
includes the render method, getDerivedStateFromProps, constructors,
functional components, and context consumer render props.

If it's called outside the render phase, an error is thrown.

* Remove vestigial context cursor

Wasn't being used.

* Split fiber.expirationTime into two separate fields

Currently, the `expirationTime` field represents the pending work of
both the fiber itself — including new props, state, and context — and of
any updates in that fiber's subtree.

This commit adds a second field called `childExpirationTime`. Now
`expirationTime` only represents the pending work of the fiber itself.
The subtree's pending work is represented by `childExpirationTime`.

The biggest advantage is it requires fewer checks to bailout on already
finished work. For most types of work, if the `expirationTime` does not
match the render expiration time, we can bailout immediately without
any further checks. This won't work for fibers that have
`shouldComponentUpdate` semantics (class components), for which we still
need to check for props and state changes explicitly.

* Performance nits

Optimize `readContext` for most common case",https://api.github.com/repos/facebook/react/git/commits/2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4,2018-07-20,"
Optimize `readContext` for most common case"
108,MDY6Q29tbWl0MTAyNzAyNTA6ZTYwNzZlY2Y0OGY1ZTQ5MmU4OTRhNWJjM2Y2MDliMDQ3ODM4OGI4MA==,Dan Abramov,Brian Vaughn,"Remove ad-hoc forks of getComponentName() and fix it (#13197)

* Fix getComponentName() for types with nested $$typeof

* Temporarily remove Profiler ID from messages

* Change getComponentName() signature to take just type

It doesn't actually need the whole Fiber.

* Remove getComponentName() forks in isomorphic and SSR

* Remove unnecessary .type access where we already have a type

* Remove unused type",https://api.github.com/repos/facebook/react/git/commits/e6076ecf48f5e492e894a5bc3f609b0478388b80,2018-07-12,Remove ad-hoc forks of getComponentName() and fix it (#13197)
108,MDY6Q29tbWl0MTAyNzAyNTA6ZTYwNzZlY2Y0OGY1ZTQ5MmU4OTRhNWJjM2Y2MDliMDQ3ODM4OGI4MA==,Dan Abramov,Brian Vaughn,"Remove ad-hoc forks of getComponentName() and fix it (#13197)

* Fix getComponentName() for types with nested $$typeof

* Temporarily remove Profiler ID from messages

* Change getComponentName() signature to take just type

It doesn't actually need the whole Fiber.

* Remove getComponentName() forks in isomorphic and SSR

* Remove unnecessary .type access where we already have a type

* Remove unused type",https://api.github.com/repos/facebook/react/git/commits/e6076ecf48f5e492e894a5bc3f609b0478388b80,2018-07-12,It doesn't actually need the whole Fiber
108,MDY6Q29tbWl0MTAyNzAyNTA6ZTYwNzZlY2Y0OGY1ZTQ5MmU4OTRhNWJjM2Y2MDliMDQ3ODM4OGI4MA==,Dan Abramov,Brian Vaughn,"Remove ad-hoc forks of getComponentName() and fix it (#13197)

* Fix getComponentName() for types with nested $$typeof

* Temporarily remove Profiler ID from messages

* Change getComponentName() signature to take just type

It doesn't actually need the whole Fiber.

* Remove getComponentName() forks in isomorphic and SSR

* Remove unnecessary .type access where we already have a type

* Remove unused type",https://api.github.com/repos/facebook/react/git/commits/e6076ecf48f5e492e894a5bc3f609b0478388b80,2018-07-12,
109,MDY6Q29tbWl0MTAyNzAyNTA6NmY2YjU2MGE2NDVhZGI1OTViYTFlNDA2MzBhMzkxNWQ4YWJkZjAzOA==,Brian Vaughn,GitHub,"Renamed selfBaseTime/treeBaseTime Fiber attributes to selfBaseDuration/treeBaseDuration (#13156)

This is an unobservable change to all but the (under development) DevTools Profiler plugin. It is being done so that the plugin can safely feature detect a version of React that supports it. The profiler API has existed since the 16.4.0 release, but it did not support the DevTools plugin prior to PR #13058.

Side note: I am not a big fan of the term ""base duration"". Both it and ""actual duration"" are kind of awkward and vague. If anyone has suggestions for better names– this is the best time to bikeshed about them.",https://api.github.com/repos/facebook/react/git/commits/6f6b560a645adb595ba1e40630a3915d8abdf038,2018-07-06,Renamed selfBaseTime/treeBaseTime Fiber attributes to selfBaseDuration/treeBaseDuration (#13156)
109,MDY6Q29tbWl0MTAyNzAyNTA6NmY2YjU2MGE2NDVhZGI1OTViYTFlNDA2MzBhMzkxNWQ4YWJkZjAzOA==,Brian Vaughn,GitHub,"Renamed selfBaseTime/treeBaseTime Fiber attributes to selfBaseDuration/treeBaseDuration (#13156)

This is an unobservable change to all but the (under development) DevTools Profiler plugin. It is being done so that the plugin can safely feature detect a version of React that supports it. The profiler API has existed since the 16.4.0 release, but it did not support the DevTools plugin prior to PR #13058.

Side note: I am not a big fan of the term ""base duration"". Both it and ""actual duration"" are kind of awkward and vague. If anyone has suggestions for better names– this is the best time to bikeshed about them.",https://api.github.com/repos/facebook/react/git/commits/6f6b560a645adb595ba1e40630a3915d8abdf038,2018-07-06,This is an unobservable change to all but the (under development) DevTools Profiler plugin
109,MDY6Q29tbWl0MTAyNzAyNTA6NmY2YjU2MGE2NDVhZGI1OTViYTFlNDA2MzBhMzkxNWQ4YWJkZjAzOA==,Brian Vaughn,GitHub,"Renamed selfBaseTime/treeBaseTime Fiber attributes to selfBaseDuration/treeBaseDuration (#13156)

This is an unobservable change to all but the (under development) DevTools Profiler plugin. It is being done so that the plugin can safely feature detect a version of React that supports it. The profiler API has existed since the 16.4.0 release, but it did not support the DevTools plugin prior to PR #13058.

Side note: I am not a big fan of the term ""base duration"". Both it and ""actual duration"" are kind of awkward and vague. If anyone has suggestions for better names– this is the best time to bikeshed about them.",https://api.github.com/repos/facebook/react/git/commits/6f6b560a645adb595ba1e40630a3915d8abdf038,2018-07-06,It is being done so that the plugin can safely feature detect a version of React that supports it
109,MDY6Q29tbWl0MTAyNzAyNTA6NmY2YjU2MGE2NDVhZGI1OTViYTFlNDA2MzBhMzkxNWQ4YWJkZjAzOA==,Brian Vaughn,GitHub,"Renamed selfBaseTime/treeBaseTime Fiber attributes to selfBaseDuration/treeBaseDuration (#13156)

This is an unobservable change to all but the (under development) DevTools Profiler plugin. It is being done so that the plugin can safely feature detect a version of React that supports it. The profiler API has existed since the 16.4.0 release, but it did not support the DevTools plugin prior to PR #13058.

Side note: I am not a big fan of the term ""base duration"". Both it and ""actual duration"" are kind of awkward and vague. If anyone has suggestions for better names– this is the best time to bikeshed about them.",https://api.github.com/repos/facebook/react/git/commits/6f6b560a645adb595ba1e40630a3915d8abdf038,2018-07-06,"The profiler API has existed since the 16.4.0 release, but it did not support the DevTools plugin prior to PR #13058"
109,MDY6Q29tbWl0MTAyNzAyNTA6NmY2YjU2MGE2NDVhZGI1OTViYTFlNDA2MzBhMzkxNWQ4YWJkZjAzOA==,Brian Vaughn,GitHub,"Renamed selfBaseTime/treeBaseTime Fiber attributes to selfBaseDuration/treeBaseDuration (#13156)

This is an unobservable change to all but the (under development) DevTools Profiler plugin. It is being done so that the plugin can safely feature detect a version of React that supports it. The profiler API has existed since the 16.4.0 release, but it did not support the DevTools plugin prior to PR #13058.

Side note: I am not a big fan of the term ""base duration"". Both it and ""actual duration"" are kind of awkward and vague. If anyone has suggestions for better names– this is the best time to bikeshed about them.",https://api.github.com/repos/facebook/react/git/commits/6f6b560a645adb595ba1e40630a3915d8abdf038,2018-07-06,"
Side note: I am not a big fan of the term ""base duration"""
109,MDY6Q29tbWl0MTAyNzAyNTA6NmY2YjU2MGE2NDVhZGI1OTViYTFlNDA2MzBhMzkxNWQ4YWJkZjAzOA==,Brian Vaughn,GitHub,"Renamed selfBaseTime/treeBaseTime Fiber attributes to selfBaseDuration/treeBaseDuration (#13156)

This is an unobservable change to all but the (under development) DevTools Profiler plugin. It is being done so that the plugin can safely feature detect a version of React that supports it. The profiler API has existed since the 16.4.0 release, but it did not support the DevTools plugin prior to PR #13058.

Side note: I am not a big fan of the term ""base duration"". Both it and ""actual duration"" are kind of awkward and vague. If anyone has suggestions for better names– this is the best time to bikeshed about them.",https://api.github.com/repos/facebook/react/git/commits/6f6b560a645adb595ba1e40630a3915d8abdf038,2018-07-06,"Both it and ""actual duration"" are kind of awkward and vague"
109,MDY6Q29tbWl0MTAyNzAyNTA6NmY2YjU2MGE2NDVhZGI1OTViYTFlNDA2MzBhMzkxNWQ4YWJkZjAzOA==,Brian Vaughn,GitHub,"Renamed selfBaseTime/treeBaseTime Fiber attributes to selfBaseDuration/treeBaseDuration (#13156)

This is an unobservable change to all but the (under development) DevTools Profiler plugin. It is being done so that the plugin can safely feature detect a version of React that supports it. The profiler API has existed since the 16.4.0 release, but it did not support the DevTools plugin prior to PR #13058.

Side note: I am not a big fan of the term ""base duration"". Both it and ""actual duration"" are kind of awkward and vague. If anyone has suggestions for better names– this is the best time to bikeshed about them.",https://api.github.com/repos/facebook/react/git/commits/6f6b560a645adb595ba1e40630a3915d8abdf038,2018-07-06,If anyone has suggestions for better names– this is the best time to bikeshed about them.
110,MDY6Q29tbWl0MTAyNzAyNTA6ODhkN2VkOGJmYmNjZDg2MGMzZTMwOWRhMzlkMzU2ZDBhMzEyN2FhNw==,Andrew Clark,GitHub,"React.Timeout -> React.Placeholder (#13105)

Changed the API to match what we've been using in our latest discussions.

Our tentative plans are for <Placeholder> to automatically hide the timed-out
children, instead of removing them, so their state is not lost. This part is
not yet implemented. We'll likely have a lower level API that does not include
the hiding behavior. This is also not yet implemented.",https://api.github.com/repos/facebook/react/git/commits/88d7ed8bfbccd860c3e309da39d356d0a3127aa7,2018-07-04,React.Timeout -> React.Placeholder (#13105)
110,MDY6Q29tbWl0MTAyNzAyNTA6ODhkN2VkOGJmYmNjZDg2MGMzZTMwOWRhMzlkMzU2ZDBhMzEyN2FhNw==,Andrew Clark,GitHub,"React.Timeout -> React.Placeholder (#13105)

Changed the API to match what we've been using in our latest discussions.

Our tentative plans are for <Placeholder> to automatically hide the timed-out
children, instead of removing them, so their state is not lost. This part is
not yet implemented. We'll likely have a lower level API that does not include
the hiding behavior. This is also not yet implemented.",https://api.github.com/repos/facebook/react/git/commits/88d7ed8bfbccd860c3e309da39d356d0a3127aa7,2018-07-04,Changed the API to match what we've been using in our latest discussions
110,MDY6Q29tbWl0MTAyNzAyNTA6ODhkN2VkOGJmYmNjZDg2MGMzZTMwOWRhMzlkMzU2ZDBhMzEyN2FhNw==,Andrew Clark,GitHub,"React.Timeout -> React.Placeholder (#13105)

Changed the API to match what we've been using in our latest discussions.

Our tentative plans are for <Placeholder> to automatically hide the timed-out
children, instead of removing them, so their state is not lost. This part is
not yet implemented. We'll likely have a lower level API that does not include
the hiding behavior. This is also not yet implemented.",https://api.github.com/repos/facebook/react/git/commits/88d7ed8bfbccd860c3e309da39d356d0a3127aa7,2018-07-04,"
Our tentative plans are for <Placeholder> to automatically hide the timed-out
children, instead of removing them, so their state is not lost"
110,MDY6Q29tbWl0MTAyNzAyNTA6ODhkN2VkOGJmYmNjZDg2MGMzZTMwOWRhMzlkMzU2ZDBhMzEyN2FhNw==,Andrew Clark,GitHub,"React.Timeout -> React.Placeholder (#13105)

Changed the API to match what we've been using in our latest discussions.

Our tentative plans are for <Placeholder> to automatically hide the timed-out
children, instead of removing them, so their state is not lost. This part is
not yet implemented. We'll likely have a lower level API that does not include
the hiding behavior. This is also not yet implemented.",https://api.github.com/repos/facebook/react/git/commits/88d7ed8bfbccd860c3e309da39d356d0a3127aa7,2018-07-04,"This part is
not yet implemented"
110,MDY6Q29tbWl0MTAyNzAyNTA6ODhkN2VkOGJmYmNjZDg2MGMzZTMwOWRhMzlkMzU2ZDBhMzEyN2FhNw==,Andrew Clark,GitHub,"React.Timeout -> React.Placeholder (#13105)

Changed the API to match what we've been using in our latest discussions.

Our tentative plans are for <Placeholder> to automatically hide the timed-out
children, instead of removing them, so their state is not lost. This part is
not yet implemented. We'll likely have a lower level API that does not include
the hiding behavior. This is also not yet implemented.",https://api.github.com/repos/facebook/react/git/commits/88d7ed8bfbccd860c3e309da39d356d0a3127aa7,2018-07-04,"We'll likely have a lower level API that does not include
the hiding behavior"
110,MDY6Q29tbWl0MTAyNzAyNTA6ODhkN2VkOGJmYmNjZDg2MGMzZTMwOWRhMzlkMzU2ZDBhMzEyN2FhNw==,Andrew Clark,GitHub,"React.Timeout -> React.Placeholder (#13105)

Changed the API to match what we've been using in our latest discussions.

Our tentative plans are for <Placeholder> to automatically hide the timed-out
children, instead of removing them, so their state is not lost. This part is
not yet implemented. We'll likely have a lower level API that does not include
the hiding behavior. This is also not yet implemented.",https://api.github.com/repos/facebook/react/git/commits/88d7ed8bfbccd860c3e309da39d356d0a3127aa7,2018-07-04,This is also not yet implemented.
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,Suspending outside of strict trees and async trees (#13098)
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"We can support components that suspend outside of an async mode tree
by immediately committing their placeholders"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"
In strict mode, the Timeout acts effectively like an error boundary"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"
Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"(Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least))"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"We need to be
clever"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"What we do is pretend the suspended component rendered null.*
There's no unwinding"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,The siblings commit like normal
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"
Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"Although this requires an extra
commit, it will not be observable"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"And because the siblings were not
blocked from committing, they don't have to be strict mode compatible"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"
Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"In other words, if any non-async component renders, the entire
tree must complete and commit without yielding"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,"
deleted"
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,We should hide them instead
111,MDY6Q29tbWl0MTAyNzAyNTA6ZjEyOGZkZWE0ODQwZjQ5NDk5MTA1NGY2MDhiOTk3NTdhNWNlNTc2NA==,Andrew Clark,GitHub,"Suspending outside of strict trees and async trees (#13098)

We can support components that suspend outside of an async mode tree
by immediately committing their placeholders.

In strict mode, the Timeout acts effectively like an error boundary.
Within a single render pass, we unwind to the nearest Timeout and
re-render the placeholder view.

Outside of strict mode, it's not safe to unwind and re-render the
siblings without committing. (Technically, this is true of error
boundaries, too, though probably not a huge deal, since we don't support
using error boundaries for control flow (yet, at least)). We need to be
clever. What we do is pretend the suspended component rendered null.*
There's no unwinding. The siblings commit like normal.

Then, in the commit phase, schedule an update on the Timeout to
synchronously re-render the placeholder. Although this requires an extra
commit, it will not be observable. And because the siblings were not
blocked from committing, they don't have to be strict mode compatible.

Another caveat is that if a component suspends during an async render,
but it's captured by a non-async Timeout, we need to revert to sync
mode. In other words, if any non-async component renders, the entire
tree must complete and commit without yielding.

* The downside of rendering null is that the existing children will be
deleted. We should hide them instead. I'll work on this in a follow-up.",https://api.github.com/repos/facebook/react/git/commits/f128fdea4840f494991054f608b99757a5ce5764,2018-07-04,I'll work on this in a follow-up.
112,MDY6Q29tbWl0MTAyNzAyNTA6YjBmNjA4OTVmNzU5MjUzZDQxODBkZmE3ZTE5MDFmZTM2ZDRhYmQzYQ==,Brian Vaughn,GitHub,"Automatically Profile roots when DevTools is present (#13058)

* react-test-renderer injects itself into DevTools if present
* Fibers are always opted into ProfileMode if DevTools is present
* Added simple test for DevTools + always profiling behavior",https://api.github.com/repos/facebook/react/git/commits/b0f60895f759253d4180dfa7e1901fe36d4abd3a,2018-06-20,Automatically Profile roots when DevTools is present (#13058)
112,MDY6Q29tbWl0MTAyNzAyNTA6YjBmNjA4OTVmNzU5MjUzZDQxODBkZmE3ZTE5MDFmZTM2ZDRhYmQzYQ==,Brian Vaughn,GitHub,"Automatically Profile roots when DevTools is present (#13058)

* react-test-renderer injects itself into DevTools if present
* Fibers are always opted into ProfileMode if DevTools is present
* Added simple test for DevTools + always profiling behavior",https://api.github.com/repos/facebook/react/git/commits/b0f60895f759253d4180dfa7e1901fe36d4abd3a,2018-06-20,
113,MDY6Q29tbWl0MTAyNzAyNTA6YWVkYTdiNzQ1ZDljMDgwMTUwNzA0ZmViMjBlYTU3NjIzOGExYjlhMQ==,Dan Abramov,GitHub,"Remove fbjs dependency (#13069)

* Inline fbjs/lib/invariant

* Inline fbjs/lib/warning

* Remove remaining usage of fbjs in packages/*.js

* Fix lint

* Remove fbjs from dependencies

* Protect against accidental fbjs imports

* Fix broken test mocks

* Allow transitive deps on fbjs/ for UMD bundles

* Remove fbjs from release script",https://api.github.com/repos/facebook/react/git/commits/aeda7b745d9c080150704feb20ea576238a1b9a1,2018-06-19,Remove fbjs dependency (#13069)
113,MDY6Q29tbWl0MTAyNzAyNTA6YWVkYTdiNzQ1ZDljMDgwMTUwNzA0ZmViMjBlYTU3NjIzOGExYjlhMQ==,Dan Abramov,GitHub,"Remove fbjs dependency (#13069)

* Inline fbjs/lib/invariant

* Inline fbjs/lib/warning

* Remove remaining usage of fbjs in packages/*.js

* Fix lint

* Remove fbjs from dependencies

* Protect against accidental fbjs imports

* Fix broken test mocks

* Allow transitive deps on fbjs/ for UMD bundles

* Remove fbjs from release script",https://api.github.com/repos/facebook/react/git/commits/aeda7b745d9c080150704feb20ea576238a1b9a1,2018-06-19,
114,MDY6Q29tbWl0MTAyNzAyNTA6NTU3ODcwMDY3MTBiZDhlZjg5YTAxZDYwYzRhOWNmYTU4YzcxMDM1ZA==,Brian Vaughn,GitHub,"Record ""actual"" times for all Fibers within a Profiler tree (alt) (#12910)

* Moved actual time fields from Profiler stateNode to Fiber

* Record actual time for all Fibers within a ProfileMode tree

* Changed how profiler accumulates time

This change gives up on accumulating time across renders of different priority, but in exchange- simplifies how the commit phase (reset) code works, and perhaps also makes the profiling code more compatible with future resuming behavior",https://api.github.com/repos/facebook/react/git/commits/55787006710bd8ef89a01d60c4a9cfa58c71035d,2018-05-25,"Record ""actual"" times for all Fibers within a Profiler tree (alt) (#12910)"
114,MDY6Q29tbWl0MTAyNzAyNTA6NTU3ODcwMDY3MTBiZDhlZjg5YTAxZDYwYzRhOWNmYTU4YzcxMDM1ZA==,Brian Vaughn,GitHub,"Record ""actual"" times for all Fibers within a Profiler tree (alt) (#12910)

* Moved actual time fields from Profiler stateNode to Fiber

* Record actual time for all Fibers within a ProfileMode tree

* Changed how profiler accumulates time

This change gives up on accumulating time across renders of different priority, but in exchange- simplifies how the commit phase (reset) code works, and perhaps also makes the profiling code more compatible with future resuming behavior",https://api.github.com/repos/facebook/react/git/commits/55787006710bd8ef89a01d60c4a9cfa58c71035d,2018-05-25,"This change gives up on accumulating time across renders of different priority, but in exchange- simplifies how the commit phase (reset) code works, and perhaps also makes the profiling code more compatible with future resuming behavior"
115,MDY6Q29tbWl0MTAyNzAyNTA6MTMwMDM2NTRlNzlmOWZhNjVlZTgzM2FmZWVjODZkNjY4ZjM1ZDMxZA==,Brian Vaughn,GitHub,"Pass ""start time"" and ""commit time"" to Profiler callback (#12852)

* Added start time parameter to Profiler onRender callback
* Profiler also captures commit time
* Only init Profiler stateNode if enableProfilerTimer feature flag enabled",https://api.github.com/repos/facebook/react/git/commits/13003654e79f9fa65ee833afeec86d668f35d31d,2018-05-21,"Pass ""start time"" and ""commit time"" to Profiler callback (#12852)"
115,MDY6Q29tbWl0MTAyNzAyNTA6MTMwMDM2NTRlNzlmOWZhNjVlZTgzM2FmZWVjODZkNjY4ZjM1ZDMxZA==,Brian Vaughn,GitHub,"Pass ""start time"" and ""commit time"" to Profiler callback (#12852)

* Added start time parameter to Profiler onRender callback
* Profiler also captures commit time
* Only init Profiler stateNode if enableProfilerTimer feature flag enabled",https://api.github.com/repos/facebook/react/git/commits/13003654e79f9fa65ee833afeec86d668f35d31d,2018-05-21,
116,MDY6Q29tbWl0MTAyNzAyNTA6YjI0NTc5NWRlMzczY2E4ZjRhNmM0OTYyYjU5NzczZTJmMWJiMmYxZA==,Dan Abramov,GitHub,"Re-enable Flow for ReactFiber and fix Flow issues (#12842)

* Lint for untyped imports and enable Flow typing in ReactFiber

* Re-enable Flow for ReactFiber and fix Flow issues

* Avoid an invariant in DEV-only code

I just introduced it, but on a second thought, it's better to keep it as a warning.

* Address review",https://api.github.com/repos/facebook/react/git/commits/b245795de373ca8f4a6c4962b59773e2f1bb2f1d,2018-05-17,Re-enable Flow for ReactFiber and fix Flow issues (#12842)
116,MDY6Q29tbWl0MTAyNzAyNTA6YjI0NTc5NWRlMzczY2E4ZjRhNmM0OTYyYjU5NzczZTJmMWJiMmYxZA==,Dan Abramov,GitHub,"Re-enable Flow for ReactFiber and fix Flow issues (#12842)

* Lint for untyped imports and enable Flow typing in ReactFiber

* Re-enable Flow for ReactFiber and fix Flow issues

* Avoid an invariant in DEV-only code

I just introduced it, but on a second thought, it's better to keep it as a warning.

* Address review",https://api.github.com/repos/facebook/react/git/commits/b245795de373ca8f4a6c4962b59773e2f1bb2f1d,2018-05-17,"I just introduced it, but on a second thought, it's better to keep it as a warning"
116,MDY6Q29tbWl0MTAyNzAyNTA6YjI0NTc5NWRlMzczY2E4ZjRhNmM0OTYyYjU5NzczZTJmMWJiMmYxZA==,Dan Abramov,GitHub,"Re-enable Flow for ReactFiber and fix Flow issues (#12842)

* Lint for untyped imports and enable Flow typing in ReactFiber

* Re-enable Flow for ReactFiber and fix Flow issues

* Avoid an invariant in DEV-only code

I just introduced it, but on a second thought, it's better to keep it as a warning.

* Address review",https://api.github.com/repos/facebook/react/git/commits/b245795de373ca8f4a6c4962b59773e2f1bb2f1d,2018-05-17,
117,MDY6Q29tbWl0MTAyNzAyNTA6OTA5N2YzY2RmMDg5YTM0ZDg3M2YzZDM0OWUzYmZiZWQ5MDg1MmZhZA==,Dan Abramov,GitHub,Delete React Call/Return experiment (#12820),https://api.github.com/repos/facebook/react/git/commits/9097f3cdf089a34d873f3d349e3bfbed90852fad,2018-05-15,Delete React Call/Return experiment (#12820)
117,MDY6Q29tbWl0MTAyNzAyNTA6OTA5N2YzY2RmMDg5YTM0ZDg3M2YzZDM0OWUzYmZiZWQ5MDg1MmZhZA==,Dan Abramov,GitHub,Delete React Call/Return experiment (#12820),https://api.github.com/repos/facebook/react/git/commits/9097f3cdf089a34d873f3d349e3bfbed90852fad,2018-05-15,
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,Suspense (#12279)
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,Adds Timeout component
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"When the promise
resolves, React will retry"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
Co-authored-by: Andrew Clark <acdlite@fb.com>
React should resume rendering regardless of whether it resolves
or rejects"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
Async is not required for Suspense, but strict mode is"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
It already worked this way in practice"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
Instead of waiting for commit phase"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"But in practice
this likely isn't a big deal"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
Non-IO-bound work is not affected at all"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
Idk why I thought this was neccessary
This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,"
When updating the tests, I also made a fix related to offscreen
priority"
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,We should never timeout inside a hidden tree
118,MDY6Q29tbWl0MTAyNzAyNTA6NjU2NTc5NTM3N2QxZDJjNzlhNzcwODc2NmYxYWY5ZTFhODc1MTdkZQ==,Andrew Clark,GitHub,"Suspense (#12279)

* Timeout component

Adds Timeout component. If a promise is thrown from inside a Timeout component,
React will suspend the in-progress render from committing. When the promise
resolves, React will retry. If the render is suspended for longer than the
maximum threshold, the Timeout switches to a placeholder state.

The timeout threshold is defined as the minimum of:
- The expiration time of the current render
- The `ms` prop given to each Timeout component in the ancestor path of the
thrown promise.

* Add a test for nested fallbacks

Co-authored-by: Andrew Clark <acdlite@fb.com>

* Resume on promise rejection

React should resume rendering regardless of whether it resolves
or rejects.

* Wrap Suspense code in feature flag

* Children of a Timeout must be strict mode compatible

Async is not required for Suspense, but strict mode is.

* Simplify list of pending work

Some of this was added with ""soft expiration"" in mind, but now with our revised
model for how soft expiration will work, this isn't necessary.

It would be nice to remove more of this, but I think the list itself is inherent
because we need a way to track the start times, for <Timeout ms={ms} />.

* Only use the Timeout update queue to store promises, not for state

It already worked this way in practice.

* Wrap more Suspense-only paths in the feature flag

* Attach promise listener immediately on suspend

Instead of waiting for commit phase.

* Infer approximate start time using expiration time

* Remove list of pending priority levels

We can replicate almost all the functionality by tracking just five
separate levels: the highest/lowest priority pending levels, the
highest/lowest priority suspended levels, and the lowest pinged level.

We lose a bit of granularity, in that if there are multiple levels of
pending updates, only the first and last ones are known. But in practice
this likely isn't a big deal.

These heuristics are almost entirely isolated to a single module and
can be adjusted later, without API changes, if necessary.

Non-IO-bound work is not affected at all.

* ReactFiberPendingWork -> ReactFiberPendingPriority

* Renaming method names from ""pending work"" to ""pending priority""

* Get rid of SuspenseThenable module

Idk why I thought this was neccessary

* Nits based on Sebastian's feedback

* More naming nits + comments

* Add test for hiding a suspended tree to unblock

* Revert change to expiration time rounding

This means you have to account for the start time approximation
heuristic when writing Suspense tests, but that's going to be
true regardless.

When updating the tests, I also made a fix related to offscreen
priority. We should never timeout inside a hidden tree.

* palceholder -> placeholder",https://api.github.com/repos/facebook/react/git/commits/6565795377d1d2c79a7708766f1af9e1a87517de,2018-05-11,
119,MDY6Q29tbWl0MTAyNzAyNTA6ZmMzNzc3YjFmZTI5NWZkMjY2MWYxOTc0ZjU1ODdkMjE0NzkxZjA0Yg==,Brian Vaughn,GitHub,"Add Profiler component for collecting new render timing info (#12745)

Add a new component type, Profiler, that can be used to collect new render time metrics. Since this is a new, experimental API, it will be exported as React.unstable_Profiler initially.

Most of the functionality for this component has been added behind a feature flag, enableProfileModeMetrics. When the feature flag is disabled, the component will just render its children with no additional behavior. When the flag is enabled, React will also collect timing information and pass it to the onRender function (as described below).",https://api.github.com/repos/facebook/react/git/commits/fc3777b1fe295fd2661f1974f5587d214791f04b,2018-05-10,Add Profiler component for collecting new render timing info (#12745)
119,MDY6Q29tbWl0MTAyNzAyNTA6ZmMzNzc3YjFmZTI5NWZkMjY2MWYxOTc0ZjU1ODdkMjE0NzkxZjA0Yg==,Brian Vaughn,GitHub,"Add Profiler component for collecting new render timing info (#12745)

Add a new component type, Profiler, that can be used to collect new render time metrics. Since this is a new, experimental API, it will be exported as React.unstable_Profiler initially.

Most of the functionality for this component has been added behind a feature flag, enableProfileModeMetrics. When the feature flag is disabled, the component will just render its children with no additional behavior. When the flag is enabled, React will also collect timing information and pass it to the onRender function (as described below).",https://api.github.com/repos/facebook/react/git/commits/fc3777b1fe295fd2661f1974f5587d214791f04b,2018-05-10,"Add a new component type, Profiler, that can be used to collect new render time metrics"
119,MDY6Q29tbWl0MTAyNzAyNTA6ZmMzNzc3YjFmZTI5NWZkMjY2MWYxOTc0ZjU1ODdkMjE0NzkxZjA0Yg==,Brian Vaughn,GitHub,"Add Profiler component for collecting new render timing info (#12745)

Add a new component type, Profiler, that can be used to collect new render time metrics. Since this is a new, experimental API, it will be exported as React.unstable_Profiler initially.

Most of the functionality for this component has been added behind a feature flag, enableProfileModeMetrics. When the feature flag is disabled, the component will just render its children with no additional behavior. When the flag is enabled, React will also collect timing information and pass it to the onRender function (as described below).",https://api.github.com/repos/facebook/react/git/commits/fc3777b1fe295fd2661f1974f5587d214791f04b,2018-05-10,"Since this is a new, experimental API, it will be exported as React.unstable_Profiler initially"
119,MDY6Q29tbWl0MTAyNzAyNTA6ZmMzNzc3YjFmZTI5NWZkMjY2MWYxOTc0ZjU1ODdkMjE0NzkxZjA0Yg==,Brian Vaughn,GitHub,"Add Profiler component for collecting new render timing info (#12745)

Add a new component type, Profiler, that can be used to collect new render time metrics. Since this is a new, experimental API, it will be exported as React.unstable_Profiler initially.

Most of the functionality for this component has been added behind a feature flag, enableProfileModeMetrics. When the feature flag is disabled, the component will just render its children with no additional behavior. When the flag is enabled, React will also collect timing information and pass it to the onRender function (as described below).",https://api.github.com/repos/facebook/react/git/commits/fc3777b1fe295fd2661f1974f5587d214791f04b,2018-05-10,"
Most of the functionality for this component has been added behind a feature flag, enableProfileModeMetrics"
119,MDY6Q29tbWl0MTAyNzAyNTA6ZmMzNzc3YjFmZTI5NWZkMjY2MWYxOTc0ZjU1ODdkMjE0NzkxZjA0Yg==,Brian Vaughn,GitHub,"Add Profiler component for collecting new render timing info (#12745)

Add a new component type, Profiler, that can be used to collect new render time metrics. Since this is a new, experimental API, it will be exported as React.unstable_Profiler initially.

Most of the functionality for this component has been added behind a feature flag, enableProfileModeMetrics. When the feature flag is disabled, the component will just render its children with no additional behavior. When the flag is enabled, React will also collect timing information and pass it to the onRender function (as described below).",https://api.github.com/repos/facebook/react/git/commits/fc3777b1fe295fd2661f1974f5587d214791f04b,2018-05-10,"When the feature flag is disabled, the component will just render its children with no additional behavior"
119,MDY6Q29tbWl0MTAyNzAyNTA6ZmMzNzc3YjFmZTI5NWZkMjY2MWYxOTc0ZjU1ODdkMjE0NzkxZjA0Yg==,Brian Vaughn,GitHub,"Add Profiler component for collecting new render timing info (#12745)

Add a new component type, Profiler, that can be used to collect new render time metrics. Since this is a new, experimental API, it will be exported as React.unstable_Profiler initially.

Most of the functionality for this component has been added behind a feature flag, enableProfileModeMetrics. When the feature flag is disabled, the component will just render its children with no additional behavior. When the flag is enabled, React will also collect timing information and pass it to the onRender function (as described below).",https://api.github.com/repos/facebook/react/git/commits/fc3777b1fe295fd2661f1974f5587d214791f04b,2018-05-10,"When the flag is enabled, React will also collect timing information and pass it to the onRender function (as described below)."
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,Decouple update queue from Fiber type (#12600)
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,The update queue is in need of a refactor
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"Recent bugfixes (#12528) have
exposed some flaws in how it's modeled"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
Major changes:
- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber)"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"This lowers the cost for adding new
types of updates"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
- Render phase updates are special cased"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"Updates scheduled during
the render phase are dropped if the work-in-progress does not commit"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
This is used for `getDerivedStateFrom{Props,Catch}`"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
- `callbackList` has been replaced with a generic effect list"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"Aside
from callbacks, this is also used for `componentDidCatch`"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
This way they can be reused independently of updates like
getDerivedStateFromProps"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,This will be important for resuming
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
Instead of using the effect tag"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"Ideally, this would be part of the
return type of processUpdateQueue"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
I don't love this name either, but it's less confusing than UpdateQueue
I suppose"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"Conceptually, this is usually a callback: setState callbacks,
componentDidCatch"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"I guess that kinda
fits, too"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"This makes more sense, since ""receiving props"" is not an event
that should be observed"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates)"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"
Change `process` and `callback` to match the expected payload types
for class components"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,"I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway"
120,MDY6Q29tbWl0MTAyNzAyNTA6YjU0OGIzY2Q2NDBkYmQ1MTVmNWQ2N2RhZmMwMjE2YmI3ZWUwZDc5Ng==,Andrew Clark,GitHub,"Decouple update queue from Fiber type (#12600)

* Decouple update queue from Fiber type

The update queue is in need of a refactor. Recent bugfixes (#12528) have
exposed some flaws in how it's modeled. Upcoming features like Suspense
and [redacted] also rely on the update queue in ways that weren't
anticipated in the original design.

Major changes:

- Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
have a `tag` field (like Fiber). This lowers the cost for adding new
types of updates.
- Render phase updates are special cased. Updates scheduled during
the render phase are dropped if the work-in-progress does not commit.
This is used for `getDerivedStateFrom{Props,Catch}`.
- `callbackList` has been replaced with a generic effect list. Aside
from callbacks, this is also used for `componentDidCatch`.

* Remove first class UpdateQueue types and use closures instead

I tried to avoid this at first, since we avoid it everywhere else in the Fiber
codebase, but since updates are not in a hot path, the trade off with file size
seems worth it.

* Store captured errors on a separate part of the update queue

This way they can be reused independently of updates like
getDerivedStateFromProps. This will be important for resuming.

* Revert back to storing hasForceUpdate on the update queue

Instead of using the effect tag. Ideally, this would be part of the
return type of processUpdateQueue.

* Rename UpdateQueue effect type back to Callback

I don't love this name either, but it's less confusing than UpdateQueue
I suppose. Conceptually, this is usually a callback: setState callbacks,
componentDidCatch. The only case that feels a bit weird is Timeouts,
which use this effect to attach a promise listener. I guess that kinda
fits, too.

* Call getDerivedStateFromProps every render, even if props did not change

Rather than enqueue a new setState updater for every props change, we
can skip the update queue entirely and merge the result into state at
the end. This makes more sense, since ""receiving props"" is not an event
that should be observed. It's still a bit weird, since eventually we do
persist the derived state (in other words, it accumulates).

* Store captured effects on separate list from ""own"" effects (callbacks)

For resuming, we need the ability to discard the ""own"" effects while
reusing the captured effects.

* Optimize for class components

Change `process` and `callback` to match the expected payload types
for class components. I had intended for the update queue to be reusable
for both class components and a future React API, but we'll likely have
to fork anyway.

* Only double-invoke render phase lifecycles functions in DEV

* Use global state to track currently processing queue in DEV",https://api.github.com/repos/facebook/react/git/commits/b548b3cd640dbd515f5d67dafc0216bb7ee0d796,2018-04-23,
121,MDY6Q29tbWl0MTAyNzAyNTA6NTlkYWM5ZDdhNmEyZjBiNjYwMDNjZjcxN2Q3MWI1NTg3MjY1NDIzZg==,Dan Abramov,GitHub,"Fix DEV performance regression by avoiding Object.assign on Fibers (#12510)

* Fix DEV performance regression by avoiding Object.assign on Fibers

* Reduce allocations in hot path by reusing the stash

Since performUnitOfWork() is not reentrant, it should be safe to reuse the same stash every time instead of creating a new object.",https://api.github.com/repos/facebook/react/git/commits/59dac9d7a6a2f0b66003cf717d71b5587265423f,2018-04-01,Fix DEV performance regression by avoiding Object.assign on Fibers (#12510)
121,MDY6Q29tbWl0MTAyNzAyNTA6NTlkYWM5ZDdhNmEyZjBiNjYwMDNjZjcxN2Q3MWI1NTg3MjY1NDIzZg==,Dan Abramov,GitHub,"Fix DEV performance regression by avoiding Object.assign on Fibers (#12510)

* Fix DEV performance regression by avoiding Object.assign on Fibers

* Reduce allocations in hot path by reusing the stash

Since performUnitOfWork() is not reentrant, it should be safe to reuse the same stash every time instead of creating a new object.",https://api.github.com/repos/facebook/react/git/commits/59dac9d7a6a2f0b66003cf717d71b5587265423f,2018-04-01,"Since performUnitOfWork() is not reentrant, it should be safe to reuse the same stash every time instead of creating a new object."
122,MDY6Q29tbWl0MTAyNzAyNTA6YmM3MDQ0MWM4YjNmYTg1MzM4MjgzYWYzZWViNDdiNWQxNWU5ZGJmZQ==,Brian Vaughn,GitHub,"RFC #30: React.forwardRef implementation (#12346)

Added React.forwardRef support to react-reconciler based renders and the SSR partial renderer.",https://api.github.com/repos/facebook/react/git/commits/bc70441c8b3fa85338283af3eeb47b5d15e9dbfe,2018-03-14,RFC #30: React.forwardRef implementation (#12346)
122,MDY6Q29tbWl0MTAyNzAyNTA6YmM3MDQ0MWM4YjNmYTg1MzM4MjgzYWYzZWViNDdiNWQxNWU5ZGJmZQ==,Brian Vaughn,GitHub,"RFC #30: React.forwardRef implementation (#12346)

Added React.forwardRef support to react-reconciler based renders and the SSR partial renderer.",https://api.github.com/repos/facebook/react/git/commits/bc70441c8b3fa85338283af3eeb47b5d15e9dbfe,2018-03-14,Added React.forwardRef support to react-reconciler based renders and the SSR partial renderer.
123,MDY6Q29tbWl0MTAyNzAyNTA6MDQ5ZmU3ZDZmZDc5ODRjNGE3MjA1MTAzZDNhYWZjNDZiY2VjYTFmNg==,Kiho · Cham,Nathan Hunzaker,"annotation typo (#12272)

* comment typo

* change after then to after that",https://api.github.com/repos/facebook/react/git/commits/049fe7d6fd7984c4a7205103d3aafc46bceca1f6,2018-03-04,annotation typo (#12272)
123,MDY6Q29tbWl0MTAyNzAyNTA6MDQ5ZmU3ZDZmZDc5ODRjNGE3MjA1MTAzZDNhYWZjNDZiY2VjYTFmNg==,Kiho · Cham,Nathan Hunzaker,"annotation typo (#12272)

* comment typo

* change after then to after that",https://api.github.com/repos/facebook/react/git/commits/049fe7d6fd7984c4a7205103d3aafc46bceca1f6,2018-03-04,
124,MDY6Q29tbWl0MTAyNzAyNTA6OGRjOGY4OGQ1YWU5ZmI5NjkzNGJhNDNlMzg0MmI1ZGNmNDA3NGFmZA==,Dominic Gannaway,GitHub,"Adds createRef() as per RFC (#12162)

* Adds createRef() as per RFC",https://api.github.com/repos/facebook/react/git/commits/8dc8f88d5ae9fb96934ba43e3842b5dcf4074afd,2018-02-06,Adds createRef() as per RFC (#12162)
124,MDY6Q29tbWl0MTAyNzAyNTA6OGRjOGY4OGQ1YWU5ZmI5NjkzNGJhNDNlMzg0MmI1ZGNmNDA3NGFmZA==,Dominic Gannaway,GitHub,"Adds createRef() as per RFC (#12162)

* Adds createRef() as per RFC",https://api.github.com/repos/facebook/react/git/commits/8dc8f88d5ae9fb96934ba43e3842b5dcf4074afd,2018-02-06,
125,MDY6Q29tbWl0MTAyNzAyNTA6OWVhNTU1MTZlNjc0YzJkZTYzYjlmNzgyOWUzYzQ1OWYzY2IzY2Y3OA==,Andrew Clark,GitHub,"Replace unstable_AsyncComponent with unstable_AsyncMode (#12117)

* Replace unstable_AsyncComponent with Unstable_AsyncMode

Mirrors the StrictMode API and uses the new Mode type of work.

* internalContextTag -> mode

Change this now that we have a better name

* Unstable_ -> unstable_",https://api.github.com/repos/facebook/react/git/commits/9ea55516e674c2de63b9f7829e3c459f3cb3cf78,2018-01-30,Replace unstable_AsyncComponent with unstable_AsyncMode (#12117)
125,MDY6Q29tbWl0MTAyNzAyNTA6OWVhNTU1MTZlNjc0YzJkZTYzYjlmNzgyOWUzYzQ1OWYzY2IzY2Y3OA==,Andrew Clark,GitHub,"Replace unstable_AsyncComponent with unstable_AsyncMode (#12117)

* Replace unstable_AsyncComponent with Unstable_AsyncMode

Mirrors the StrictMode API and uses the new Mode type of work.

* internalContextTag -> mode

Change this now that we have a better name

* Unstable_ -> unstable_",https://api.github.com/repos/facebook/react/git/commits/9ea55516e674c2de63b9f7829e3c459f3cb3cf78,2018-01-30,Mirrors the StrictMode API and uses the new Mode type of work
125,MDY6Q29tbWl0MTAyNzAyNTA6OWVhNTU1MTZlNjc0YzJkZTYzYjlmNzgyOWUzYzQ1OWYzY2IzY2Y3OA==,Andrew Clark,GitHub,"Replace unstable_AsyncComponent with unstable_AsyncMode (#12117)

* Replace unstable_AsyncComponent with Unstable_AsyncMode

Mirrors the StrictMode API and uses the new Mode type of work.

* internalContextTag -> mode

Change this now that we have a better name

* Unstable_ -> unstable_",https://api.github.com/repos/facebook/react/git/commits/9ea55516e674c2de63b9f7829e3c459f3cb3cf78,2018-01-30,"
Change this now that we have a better name"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,New context API (#11818)
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"
Same semantics as PureComponent/shallowEqual"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"
Rather than using a linked list stored on the context type"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"
We'll enable this in www only for now"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"
Context stack should be per server renderer instance"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"
The context type defines an optional function that compares two context
values, returning a bitfield"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"A consumer may specify the bits it needs
for rendering"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"
This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"The only user code involved is the function
that computes the changed bits"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"But that's only called once per provider
update, not for every consumer"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"
There are fewer providers than consumers, so better to do this work
at the provider"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"
This is the largest integer size in V8 on 32-bit systems"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"Warn in
development if too large a number is used"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"
Let's see if we can get away with not supporting this for now"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,"If it
turns out that it's needed, we can fall back to backtracking the
fiber return path"
126,MDY6Q29tbWl0MTAyNzAyNTA6ODdhZTIxMWNjZDhkNjE3OTZjZmRlZjEzOGQxZTEyZmI3YTc0Zjg1ZA==,Andrew Clark,GitHub,"New context API (#11818)

* New context API

Introduces a declarative context API that propagates updates even when
shouldComponentUpdate returns false.

* Fuzz tester for context

* Use ReactElement for provider and consumer children

* Unify more branches in createFiberFromElement

* Compare context values using Object.is

Same semantics as PureComponent/shallowEqual.

* Add support for Provider and Consumer to server-side renderer

* Store providers on global stack

Rather than using a linked list stored on the context type. The global
stack can be reset in case of an interruption or error, whereas with the
linked list implementation, you'd need to keep track of every
context type.

* Put new context API behind a feature flag

We'll enable this in www only for now.

* Store nearest provider on context object

* Handle reentrancy in server renderer

Context stack should be per server renderer instance.

* Bailout of consumer updates using bitmask

The context type defines an optional function that compares two context
values, returning a bitfield. A consumer may specify the bits it needs
for rendering. If a provider's context changes, and the consumer's bits
do not intersect with the changed bits, we can skip the consumer.

This is similar to how selectors are used in Redux but fast enough to do
while scanning the tree. The only user code involved is the function
that computes the changed bits. But that's only called once per provider
update, not for every consumer.

* Store current value and changed bits on context object

There are fewer providers than consumers, so better to do this work
at the provider.

* Use maximum of 31 bits for bitmask

This is the largest integer size in V8 on 32-bit systems. Warn in
development if too large a number is used.

* ProviderComponent -> ContextProvider, ConsumerComponent -> ContextConsumer

* Inline Object.is

* Warn if multiple renderers concurrently render the same context provider

Let's see if we can get away with not supporting this for now. If it
turns out that it's needed, we can fall back to backtracking the
fiber return path.

* Nits that came up during review",https://api.github.com/repos/facebook/react/git/commits/87ae211ccd8d61796cfdef138d1e12fb7a74f85d,2018-01-25,
127,MDY6Q29tbWl0MTAyNzAyNTA6YmU1MWU2YTQxYzA5NmYzM2FjZjkyYTY5MzAyNmI4MGM5OGU3ZGRlYg==,Brian Vaughn,GitHub,"Opt into unsafe lifecycle warnings without async tree (#12083)

Added new StrictMode component for enabling async warnings (without enabling async rendering). This component can be used in the future to help with other warnings (eg compilation, Fabric).",https://api.github.com/repos/facebook/react/git/commits/be51e6a41c096f33acf92a693026b80c98e7ddeb,2018-01-25,Opt into unsafe lifecycle warnings without async tree (#12083)
127,MDY6Q29tbWl0MTAyNzAyNTA6YmU1MWU2YTQxYzA5NmYzM2FjZjkyYTY5MzAyNmI4MGM5OGU3ZGRlYg==,Brian Vaughn,GitHub,"Opt into unsafe lifecycle warnings without async tree (#12083)

Added new StrictMode component for enabling async warnings (without enabling async rendering). This component can be used in the future to help with other warnings (eg compilation, Fabric).",https://api.github.com/repos/facebook/react/git/commits/be51e6a41c096f33acf92a693026b80c98e7ddeb,2018-01-25,Added new StrictMode component for enabling async warnings (without enabling async rendering)
127,MDY6Q29tbWl0MTAyNzAyNTA6YmU1MWU2YTQxYzA5NmYzM2FjZjkyYTY5MzAyNmI4MGM5OGU3ZGRlYg==,Brian Vaughn,GitHub,"Opt into unsafe lifecycle warnings without async tree (#12083)

Added new StrictMode component for enabling async warnings (without enabling async rendering). This component can be used in the future to help with other warnings (eg compilation, Fabric).",https://api.github.com/repos/facebook/react/git/commits/be51e6a41c096f33acf92a693026b80c98e7ddeb,2018-01-25,"This component can be used in the future to help with other warnings (eg compilation, Fabric)."
128,MDY6Q29tbWl0MTAyNzAyNTA6Yjc3YjEyMzExZjBjNjZhYWQ5YjUwZjgwNWM1M2RjYzA1ZDJlYTc1Yw==,Andrew Clark,GitHub,"Call and Return components should use ReactElement (#11834)

* Call and Return components should use ReactElement

ReactChildFiber contains lots of branches that do the same thing for
different child types. We can unify them by having more child types be
ReactElements. This requires that the `type` and `key` fields are
sufficient to determine the identity of the child.

The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers.

This updates Call and Return components to use ReactElement. Portals are
left alone for now because their identity includes the host instance.

* Move server render invariant for call and return types

* Sort ReactElement type checks by most likely

* Performance timeline should skip over call components

Don't think these were intentionally omitted from the blacklist of
component types.

I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now.

* Remove surrounding brackets from internal display names",https://api.github.com/repos/facebook/react/git/commits/b77b12311f0c66aad9b50f805c53dcc05d2ea75c,2017-12-12,Call and Return components should use ReactElement (#11834)
128,MDY6Q29tbWl0MTAyNzAyNTA6Yjc3YjEyMzExZjBjNjZhYWQ5YjUwZjgwNWM1M2RjYzA1ZDJlYTc1Yw==,Andrew Clark,GitHub,"Call and Return components should use ReactElement (#11834)

* Call and Return components should use ReactElement

ReactChildFiber contains lots of branches that do the same thing for
different child types. We can unify them by having more child types be
ReactElements. This requires that the `type` and `key` fields are
sufficient to determine the identity of the child.

The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers.

This updates Call and Return components to use ReactElement. Portals are
left alone for now because their identity includes the host instance.

* Move server render invariant for call and return types

* Sort ReactElement type checks by most likely

* Performance timeline should skip over call components

Don't think these were intentionally omitted from the blacklist of
component types.

I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now.

* Remove surrounding brackets from internal display names",https://api.github.com/repos/facebook/react/git/commits/b77b12311f0c66aad9b50f805c53dcc05d2ea75c,2017-12-12,"ReactChildFiber contains lots of branches that do the same thing for
different child types"
128,MDY6Q29tbWl0MTAyNzAyNTA6Yjc3YjEyMzExZjBjNjZhYWQ5YjUwZjgwNWM1M2RjYzA1ZDJlYTc1Yw==,Andrew Clark,GitHub,"Call and Return components should use ReactElement (#11834)

* Call and Return components should use ReactElement

ReactChildFiber contains lots of branches that do the same thing for
different child types. We can unify them by having more child types be
ReactElements. This requires that the `type` and `key` fields are
sufficient to determine the identity of the child.

The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers.

This updates Call and Return components to use ReactElement. Portals are
left alone for now because their identity includes the host instance.

* Move server render invariant for call and return types

* Sort ReactElement type checks by most likely

* Performance timeline should skip over call components

Don't think these were intentionally omitted from the blacklist of
component types.

I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now.

* Remove surrounding brackets from internal display names",https://api.github.com/repos/facebook/react/git/commits/b77b12311f0c66aad9b50f805c53dcc05d2ea75c,2017-12-12,"We can unify them by having more child types be
ReactElements"
128,MDY6Q29tbWl0MTAyNzAyNTA6Yjc3YjEyMzExZjBjNjZhYWQ5YjUwZjgwNWM1M2RjYzA1ZDJlYTc1Yw==,Andrew Clark,GitHub,"Call and Return components should use ReactElement (#11834)

* Call and Return components should use ReactElement

ReactChildFiber contains lots of branches that do the same thing for
different child types. We can unify them by having more child types be
ReactElements. This requires that the `type` and `key` fields are
sufficient to determine the identity of the child.

The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers.

This updates Call and Return components to use ReactElement. Portals are
left alone for now because their identity includes the host instance.

* Move server render invariant for call and return types

* Sort ReactElement type checks by most likely

* Performance timeline should skip over call components

Don't think these were intentionally omitted from the blacklist of
component types.

I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now.

* Remove surrounding brackets from internal display names",https://api.github.com/repos/facebook/react/git/commits/b77b12311f0c66aad9b50f805c53dcc05d2ea75c,2017-12-12,"This requires that the `type` and `key` fields are
sufficient to determine the identity of the child"
128,MDY6Q29tbWl0MTAyNzAyNTA6Yjc3YjEyMzExZjBjNjZhYWQ5YjUwZjgwNWM1M2RjYzA1ZDJlYTc1Yw==,Andrew Clark,GitHub,"Call and Return components should use ReactElement (#11834)

* Call and Return components should use ReactElement

ReactChildFiber contains lots of branches that do the same thing for
different child types. We can unify them by having more child types be
ReactElements. This requires that the `type` and `key` fields are
sufficient to determine the identity of the child.

The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers.

This updates Call and Return components to use ReactElement. Portals are
left alone for now because their identity includes the host instance.

* Move server render invariant for call and return types

* Sort ReactElement type checks by most likely

* Performance timeline should skip over call components

Don't think these were intentionally omitted from the blacklist of
component types.

I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now.

* Remove surrounding brackets from internal display names",https://api.github.com/repos/facebook/react/git/commits/b77b12311f0c66aad9b50f805c53dcc05d2ea75c,2017-12-12,"
The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers"
128,MDY6Q29tbWl0MTAyNzAyNTA6Yjc3YjEyMzExZjBjNjZhYWQ5YjUwZjgwNWM1M2RjYzA1ZDJlYTc1Yw==,Andrew Clark,GitHub,"Call and Return components should use ReactElement (#11834)

* Call and Return components should use ReactElement

ReactChildFiber contains lots of branches that do the same thing for
different child types. We can unify them by having more child types be
ReactElements. This requires that the `type` and `key` fields are
sufficient to determine the identity of the child.

The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers.

This updates Call and Return components to use ReactElement. Portals are
left alone for now because their identity includes the host instance.

* Move server render invariant for call and return types

* Sort ReactElement type checks by most likely

* Performance timeline should skip over call components

Don't think these were intentionally omitted from the blacklist of
component types.

I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now.

* Remove surrounding brackets from internal display names",https://api.github.com/repos/facebook/react/git/commits/b77b12311f0c66aad9b50f805c53dcc05d2ea75c,2017-12-12,"
This updates Call and Return components to use ReactElement"
128,MDY6Q29tbWl0MTAyNzAyNTA6Yjc3YjEyMzExZjBjNjZhYWQ5YjUwZjgwNWM1M2RjYzA1ZDJlYTc1Yw==,Andrew Clark,GitHub,"Call and Return components should use ReactElement (#11834)

* Call and Return components should use ReactElement

ReactChildFiber contains lots of branches that do the same thing for
different child types. We can unify them by having more child types be
ReactElements. This requires that the `type` and `key` fields are
sufficient to determine the identity of the child.

The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers.

This updates Call and Return components to use ReactElement. Portals are
left alone for now because their identity includes the host instance.

* Move server render invariant for call and return types

* Sort ReactElement type checks by most likely

* Performance timeline should skip over call components

Don't think these were intentionally omitted from the blacklist of
component types.

I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now.

* Remove surrounding brackets from internal display names",https://api.github.com/repos/facebook/react/git/commits/b77b12311f0c66aad9b50f805c53dcc05d2ea75c,2017-12-12,"Portals are
left alone for now because their identity includes the host instance"
128,MDY6Q29tbWl0MTAyNzAyNTA6Yjc3YjEyMzExZjBjNjZhYWQ5YjUwZjgwNWM1M2RjYzA1ZDJlYTc1Yw==,Andrew Clark,GitHub,"Call and Return components should use ReactElement (#11834)

* Call and Return components should use ReactElement

ReactChildFiber contains lots of branches that do the same thing for
different child types. We can unify them by having more child types be
ReactElements. This requires that the `type` and `key` fields are
sufficient to determine the identity of the child.

The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers.

This updates Call and Return components to use ReactElement. Portals are
left alone for now because their identity includes the host instance.

* Move server render invariant for call and return types

* Sort ReactElement type checks by most likely

* Performance timeline should skip over call components

Don't think these were intentionally omitted from the blacklist of
component types.

I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now.

* Remove surrounding brackets from internal display names",https://api.github.com/repos/facebook/react/git/commits/b77b12311f0c66aad9b50f805c53dcc05d2ea75c,2017-12-12,"
Don't think these were intentionally omitted from the blacklist of
component types"
128,MDY6Q29tbWl0MTAyNzAyNTA6Yjc3YjEyMzExZjBjNjZhYWQ5YjUwZjgwNWM1M2RjYzA1ZDJlYTc1Yw==,Andrew Clark,GitHub,"Call and Return components should use ReactElement (#11834)

* Call and Return components should use ReactElement

ReactChildFiber contains lots of branches that do the same thing for
different child types. We can unify them by having more child types be
ReactElements. This requires that the `type` and `key` fields are
sufficient to determine the identity of the child.

The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers.

This updates Call and Return components to use ReactElement. Portals are
left alone for now because their identity includes the host instance.

* Move server render invariant for call and return types

* Sort ReactElement type checks by most likely

* Performance timeline should skip over call components

Don't think these were intentionally omitted from the blacklist of
component types.

I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now.

* Remove surrounding brackets from internal display names",https://api.github.com/repos/facebook/react/git/commits/b77b12311f0c66aad9b50f805c53dcc05d2ea75c,2017-12-12,"
I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now"
128,MDY6Q29tbWl0MTAyNzAyNTA6Yjc3YjEyMzExZjBjNjZhYWQ5YjUwZjgwNWM1M2RjYzA1ZDJlYTc1Yw==,Andrew Clark,GitHub,"Call and Return components should use ReactElement (#11834)

* Call and Return components should use ReactElement

ReactChildFiber contains lots of branches that do the same thing for
different child types. We can unify them by having more child types be
ReactElements. This requires that the `type` and `key` fields are
sufficient to determine the identity of the child.

The main benefit is decreased file size, especially as we add more
component types, like context providers and consumers.

This updates Call and Return components to use ReactElement. Portals are
left alone for now because their identity includes the host instance.

* Move server render invariant for call and return types

* Sort ReactElement type checks by most likely

* Performance timeline should skip over call components

Don't think these were intentionally omitted from the blacklist of
component types.

I went ahead and updated getComponentName to include special types, even
though I don't think they're used anywhere right now.

* Remove surrounding brackets from internal display names",https://api.github.com/repos/facebook/react/git/commits/b77b12311f0c66aad9b50f805c53dcc05d2ea75c,2017-12-12,
129,MDY6Q29tbWl0MTAyNzAyNTA6MzdlNDMyOWJjODFkZWY0Njk1MjExZDZlMzc5NWE2NTRlZjRkODRmNQ==,Raphael Amorim,Dan Abramov,"Remove vars (#11766)

* react: convert packages/react

* react-reconciler: convert packages/react-reconciler

* react-noop-renderer: convert packages/react-noop-renderer

* react-dom: convert packages/react-dom/src/shared

* react-dom: convert packages/react-dom/src/server",https://api.github.com/repos/facebook/react/git/commits/37e4329bc81def4695211d6e3795a654ef4d84f5,2017-12-05,Remove vars (#11766)
129,MDY6Q29tbWl0MTAyNzAyNTA6MzdlNDMyOWJjODFkZWY0Njk1MjExZDZlMzc5NWE2NTRlZjRkODRmNQ==,Raphael Amorim,Dan Abramov,"Remove vars (#11766)

* react: convert packages/react

* react-reconciler: convert packages/react-reconciler

* react-noop-renderer: convert packages/react-noop-renderer

* react-dom: convert packages/react-dom/src/shared

* react-dom: convert packages/react-dom/src/server",https://api.github.com/repos/facebook/react/git/commits/37e4329bc81def4695211d6e3795a654ef4d84f5,2017-12-05,
130,MDY6Q29tbWl0MTAyNzAyNTA6NGQwZThmYzQ4Nzg1NjllN2I3YTcwZTkyNjFhN2M5NDVjYjBmZjFkOA==,Andrew Clark,GitHub,"ReactDOM.createRoot creates an async root (#11769)

Makes createRoot the opt-in API for async updates. Now we don't have
to check the top-level element to see if it's an async container.",https://api.github.com/repos/facebook/react/git/commits/4d0e8fc4878569e7b7a70e9261a7c945cb0ff1d8,2017-12-04,ReactDOM.createRoot creates an async root (#11769)
130,MDY6Q29tbWl0MTAyNzAyNTA6NGQwZThmYzQ4Nzg1NjllN2I3YTcwZTkyNjFhN2M5NDVjYjBmZjFkOA==,Andrew Clark,GitHub,"ReactDOM.createRoot creates an async root (#11769)

Makes createRoot the opt-in API for async updates. Now we don't have
to check the top-level element to see if it's an async container.",https://api.github.com/repos/facebook/react/git/commits/4d0e8fc4878569e7b7a70e9261a7c945cb0ff1d8,2017-12-04,Makes createRoot the opt-in API for async updates
130,MDY6Q29tbWl0MTAyNzAyNTA6NGQwZThmYzQ4Nzg1NjllN2I3YTcwZTkyNjFhN2M5NDVjYjBmZjFkOA==,Andrew Clark,GitHub,"ReactDOM.createRoot creates an async root (#11769)

Makes createRoot the opt-in API for async updates. Now we don't have
to check the top-level element to see if it's an async container.",https://api.github.com/repos/facebook/react/git/commits/4d0e8fc4878569e7b7a70e9261a7c945cb0ff1d8,2017-12-04,"Now we don't have
to check the top-level element to see if it's an async container."
131,MDY6Q29tbWl0MTAyNzAyNTA6MzFlYTBhYTZkNzAxZGY4MTFmYjU4NmZhNzU0NWEzNzZlNTEzNTQ0MA==,Dan Abramov,GitHub,"Add a test for bad Map polyfill, and work around Rollup bug (#11745)

* Add a test for bad Map polyfill

* Add a workaround for the Rollup bug

* Add a link to the bug URL",https://api.github.com/repos/facebook/react/git/commits/31ea0aa6d701df811fb586fa7545a376e5135440,2017-12-02,"Add a test for bad Map polyfill, and work around Rollup bug (#11745)"
131,MDY6Q29tbWl0MTAyNzAyNTA6MzFlYTBhYTZkNzAxZGY4MTFmYjU4NmZhNzU0NWEzNzZlNTEzNTQ0MA==,Dan Abramov,GitHub,"Add a test for bad Map polyfill, and work around Rollup bug (#11745)

* Add a test for bad Map polyfill

* Add a workaround for the Rollup bug

* Add a link to the bug URL",https://api.github.com/repos/facebook/react/git/commits/31ea0aa6d701df811fb586fa7545a376e5135440,2017-12-02,
132,MDY6Q29tbWl0MTAyNzAyNTA6NjA3NDY2NGY3M2M2YjFlYTFmNzc0ZjJiYzY5ODIyNGUzNjc3Y2VmMA==,Raphael Amorim,Dan Abramov,react-reconciler: convert vars into let/const (#11729),https://api.github.com/repos/facebook/react/git/commits/6074664f73c6b1ea1f774f2bc698224e3677cef0,2017-11-30,react-reconciler: convert vars into let/const (#11729)
132,MDY6Q29tbWl0MTAyNzAyNTA6NjA3NDY2NGY3M2M2YjFlYTFmNzc0ZjJiYzY5ODIyNGUzNjc3Y2VmMA==,Raphael Amorim,Dan Abramov,react-reconciler: convert vars into let/const (#11729),https://api.github.com/repos/facebook/react/git/commits/6074664f73c6b1ea1f774f2bc698224e3677cef0,2017-11-30,
133,MDY6Q29tbWl0MTAyNzAyNTA6MmFlNGM2MjE1ODkxYzY3YWVkMTdjMjIyNjFkYjc0YzFmMDc4ZjY2Mw==,Andrew Clark,GitHub,"Always set pendingProps to the next props (#11580)

In the current implementation, pendingProps is null if there are no new
props since the last commit. When that happens, we bail out and reuse
the current props.

But it makes more sense to always set pendingProps to whatever the next
props will be. In other words, pendingProps is never null: it points to
either new props, or to the current props. Modeling it this way lets us
delete lots of code branches and is easier to reason about bail outs:
just compare the pending props to the current props.",https://api.github.com/repos/facebook/react/git/commits/2ae4c6215891c67aed17c22261db74c1f078f663,2017-11-29,Always set pendingProps to the next props (#11580)
133,MDY6Q29tbWl0MTAyNzAyNTA6MmFlNGM2MjE1ODkxYzY3YWVkMTdjMjIyNjFkYjc0YzFmMDc4ZjY2Mw==,Andrew Clark,GitHub,"Always set pendingProps to the next props (#11580)

In the current implementation, pendingProps is null if there are no new
props since the last commit. When that happens, we bail out and reuse
the current props.

But it makes more sense to always set pendingProps to whatever the next
props will be. In other words, pendingProps is never null: it points to
either new props, or to the current props. Modeling it this way lets us
delete lots of code branches and is easier to reason about bail outs:
just compare the pending props to the current props.",https://api.github.com/repos/facebook/react/git/commits/2ae4c6215891c67aed17c22261db74c1f078f663,2017-11-29,"In the current implementation, pendingProps is null if there are no new
props since the last commit"
133,MDY6Q29tbWl0MTAyNzAyNTA6MmFlNGM2MjE1ODkxYzY3YWVkMTdjMjIyNjFkYjc0YzFmMDc4ZjY2Mw==,Andrew Clark,GitHub,"Always set pendingProps to the next props (#11580)

In the current implementation, pendingProps is null if there are no new
props since the last commit. When that happens, we bail out and reuse
the current props.

But it makes more sense to always set pendingProps to whatever the next
props will be. In other words, pendingProps is never null: it points to
either new props, or to the current props. Modeling it this way lets us
delete lots of code branches and is easier to reason about bail outs:
just compare the pending props to the current props.",https://api.github.com/repos/facebook/react/git/commits/2ae4c6215891c67aed17c22261db74c1f078f663,2017-11-29,"When that happens, we bail out and reuse
the current props"
133,MDY6Q29tbWl0MTAyNzAyNTA6MmFlNGM2MjE1ODkxYzY3YWVkMTdjMjIyNjFkYjc0YzFmMDc4ZjY2Mw==,Andrew Clark,GitHub,"Always set pendingProps to the next props (#11580)

In the current implementation, pendingProps is null if there are no new
props since the last commit. When that happens, we bail out and reuse
the current props.

But it makes more sense to always set pendingProps to whatever the next
props will be. In other words, pendingProps is never null: it points to
either new props, or to the current props. Modeling it this way lets us
delete lots of code branches and is easier to reason about bail outs:
just compare the pending props to the current props.",https://api.github.com/repos/facebook/react/git/commits/2ae4c6215891c67aed17c22261db74c1f078f663,2017-11-29,"
But it makes more sense to always set pendingProps to whatever the next
props will be"
133,MDY6Q29tbWl0MTAyNzAyNTA6MmFlNGM2MjE1ODkxYzY3YWVkMTdjMjIyNjFkYjc0YzFmMDc4ZjY2Mw==,Andrew Clark,GitHub,"Always set pendingProps to the next props (#11580)

In the current implementation, pendingProps is null if there are no new
props since the last commit. When that happens, we bail out and reuse
the current props.

But it makes more sense to always set pendingProps to whatever the next
props will be. In other words, pendingProps is never null: it points to
either new props, or to the current props. Modeling it this way lets us
delete lots of code branches and is easier to reason about bail outs:
just compare the pending props to the current props.",https://api.github.com/repos/facebook/react/git/commits/2ae4c6215891c67aed17c22261db74c1f078f663,2017-11-29,"In other words, pendingProps is never null: it points to
either new props, or to the current props"
133,MDY6Q29tbWl0MTAyNzAyNTA6MmFlNGM2MjE1ODkxYzY3YWVkMTdjMjIyNjFkYjc0YzFmMDc4ZjY2Mw==,Andrew Clark,GitHub,"Always set pendingProps to the next props (#11580)

In the current implementation, pendingProps is null if there are no new
props since the last commit. When that happens, we bail out and reuse
the current props.

But it makes more sense to always set pendingProps to whatever the next
props will be. In other words, pendingProps is never null: it points to
either new props, or to the current props. Modeling it this way lets us
delete lots of code branches and is easier to reason about bail outs:
just compare the pending props to the current props.",https://api.github.com/repos/facebook/react/git/commits/2ae4c6215891c67aed17c22261db74c1f078f663,2017-11-29,"Modeling it this way lets us
delete lots of code branches and is easier to reason about bail outs:
just compare the pending props to the current props."
134,MDY6Q29tbWl0MTAyNzAyNTA6NWJmYjg3ODc0MzkxZTYzNWNiMjQ1OGEyOWE3Yzg3OGNiNGRlYzg5Yw==,Kristofer Selbekk,Dan Abramov,"Add note about mistaken named / default export (#11505)

This commit adds a note about the possibility of erroneously
mistaking named and default exports to an existing error message.",https://api.github.com/repos/facebook/react/git/commits/5bfb87874391e635cb2458a29a7c878cb4dec89c,2017-11-09,Add note about mistaken named / default export (#11505)
134,MDY6Q29tbWl0MTAyNzAyNTA6NWJmYjg3ODc0MzkxZTYzNWNiMjQ1OGEyOWE3Yzg3OGNiNGRlYzg5Yw==,Kristofer Selbekk,Dan Abramov,"Add note about mistaken named / default export (#11505)

This commit adds a note about the possibility of erroneously
mistaking named and default exports to an existing error message.",https://api.github.com/repos/facebook/react/git/commits/5bfb87874391e635cb2458a29a7c878cb4dec89c,2017-11-09,"This commit adds a note about the possibility of erroneously
mistaking named and default exports to an existing error message."
135,MDY6Q29tbWl0MTAyNzAyNTA6NDVjMWZmMzQ4ZTFjN2QwMzU2N2Y1YmJhNmNiMzJjZmZhOTIyMjk3Mg==,Dan Abramov,GitHub,"Remove unnecessary 'use strict' in the source (#11433)

* Remove use strict from ES modules

* Delete unused file

This was unused since Stack.",https://api.github.com/repos/facebook/react/git/commits/45c1ff348e1c7d03567f5bba6cb32cffa9222972,2017-11-02,Remove unnecessary 'use strict' in the source (#11433)
135,MDY6Q29tbWl0MTAyNzAyNTA6NDVjMWZmMzQ4ZTFjN2QwMzU2N2Y1YmJhNmNiMzJjZmZhOTIyMjk3Mg==,Dan Abramov,GitHub,"Remove unnecessary 'use strict' in the source (#11433)

* Remove use strict from ES modules

* Delete unused file

This was unused since Stack.",https://api.github.com/repos/facebook/react/git/commits/45c1ff348e1c7d03567f5bba6cb32cffa9222972,2017-11-02,This was unused since Stack.
136,MDY6Q29tbWl0MTAyNzAyNTA6MjFkMGMxMTUyMzhiNGYzODgzNzAyMGNmODNlMGM2NTdkOGMwMWM5Zg==,Dan Abramov,GitHub,"Convert the Source to ES Modules (#11389)

* Update transforms to handle ES modules

* Update Jest to handle ES modules

* Convert react package to ES modules

* Convert react-art package to ES Modules

* Convert react-call-return package to ES Modules

* Convert react-test-renderer package to ES Modules

* Convert react-cs-renderer package to ES Modules

* Convert react-rt-renderer package to ES Modules

* Convert react-noop-renderer package to ES Modules

* Convert react-dom/server to ES modules

* Convert react-dom/{client,events,test-utils} to ES modules

* Convert react-dom/shared to ES modules

* Convert react-native-renderer to ES modules

* Convert react-reconciler to ES modules

* Convert events to ES modules

* Convert shared to ES modules

* Remove CommonJS support from transforms

* Move ReactDOMFB entry point code into react-dom/src

This is clearer because we can use ES imports in it.

* Fix Rollup shim configuration to work with ESM

* Fix incorrect comment

* Exclude external imports without side effects

* Fix ReactDOM FB build

* Remove TODOs I don’t intend to fix yet",https://api.github.com/repos/facebook/react/git/commits/21d0c115238b4f38837020cf83e0c657d8c01c9f,2017-11-02,Convert the Source to ES Modules (#11389)
136,MDY6Q29tbWl0MTAyNzAyNTA6MjFkMGMxMTUyMzhiNGYzODgzNzAyMGNmODNlMGM2NTdkOGMwMWM5Zg==,Dan Abramov,GitHub,"Convert the Source to ES Modules (#11389)

* Update transforms to handle ES modules

* Update Jest to handle ES modules

* Convert react package to ES modules

* Convert react-art package to ES Modules

* Convert react-call-return package to ES Modules

* Convert react-test-renderer package to ES Modules

* Convert react-cs-renderer package to ES Modules

* Convert react-rt-renderer package to ES Modules

* Convert react-noop-renderer package to ES Modules

* Convert react-dom/server to ES modules

* Convert react-dom/{client,events,test-utils} to ES modules

* Convert react-dom/shared to ES modules

* Convert react-native-renderer to ES modules

* Convert react-reconciler to ES modules

* Convert events to ES modules

* Convert shared to ES modules

* Remove CommonJS support from transforms

* Move ReactDOMFB entry point code into react-dom/src

This is clearer because we can use ES imports in it.

* Fix Rollup shim configuration to work with ESM

* Fix incorrect comment

* Exclude external imports without side effects

* Fix ReactDOM FB build

* Remove TODOs I don’t intend to fix yet",https://api.github.com/repos/facebook/react/git/commits/21d0c115238b4f38837020cf83e0c657d8c01c9f,2017-11-02,This is clearer because we can use ES imports in it
136,MDY6Q29tbWl0MTAyNzAyNTA6MjFkMGMxMTUyMzhiNGYzODgzNzAyMGNmODNlMGM2NTdkOGMwMWM5Zg==,Dan Abramov,GitHub,"Convert the Source to ES Modules (#11389)

* Update transforms to handle ES modules

* Update Jest to handle ES modules

* Convert react package to ES modules

* Convert react-art package to ES Modules

* Convert react-call-return package to ES Modules

* Convert react-test-renderer package to ES Modules

* Convert react-cs-renderer package to ES Modules

* Convert react-rt-renderer package to ES Modules

* Convert react-noop-renderer package to ES Modules

* Convert react-dom/server to ES modules

* Convert react-dom/{client,events,test-utils} to ES modules

* Convert react-dom/shared to ES modules

* Convert react-native-renderer to ES modules

* Convert react-reconciler to ES modules

* Convert events to ES modules

* Convert shared to ES modules

* Remove CommonJS support from transforms

* Move ReactDOMFB entry point code into react-dom/src

This is clearer because we can use ES imports in it.

* Fix Rollup shim configuration to work with ESM

* Fix incorrect comment

* Exclude external imports without side effects

* Fix ReactDOM FB build

* Remove TODOs I don’t intend to fix yet",https://api.github.com/repos/facebook/react/git/commits/21d0c115238b4f38837020cf83e0c657d8c01c9f,2017-11-02,
137,MDY6Q29tbWl0MTAyNzAyNTA6MmIzNTkyMzMxZWZkNGI0MWYxOWRlNTIxNTI4ZjY2NGI4NzAzOTNlNQ==,zombieJ,Dan Abramov,"Pass `pendingProps` as argument in `createWorkInProgress` (#11296)

* move to pendingProps to args

* update userFiber in ReactChildFiber

* prettier it

* prettier it

* move expirationTime to the last

* move expirationTime to the last on userFiber

* Move assignment",https://api.github.com/repos/facebook/react/git/commits/2b3592331efd4b41f19de521528f664b870393e5,2017-10-31,Pass `pendingProps` as argument in `createWorkInProgress` (#11296)
137,MDY6Q29tbWl0MTAyNzAyNTA6MmIzNTkyMzMxZWZkNGI0MWYxOWRlNTIxNTI4ZjY2NGI4NzAzOTNlNQ==,zombieJ,Dan Abramov,"Pass `pendingProps` as argument in `createWorkInProgress` (#11296)

* move to pendingProps to args

* update userFiber in ReactChildFiber

* prettier it

* prettier it

* move expirationTime to the last

* move expirationTime to the last on userFiber

* Move assignment",https://api.github.com/repos/facebook/react/git/commits/2b3592331efd4b41f19de521528f664b870393e5,2017-10-31,
138,MDY6Q29tbWl0MTAyNzAyNTA6NGNlNWRhN2FlZTkwYTM3M2YyZjM2ZDFiZWI1NTkwOTdhZjMwOTUyZQ==,Clement Hoang,GitHub,"Add Fragment as a named export to React (#10783)

* Add Fragment as a named export to React

* Remove extra tests for Fragment

* Change React.Fragment export to be a string '#fragment'

* Fix fragment special case to work with 1 child

* Add single child test for fragment export

* Move fragment definition to ReactEntry.js and render components for key warning tests

* Inline createFiberFromElementType into createFiberFromElement

* Update reconciliation to special case fragments

* Use same semantics as implicit childsets for ReactFragment

* Add more fragment state preservation tests

* Export symbol instead of string for fragments

* Fix rebase breakages

* Re-apply prettier at 1.2.2

* Merge branches in updateElement

* Remove unnecessary check

* Re-use createFiberFromFragment for fragment case

* Simplyify branches by adding type field to fragment fiber

* Move branching logic for fragments to broader methods when possible.

* Add more tests for fragments

* Address Dan's feedback

* Move REACT_FRAGMENT_TYPE into __DEV__ block for DCE

* Change hex representation of REACT_FRAGMENT_TYPE to follow convention

* Remove unnecessary branching and isArray checks

* Update test for preserving children state when keys are same

* Fix updateSlot bug and add more tests

* Make fragment tests more robust by using ops pattern

* Update jsx element validator to allow numbers and symbols

* Remove type field from fragment fiber

* Fork reconcileChildFibers instead of recursing

* Use ternary if condition

* Revamp fragment test suite:

- Add more coverage to fragment tests
- Use better names
- Remove useless Fragment component inside tests
- Remove useless tests so that tests are more concise

* Check output of renderer in fragment tests to ensure no silly business despite states being preserved

* Finish implementation of fragment reconciliation with desired behavior

* Add reverse render direction for fragment tests

* Remove unneeded fragment branch in updateElement

* Add more test cases for ReactFragment

* Handle childless fragment in reconciler

* Support fragment flattening in SSR

* Clean up ReactPartialRenderer

* Warn when non-key and children props are passed to fragments

* Add non-null key check back to updateSlot's array's case

* Add test for positional reconciliation in fragments

* Add warning for refs in fragments with stack trace",https://api.github.com/repos/facebook/react/git/commits/4ce5da7aee90a373f2f36d1beb559097af30952e,2017-10-31,Add Fragment as a named export to React (#10783)
138,MDY6Q29tbWl0MTAyNzAyNTA6NGNlNWRhN2FlZTkwYTM3M2YyZjM2ZDFiZWI1NTkwOTdhZjMwOTUyZQ==,Clement Hoang,GitHub,"Add Fragment as a named export to React (#10783)

* Add Fragment as a named export to React

* Remove extra tests for Fragment

* Change React.Fragment export to be a string '#fragment'

* Fix fragment special case to work with 1 child

* Add single child test for fragment export

* Move fragment definition to ReactEntry.js and render components for key warning tests

* Inline createFiberFromElementType into createFiberFromElement

* Update reconciliation to special case fragments

* Use same semantics as implicit childsets for ReactFragment

* Add more fragment state preservation tests

* Export symbol instead of string for fragments

* Fix rebase breakages

* Re-apply prettier at 1.2.2

* Merge branches in updateElement

* Remove unnecessary check

* Re-use createFiberFromFragment for fragment case

* Simplyify branches by adding type field to fragment fiber

* Move branching logic for fragments to broader methods when possible.

* Add more tests for fragments

* Address Dan's feedback

* Move REACT_FRAGMENT_TYPE into __DEV__ block for DCE

* Change hex representation of REACT_FRAGMENT_TYPE to follow convention

* Remove unnecessary branching and isArray checks

* Update test for preserving children state when keys are same

* Fix updateSlot bug and add more tests

* Make fragment tests more robust by using ops pattern

* Update jsx element validator to allow numbers and symbols

* Remove type field from fragment fiber

* Fork reconcileChildFibers instead of recursing

* Use ternary if condition

* Revamp fragment test suite:

- Add more coverage to fragment tests
- Use better names
- Remove useless Fragment component inside tests
- Remove useless tests so that tests are more concise

* Check output of renderer in fragment tests to ensure no silly business despite states being preserved

* Finish implementation of fragment reconciliation with desired behavior

* Add reverse render direction for fragment tests

* Remove unneeded fragment branch in updateElement

* Add more test cases for ReactFragment

* Handle childless fragment in reconciler

* Support fragment flattening in SSR

* Clean up ReactPartialRenderer

* Warn when non-key and children props are passed to fragments

* Add non-null key check back to updateSlot's array's case

* Add test for positional reconciliation in fragments

* Add warning for refs in fragments with stack trace",https://api.github.com/repos/facebook/react/git/commits/4ce5da7aee90a373f2f36d1beb559097af30952e,2017-10-31,"- Add more coverage to fragment tests
- Use better names
- Remove useless Fragment component inside tests
- Remove useless tests so that tests are more concise"
139,MDY6Q29tbWl0MTAyNzAyNTA6MmMwYThmYjk5ZTk0NTMxNWM5ZGNlN2ExNWM4NTc3NWQ1MWY1NzU1ZA==,Dan Abramov,GitHub,Add react-call-return package (#11364),https://api.github.com/repos/facebook/react/git/commits/2c0a8fb99e945315c9dce7a15c85775d51f5755d,2017-10-25,Add react-call-return package (#11364)
139,MDY6Q29tbWl0MTAyNzAyNTA6MmMwYThmYjk5ZTk0NTMxNWM5ZGNlN2ExNWM4NTc3NWQ1MWY1NzU1ZA==,Dan Abramov,GitHub,Add react-call-return package (#11364),https://api.github.com/repos/facebook/react/git/commits/2c0a8fb99e945315c9dce7a15c85775d51f5755d,2017-10-25,
140,MDY6Q29tbWl0MTAyNzAyNTA6MDg3YzQ4YmIzNmI4OGVmMGI1YmJjYTJiOWI3MGE1MmQ4ZDQxMzEwMg==,Dan Abramov,GitHub,"Reorder imports (#11359)

* Reorder imports

* Record sizes",https://api.github.com/repos/facebook/react/git/commits/087c48bb36b88ef0b5bbca2b9b70a52d8d413102,2017-10-25,Reorder imports (#11359)
140,MDY6Q29tbWl0MTAyNzAyNTA6MDg3YzQ4YmIzNmI4OGVmMGI1YmJjYTJiOWI3MGE1MmQ4ZDQxMzEwMg==,Dan Abramov,GitHub,"Reorder imports (#11359)

* Reorder imports

* Record sizes",https://api.github.com/repos/facebook/react/git/commits/087c48bb36b88ef0b5bbca2b9b70a52d8d413102,2017-10-25,
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,Drop Haste (#11303)
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,"
Either this is a showstopper or we can solve it by completely fobbidding remaining /src/"
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,"
It seems we can't use relative requires in tests anymore"
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,Otherwise Jest becomes confused between real file and symlink
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,"
This seems bad.."
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,Except that we already *don't* want people to create tests that import individual source files
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,"
All existing cases of us doing so are actually TODOs waiting to be fixed"
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,"
So perhaps this requirement isn't too bad because it makes bad code looks bad"
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,"
Of course, if we go with this, we'll have to lint against relative requires in tests"
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,"
It also makes moving things more painful"
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,"
Shouldn't affect correctness (they were ignored) but fixes DEV size regression"
141,MDY6Q29tbWl0MTAyNzAyNTA6MWVlZDMwMmQzNDZiZmI4ZjVkYjhkODhiMGU3MDk2ZDg5OTlkMzU0OA==,Dan Abramov,GitHub,"Drop Haste (#11303)

* Use relative paths in packages/react

* Use relative paths in packages/react-art

* Use relative paths in packages/react-cs

* Use relative paths in other packages

* Fix as many issues as I can

This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.

Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.

* Fix all tests

It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
https://github.com/facebook/jest/issues/3830

This seems bad... Except that we already *don't* want people to create tests that import individual source files.
All existing cases of us doing so are actually TODOs waiting to be fixed.

So perhaps this requirement isn't too bad because it makes bad code looks bad.

Of course, if we go with this, we'll have to lint against relative requires in tests.
It also makes moving things more painful.

* Prettier

* Remove @providesModule

* Fix remaining Haste imports I missed earlier

* Fix up paths to reflect new flat structure

* Fix Flow

* Fix CJS and UMD builds

* Fix FB bundles

* Fix RN bundles

* Prettier

* Fix lint

* Fix warning printing and error codes

* Fix buggy return

* Fix lint and Flow

* Use Yarn on CI

* Unbreak Jest

* Fix lint

* Fix aliased originals getting included in DEV

Shouldn't affect correctness (they were ignored) but fixes DEV size regression.

* Record sizes

* Fix weird version in package.json

* Tweak bundle labels

* Get rid of output option by introducing react-dom/server.node

* Reconciler should depend on prop-types

* Update sizes last time",https://api.github.com/repos/facebook/react/git/commits/1eed302d346bfb8f5db8d88b0e7096d8999d3548,2017-10-24,
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,[CS] Persistent Updates (#11260)
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"The extra ""root"" concept is kind of unnecessary"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"Then the ""commit"" just becomes
swapping the previous container for the new one"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
We may need to clone without any updates, e.g"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,when the children are changed
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,It's really only useful to for allocation pooling
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
This forks the update path for host fibers"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"For mutation mode we mark
them as having an effect"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"For persistence mode, we clone the stateNode with
new props/children"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
Next I'll do HostRoot and HostPortal"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
finalizeContainerChildren will get called at the complete phase"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
replaceContainer will get called at commit"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
Also, drop the keepChildren flag"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"We'll never keep children as we'll never
update a container if none of the children has changed"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
These are both ""containers"""
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"Normally we rely on placement/deletion effects
to deal with insertions into the containers"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"In the persistent mode we need
to clone the container and append all the changed children to it"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
I needed somewhere to store these new containers before they're committed
so I added another field"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
However, the real difference which one we call is depending on whether they
are equal"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,We can just offload that to the renderer
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"Most of them won't
need to know about this at all since they'll always clone or just create
new"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
This adds a test for bailouts"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,This revealed a subtle bug
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"We don't set the
return pointer when stepping into newly created fibers because there
can only be one"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
Found another bug"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
This creates a bit of an unfortunate feature testing in the unmount
branch"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
That's because we want to trigger nested host deletions in portals in the
mutation mode"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"Because
for persistent containers, there is no permanent identity"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
This makes it kind of strange to even use portals in this mode"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
We need container to stay as the persistent identity of the root atom"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
So that we can refer to portals over time"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"
Now containers are singletons and instead their children swap"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,"That way
portals can use the container as part of their identity again"
142,MDY6Q29tbWl0MTAyNzAyNTA6YjUyYTU2MjRlOTVmNzcxNjZmZmE1MjA0NzZkNjgyMzE2NDA2OTJmOQ==,Sebastian Markbåge,GitHub,"[CS] Persistent Updates (#11260)

* Update build size

* [CS] Clone container instead of new root concept

The extra ""root"" concept is kind of unnecessary. Instead of having a
mutable container even in the persistent mode, I'll instead make the
container be immutable too and be cloned. Then the ""commit"" just becomes
swapping the previous container for the new one.

* Change the signature or persistence again

We may need to clone without any updates, e.g. when the children are changed.

Passing in the previous node is not enough to recycle since it won't have the
up-to-date props and children. It's really only useful to for allocation pooling.

* Implement persistent updates

This forks the update path for host fibers. For mutation mode we mark
them as having an effect. For persistence mode, we clone the stateNode with
new props/children.

Next I'll do HostRoot and HostPortal.

* Refine protocol into a complete and commit phase

finalizeContainerChildren will get called at the complete phase.
replaceContainer will get called at commit.

Also, drop the keepChildren flag. We'll never keep children as we'll never
update a container if none of the children has changed.

* Implement persistent updates of roots and portals

These are both ""containers"". Normally we rely on placement/deletion effects
to deal with insertions into the containers. In the persistent mode we need
to clone the container and append all the changed children to it.

I needed somewhere to store these new containers before they're committed
so I added another field.

* Commit persistent work at the end by swapping out the container

* Unify cloneOrRecycle

Originally I tried to make the recyclable instance nullable but Flow didn't
like that and it's kind of sketchy since the instance type might not be
nullable.

However, the real difference which one we call is depending on whether they
are equal. We can just offload that to the renderer. Most of them won't
need to know about this at all since they'll always clone or just create
new.

The ones that do know now have to be careful to compare them so they don't
reuse an existing instance but that's probably fine to simplify the
implementation and API.

* Add persistent noop renderer for testing

* Add basic persistent tree test

* Test bail out

This adds a test for bailouts. This revealed a subtle bug. We don't set the
return pointer when stepping into newly created fibers because there
can only be one. However, since I'm reusing this mechanism for persistent
updates, I'll need to set the return pointer because a bailed out tree
won't have the right return pointer.

* Test persistent text nodes

Found another bug.

* Add persistent portal test

This creates a bit of an unfortunate feature testing in the unmount
branch.

That's because we want to trigger nested host deletions in portals in the
mutation mode.

* Don't consider container when determining portal identity

Basically, we can't use the container to determine if we should keep
identity and update an existing portal instead of recreate it. Because
for persistent containers, there is no permanent identity.

This makes it kind of strange to even use portals in this mode. It's
probably more ideal to have another concept that has permanent identity
rather than trying to swap out containers.

* Clear portals when the portal is deleted

When a portal gets deleted we need to create a new empty container and
replace the current one with the empty one.

* Add renderer mode flags for dead code elimination

* Simplify ReactNoop fix

* Add new type to the host config for persistent configs

We need container to stay as the persistent identity of the root atom.
So that we can refer to portals over time.

Instead, I'll introduce a new type just to temporarily hold the children
of a container until they're ready to be committed into the permanent
container. Essentially, this is just a fancy array that is not an array
so that the host can choose data structure/allocation for it.

* Implement new hooks

Now containers are singletons and instead their children swap. That way
portals can use the container as part of their identity again.

* Update build size and error codes

* Address comment

* Move new files to new location",https://api.github.com/repos/facebook/react/git/commits/b52a5624e95f77166ffa520476d68231640692f9,2017-10-19,
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,Use Yarn Workspaces (#11252)
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"This makes the test pass again, but breaks the build because npm/ folders aren't used yet"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
It is now unnecessary"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,Some tests fail though
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
Jest sees node_modules and thinks it's third party code"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
I'm not very happy with this and we should revisit"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
It's not super clear how to organize this properly yet"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
I didn't change this file but Flow started complaining"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
Caleb said this annotation was unnecessarily using $Abstract though so I removed it"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
Use file: instead of NODE_PATH since NODE_PATH"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,"
Verified that the page shows up"
143,MDY6Q29tbWl0MTAyNzAyNTA6ZDljMWRiZDYxNzcyZjhmOGFiMGNkZjM4OWU3MDQ2M2Q3MDRjNDgwYg==,Dan Abramov,GitHub,"Use Yarn Workspaces (#11252)

* Enable Yarn workspaces for packages/*

* Move src/isomorphic/* into packages/react/src/*

* Create index.js stubs for all packages in packages/*

This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.

* Put FB entry point for react-dom into packages/*

* Move src/renderers/testing/* into packages/react-test-renderer/src/*

Note that this is currently broken because Jest ignores node_modules,
and so Yarn linking makes Jest skip React source when transforming.

* Remove src/node_modules

It is now unnecessary. Some tests fail though.

* Add a hacky workaround for Jest/Workspaces issue

Jest sees node_modules and thinks it's third party code.

This is a hacky way to teach Jest to still transform anything in node_modules/react*
if it resolves outside of node_modules (such as to our packages/*) folder.

I'm not very happy with this and we should revisit.

* Add a fake react-native package

* Move src/renderers/art/* into packages/react-art/src/*

* Move src/renderers/noop/* into packages/react-noop-renderer/src/*

* Move src/renderers/dom/* into packages/react-dom/src/*

* Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*

* Move DOM/reconciler tests I previously forgot to move

* Move src/renderers/native-*/* into packages/react-native-*/src/*

* Move shared code into packages/shared

It's not super clear how to organize this properly yet.

* Add back files that somehow got lost

* Fix the build

* Prettier

* Add missing license headers

* Fix an issue that caused mocks to get included into build

* Update other references to src/

* Re-run Prettier

* Fix lint

* Fix weird Flow violation

I didn't change this file but Flow started complaining.
Caleb said this annotation was unnecessarily using $Abstract though so I removed it.

* Update sizes

* Fix stats script

* Fix packaging fixtures

Use file: instead of NODE_PATH since NODE_PATH.
NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.

file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
Verified that the page shows up.

* Fix art fixture

* Fix reconciler fixture

* Fix SSR fixture

* Rename native packages",https://api.github.com/repos/facebook/react/git/commits/d9c1dbd61772f8f8ab0cdf389e70463d704c480b,2017-10-18,
